import gql from "graphql-tag";
import { Injectable } from "@angular/core";
import * as Apollo from "apollo-angular";
export type Maybe<T> = T | null;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: any;
  LangJson: any;
  /** Represents untyped JSON */
  JSON: any;
  NodeDescription: any;
  QualifiedTypeName: any;
};

export type AdvancedNewsInputType = {
  order?: Maybe<NewsOrderType>;
  filter?: Maybe<NewsFilterFieldType>;
  languages?: Maybe<Array<LanguageEnum>>;
  textLength?: Maybe<TextLengthOptionsEnum>;
};

export type BlockLanguage = {
  __typename?: "BlockLanguage";
  codeResources?: Maybe<Array<CodeResource>>;
  createdAt?: Maybe<Scalars["ISO8601DateTime"]>;
  defaultProgrammingLanguage: ProgrammingLanguage;
  defaultProgrammingLanguageId: Scalars["ID"];
  editorBlocks: Scalars["JSON"];
  editorComponents: Scalars["JSON"];
  generated?: Maybe<Scalars["Boolean"]>;
  grammar?: Maybe<Grammar>;
  grammarId?: Maybe<Scalars["ID"]>;
  id: Scalars["ID"];
  localGeneratorInstructions?: Maybe<Scalars["JSON"]>;
  name: Scalars["String"];
  rootCssClasses: Array<Scalars["String"]>;
  sidebars: Scalars["JSON"];
  slug?: Maybe<Scalars["String"]>;
  updatedAt?: Maybe<Scalars["ISO8601DateTime"]>;
};

/** The connection type for BlockLanguage. */
export type BlockLanguageConnection = {
  __typename?: "BlockLanguageConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BlockLanguageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BlockLanguage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

export type BlockLanguageDescription = {
  __typename?: "BlockLanguageDescription";
  codeResources?: Maybe<Array<CodeResource>>;
  createdAt?: Maybe<Scalars["ISO8601DateTime"]>;
  defaultProgrammingLanguage: ProgrammingLanguage;
  defaultProgrammingLanguageId: Scalars["ID"];
  editorBlocks: Scalars["JSON"];
  editorComponents: Scalars["JSON"];
  generated?: Maybe<Scalars["Boolean"]>;
  grammar?: Maybe<Grammar>;
  grammarId?: Maybe<Scalars["ID"]>;
  id: Scalars["ID"];
  localGeneratorInstructions?: Maybe<Scalars["JSON"]>;
  name: Scalars["String"];
  rootCssClasses?: Maybe<Scalars["JSON"]>;
  sidebars: Scalars["JSON"];
  slug?: Maybe<Scalars["String"]>;
  updatedAt?: Maybe<Scalars["ISO8601DateTime"]>;
};

/** An edge in a connection. */
export type BlockLanguageEdge = {
  __typename?: "BlockLanguageEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<BlockLanguage>;
};

export type BlockLanguageFilterFieldType = {
  id?: Maybe<Scalars["ID"]>;
  name?: Maybe<Scalars["String"]>;
  slug?: Maybe<Scalars["String"]>;
  grammar?: Maybe<Scalars["String"]>;
};

export type BlockLanguageInputType = {
  order?: Maybe<BlockLanguageOrderType>;
  filter?: Maybe<BlockLanguageFilterFieldType>;
  languages?: Maybe<Array<LanguageEnum>>;
};

export type BlockLanguageOrderFieldEnum = "name" | "slug" | "grammar";

export type BlockLanguageOrderType = {
  orderField?: Maybe<BlockLanguageOrderFieldEnum>;
  orderDirection?: Maybe<OrderDirectionEnum>;
};

export type CodeResource = {
  __typename?: "CodeResource";
  ast?: Maybe<Scalars["NodeDescription"]>;
  blockLanguage: BlockLanguage;
  blockLanguageId: Scalars["ID"];
  compiled?: Maybe<Scalars["String"]>;
  createdAt?: Maybe<Scalars["ISO8601DateTime"]>;
  grammars?: Maybe<Grammar>;
  id: Scalars["ID"];
  name: Scalars["String"];
  programmingLanguage: ProgrammingLanguage;
  programmingLanguageId: Scalars["ID"];
  project: Project;
  updatedAt?: Maybe<Scalars["ISO8601DateTime"]>;
};

/** The connection type for CodeResource. */
export type CodeResourceConnection = {
  __typename?: "CodeResourceConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CodeResourceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CodeResource>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type CodeResourceEdge = {
  __typename?: "CodeResourceEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<CodeResource>;
};

export type CodeResourceFilterFieldType = {
  id?: Maybe<Scalars["ID"]>;
  name?: Maybe<Scalars["String"]>;
  programmingLanguageId?: Maybe<Scalars["ID"]>;
};

export type CodeResourceInputType = {
  order?: Maybe<CodeResourceOrderType>;
  filter?: Maybe<CodeResourceFilterFieldType>;
  languages?: Maybe<Array<LanguageEnum>>;
};

export type CodeResourceOrderFieldEnum = "name";

export type CodeResourceOrderType = {
  orderField?: Maybe<CodeResourceOrderFieldEnum>;
  orderDirection?: Maybe<OrderDirectionEnum>;
};

/** Autogenerated input type of CreateBlockLanguage */
export type CreateBlockLanguageInput = {
  name: Scalars["String"];
  slug?: Maybe<Scalars["String"]>;
  defaultProgrammingLanguageId?: Maybe<Scalars["ID"]>;
  grammarId?: Maybe<Scalars["ID"]>;
  sidebars: Scalars["JSON"];
  editorBlocks: Scalars["JSON"];
  editorComponents: Scalars["JSON"];
  rootCssClasses?: Maybe<Scalars["JSON"]>;
  localGeneratorInstructions?: Maybe<Scalars["JSON"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of CreateBlockLanguage */
export type CreateBlockLanguagePayload = {
  __typename?: "CreateBlockLanguagePayload";
  blockLanguage?: Maybe<BlockLanguage>;
  blockLanguageDescription?: Maybe<BlockLanguageDescription>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  errors: Array<Scalars["String"]>;
  id?: Maybe<Scalars["ID"]>;
};

/** Autogenerated input type of CreateGrammar */
export type CreateGrammarInput = {
  name: Scalars["String"];
  slug?: Maybe<Scalars["String"]>;
  types: Scalars["JSON"];
  foreignTypes?: Maybe<Scalars["JSON"]>;
  root?: Maybe<Scalars["QualifiedTypeName"]>;
  programmingLanguageId: Scalars["ID"];
  generatedFromId?: Maybe<Scalars["ID"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of CreateGrammar */
export type CreateGrammarPayload = {
  __typename?: "CreateGrammarPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  errors: Array<Scalars["String"]>;
  grammar?: Maybe<Grammar>;
};

/** Autogenerated input type of CreateNews */
export type CreateNewsInput = {
  title: Scalars["LangJson"];
  text: Scalars["LangJson"];
  publishedFrom: Scalars["ISO8601DateTime"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of CreateNews */
export type CreateNewsPayload = {
  __typename?: "CreateNewsPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  errors: Array<Scalars["String"]>;
  id?: Maybe<Scalars["ID"]>;
  news?: Maybe<News>;
};

/** Autogenerated input type of CreateProject */
export type CreateProjectInput = {
  name: Scalars["LangJson"];
  slug: Scalars["String"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of CreateProject */
export type CreateProjectPayload = {
  __typename?: "CreateProjectPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  errors: Array<Scalars["String"]>;
  id?: Maybe<Scalars["ID"]>;
};

export type DateTimeFilter = {
  date?: Maybe<Scalars["ISO8601DateTime"]>;
  until: Scalars["Boolean"];
};

/** Autogenerated input type of DestroyBlockLanguage */
export type DestroyBlockLanguageInput = {
  id: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of DestroyBlockLanguage */
export type DestroyBlockLanguagePayload = {
  __typename?: "DestroyBlockLanguagePayload";
  blockLanguage?: Maybe<BlockLanguage>;
  blockLanguageDescription?: Maybe<BlockLanguageDescription>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  errors: Array<Scalars["String"]>;
  id?: Maybe<Scalars["ID"]>;
};

/** Autogenerated input type of DestroyGrammar */
export type DestroyGrammarInput = {
  id: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of DestroyGrammar */
export type DestroyGrammarPayload = {
  __typename?: "DestroyGrammarPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  errors: Array<Scalars["String"]>;
  grammar?: Maybe<Grammar>;
};

/** Autogenerated input type of DestroyNews */
export type DestroyNewsInput = {
  id?: Maybe<Scalars["ID"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of DestroyNews */
export type DestroyNewsPayload = {
  __typename?: "DestroyNewsPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  errors: Array<Scalars["String"]>;
  id?: Maybe<Scalars["ID"]>;
  news?: Maybe<News>;
};

export type Grammar = {
  __typename?: "Grammar";
  blockLanguages?: Maybe<BlockLanguageConnection>;
  codeResources?: Maybe<CodeResourceConnection>;
  createdAt: Scalars["ISO8601DateTime"];
  foreignTypes: Scalars["JSON"];
  generatedFrom?: Maybe<CodeResource>;
  generatedFromId?: Maybe<Scalars["ID"]>;
  id: Scalars["ID"];
  includes?: Maybe<Array<Scalars["ID"]>>;
  name: Scalars["String"];
  programmingLanguage: ProgrammingLanguage;
  programmingLanguageId: Scalars["ID"];
  root?: Maybe<Scalars["QualifiedTypeName"]>;
  slug?: Maybe<Scalars["String"]>;
  types: Scalars["JSON"];
  updatedAt: Scalars["ISO8601DateTime"];
  visualizes?: Maybe<Array<Scalars["ID"]>>;
};

export type GrammarBlockLanguagesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

export type GrammarCodeResourcesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

/** The connection type for Grammar. */
export type GrammarConnection = {
  __typename?: "GrammarConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GrammarEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Grammar>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type GrammarEdge = {
  __typename?: "GrammarEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<Grammar>;
};

export type GrammarFilterFieldType = {
  id?: Maybe<Scalars["ID"]>;
  name?: Maybe<Scalars["String"]>;
  slug?: Maybe<Scalars["String"]>;
};

export type GrammarInputType = {
  order?: Maybe<GrammarOrderType>;
  filter?: Maybe<GrammarFilterFieldType>;
  languages?: Maybe<Array<LanguageEnum>>;
};

export type GrammarOrderFieldEnum = "name" | "slug";

export type GrammarOrderType = {
  orderField?: Maybe<GrammarOrderFieldEnum>;
  orderDirection?: Maybe<OrderDirectionEnum>;
};

export type Identity = {
  __typename?: "Identity";
  createdAt?: Maybe<Scalars["ISO8601DateTime"]>;
  id: Scalars["ID"];
  ownData?: Maybe<Scalars["JSON"]>;
  provider: Scalars["String"];
  providerData?: Maybe<Scalars["JSON"]>;
  type: Scalars["String"];
  updatedAt?: Maybe<Scalars["ISO8601DateTime"]>;
  user: User;
};

export type LanguageEnum = "de" | "en";

export type Mutation = {
  __typename?: "Mutation";
  createBlockLanguage?: Maybe<CreateBlockLanguagePayload>;
  createGrammar?: Maybe<CreateGrammarPayload>;
  createNews?: Maybe<CreateNewsPayload>;
  createProject?: Maybe<CreateProjectPayload>;
  destroyBlockLanguage?: Maybe<DestroyBlockLanguagePayload>;
  destroyGrammar?: Maybe<DestroyGrammarPayload>;
  destroyNews?: Maybe<DestroyNewsPayload>;
  regenerateForeignTypes?: Maybe<RegenerateForeignTypesPayload>;
  updateBlockLanguage?: Maybe<UpdateBlockLanguagePayload>;
  updateGrammar?: Maybe<UpdateGrammarPayload>;
  updateNews?: Maybe<UpdateNewsPayload>;
};

export type MutationCreateBlockLanguageArgs = {
  input: CreateBlockLanguageInput;
};

export type MutationCreateGrammarArgs = {
  input: CreateGrammarInput;
};

export type MutationCreateNewsArgs = {
  input: CreateNewsInput;
};

export type MutationCreateProjectArgs = {
  input: CreateProjectInput;
};

export type MutationDestroyBlockLanguageArgs = {
  input: DestroyBlockLanguageInput;
};

export type MutationDestroyGrammarArgs = {
  input: DestroyGrammarInput;
};

export type MutationDestroyNewsArgs = {
  input: DestroyNewsInput;
};

export type MutationRegenerateForeignTypesArgs = {
  input: RegenerateForeignTypesInput;
};

export type MutationUpdateBlockLanguageArgs = {
  input: UpdateBlockLanguageInput;
};

export type MutationUpdateGrammarArgs = {
  input: UpdateGrammarInput;
};

export type MutationUpdateNewsArgs = {
  input: UpdateNewsInput;
};

export type News = {
  __typename?: "News";
  createdAt?: Maybe<Scalars["ISO8601DateTime"]>;
  id: Scalars["ID"];
  publishedFrom?: Maybe<Scalars["ISO8601DateTime"]>;
  text: Scalars["LangJson"];
  title: Scalars["LangJson"];
  updatedAt?: Maybe<Scalars["ISO8601DateTime"]>;
  user?: Maybe<User>;
  userId?: Maybe<Scalars["ID"]>;
};

/** The connection type for News. */
export type NewsConnection = {
  __typename?: "NewsConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NewsEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<News>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type NewsEdge = {
  __typename?: "NewsEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<News>;
};

export type NewsFilterFieldType = {
  id?: Maybe<Scalars["ID"]>;
  title?: Maybe<Scalars["String"]>;
  text?: Maybe<Scalars["String"]>;
  userId?: Maybe<Scalars["String"]>;
  publishedFrom?: Maybe<DateTimeFilter>;
};

export type NewsInputType = {
  order?: Maybe<NewsOrderType>;
  filter?: Maybe<NewsFilterFieldType>;
  languages?: Maybe<Array<LanguageEnum>>;
};

export type NewsOrderFieldEnum =
  | "title"
  | "publishedFrom"
  | "createdAt"
  | "updatedAt";

export type NewsOrderType = {
  orderField?: Maybe<NewsOrderFieldEnum>;
  orderDirection?: Maybe<OrderDirectionEnum>;
};

export type OrderDirectionEnum = "asc" | "desc";

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: "PageInfo";
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars["String"]>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars["Boolean"];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars["Boolean"];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars["String"]>;
};

export type ProgrammingLanguage = {
  __typename?: "ProgrammingLanguage";
  id: Scalars["ID"];
  name: Scalars["String"];
};

/** The connection type for ProgrammingLanguage. */
export type ProgrammingLanguageConnection = {
  __typename?: "ProgrammingLanguageConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProgrammingLanguageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProgrammingLanguage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type ProgrammingLanguageEdge = {
  __typename?: "ProgrammingLanguageEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<ProgrammingLanguage>;
};

export type Project = {
  __typename?: "Project";
  blockLanguages: Array<BlockLanguage>;
  codeResourceCount?: Maybe<Scalars["Int"]>;
  codeResources: Array<CodeResource>;
  createdAt?: Maybe<Scalars["ISO8601DateTime"]>;
  defaultDatabase?: Maybe<ProjectDatabase>;
  defaultDatabaseId?: Maybe<Scalars["ID"]>;
  description: Scalars["LangJson"];
  grammars: Array<Grammar>;
  id: Scalars["ID"];
  indexPageId?: Maybe<Scalars["String"]>;
  name: Scalars["LangJson"];
  preview?: Maybe<Scalars["String"]>;
  projectSources: Array<ProjectSource>;
  projectUsesBlockLanguages: Array<ProjectUsesBlockLanguage>;
  public?: Maybe<Scalars["Boolean"]>;
  schema: Array<SqlTable>;
  slug?: Maybe<Scalars["String"]>;
  updatedAt?: Maybe<Scalars["ISO8601DateTime"]>;
  user?: Maybe<User>;
  userId?: Maybe<Scalars["ID"]>;
};

/** The connection type for Project. */
export type ProjectConnection = {
  __typename?: "ProjectConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Project>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

export type ProjectDatabase = {
  __typename?: "ProjectDatabase";
  createdAt: Scalars["ISO8601DateTime"];
  id: Scalars["ID"];
  name?: Maybe<Scalars["String"]>;
  project?: Maybe<Project>;
  schema?: Maybe<Scalars["JSON"]>;
  updatedAt: Scalars["ISO8601DateTime"];
};

/** The connection type for ProjectDatabase. */
export type ProjectDatabaseConnection = {
  __typename?: "ProjectDatabaseConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectDatabaseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectDatabase>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type ProjectDatabaseEdge = {
  __typename?: "ProjectDatabaseEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectDatabase>;
};

/** An edge in a connection. */
export type ProjectEdge = {
  __typename?: "ProjectEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<Project>;
};

export type ProjectFilterFieldType = {
  id?: Maybe<Scalars["ID"]>;
  name?: Maybe<Scalars["String"]>;
  slug?: Maybe<Scalars["String"]>;
  public?: Maybe<Scalars["Boolean"]>;
};

export type ProjectInputType = {
  order?: Maybe<ProjectOrderType>;
  filter?: Maybe<ProjectFilterFieldType>;
  languages?: Maybe<Array<LanguageEnum>>;
};

export type ProjectOrderFieldEnum = "name" | "slug";

export type ProjectOrderType = {
  orderField?: Maybe<ProjectOrderFieldEnum>;
  orderDirection?: Maybe<OrderDirectionEnum>;
};

export type ProjectSource = {
  __typename?: "ProjectSource";
  createdAt?: Maybe<Scalars["ISO8601DateTime"]>;
  display: Scalars["String"];
  id: Scalars["ID"];
  kind: ProjectSourceKind;
  project: Project;
  readOnly: Scalars["Boolean"];
  title: Scalars["String"];
  updatedAt?: Maybe<Scalars["ISO8601DateTime"]>;
  url: Scalars["String"];
};

/** The connection type for ProjectSource. */
export type ProjectSourceConnection = {
  __typename?: "ProjectSourceConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectSourceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectSource>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars["Int"];
};

/** An edge in a connection. */
export type ProjectSourceEdge = {
  __typename?: "ProjectSourceEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectSource>;
};

export type ProjectSourceKind = "data";

export type ProjectUsesBlockLanguage = {
  __typename?: "ProjectUsesBlockLanguage";
  blockLanguage: BlockLanguage;
  blockLanguageId: Scalars["ID"];
  id: Scalars["ID"];
  project: Project;
  projectId: Scalars["ID"];
};

export type Query = {
  __typename?: "Query";
  adminSingleNews: News;
  blockLanguages: BlockLanguageConnection;
  codeResources: CodeResourceConnection;
  frontpageListNews: NewsConnection;
  frontpageSingleNews: News;
  grammars: GrammarConnection;
  news: NewsConnection;
  programmingLanguages: ProgrammingLanguageConnection;
  projectDatabases: ProjectDatabaseConnection;
  projectSources: ProjectSourceConnection;
  projects: ProjectConnection;
  singleBlockLanguage: BlockLanguageDescription;
  singleGrammar: Grammar;
  singleProject: Project;
};

export type QueryAdminSingleNewsArgs = {
  id: Scalars["ID"];
};

export type QueryBlockLanguagesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  input?: Maybe<BlockLanguageInputType>;
};

export type QueryCodeResourcesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  input?: Maybe<CodeResourceInputType>;
};

export type QueryFrontpageListNewsArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  input?: Maybe<AdvancedNewsInputType>;
};

export type QueryFrontpageSingleNewsArgs = {
  id: Scalars["ID"];
};

export type QueryGrammarsArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  input?: Maybe<GrammarInputType>;
};

export type QueryNewsArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  input?: Maybe<NewsInputType>;
};

export type QueryProgrammingLanguagesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

export type QueryProjectDatabasesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

export type QueryProjectSourcesArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

export type QueryProjectsArgs = {
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
  input?: Maybe<ProjectInputType>;
};

export type QuerySingleBlockLanguageArgs = {
  id: Scalars["ID"];
};

export type QuerySingleGrammarArgs = {
  id: Scalars["ID"];
};

export type QuerySingleProjectArgs = {
  id: Scalars["ID"];
};

/** Autogenerated input type of RegenerateForeignTypes */
export type RegenerateForeignTypesInput = {
  id: Scalars["ID"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of RegenerateForeignTypes */
export type RegenerateForeignTypesPayload = {
  __typename?: "RegenerateForeignTypesPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  grammar: Grammar;
};

export type Role = {
  __typename?: "Role";
  createdAt: Scalars["ISO8601DateTime"];
  id: Scalars["ID"];
  name?: Maybe<Scalars["String"]>;
  resourceId?: Maybe<Scalars["String"]>;
  resourceType?: Maybe<Scalars["String"]>;
  updatedAt: Scalars["ISO8601DateTime"];
  users?: Maybe<Array<User>>;
};

export type SqlColumn = {
  __typename?: "SqlColumn";
  dfltValue?: Maybe<Scalars["String"]>;
  index: Scalars["Int"];
  name: Scalars["String"];
  notNull: Scalars["Boolean"];
  primary: Scalars["Boolean"];
  type: Scalars["String"];
};

export type SqlForeignKey = {
  __typename?: "SqlForeignKey";
  references: Array<SqlForeignKeyReference>;
};

export type SqlForeignKeyReference = {
  __typename?: "SqlForeignKeyReference";
  fromColumn: Scalars["String"];
  toColumn: Scalars["String"];
  toTable: Scalars["String"];
};

export type SqlTable = {
  __typename?: "SqlTable";
  columns: Array<SqlColumn>;
  foreignKeys: Array<SqlForeignKey>;
  name: Scalars["String"];
  systemTable: Scalars["Boolean"];
};

export type TextLengthOptionsEnum = "short" | "long";

/** Autogenerated input type of UpdateBlockLanguage */
export type UpdateBlockLanguageInput = {
  id?: Maybe<Scalars["ID"]>;
  name?: Maybe<Scalars["String"]>;
  slug?: Maybe<Scalars["String"]>;
  defaultProgrammingLanguageId?: Maybe<Scalars["ID"]>;
  grammarId?: Maybe<Scalars["ID"]>;
  sidebars?: Maybe<Scalars["JSON"]>;
  editorBlocks?: Maybe<Scalars["JSON"]>;
  rootCssClasses?: Maybe<Scalars["JSON"]>;
  editorComponents?: Maybe<Scalars["JSON"]>;
  localGeneratorInstructions?: Maybe<Scalars["JSON"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateBlockLanguage */
export type UpdateBlockLanguagePayload = {
  __typename?: "UpdateBlockLanguagePayload";
  blockLanguage?: Maybe<BlockLanguage>;
  blockLanguageDescription?: Maybe<BlockLanguageDescription>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  errors: Array<Scalars["String"]>;
  id?: Maybe<Scalars["ID"]>;
};

/** Autogenerated input type of UpdateGrammar */
export type UpdateGrammarInput = {
  id?: Maybe<Scalars["ID"]>;
  name?: Maybe<Scalars["String"]>;
  slug?: Maybe<Scalars["String"]>;
  types?: Maybe<Scalars["JSON"]>;
  foreignTypes?: Maybe<Scalars["JSON"]>;
  root?: Maybe<Scalars["QualifiedTypeName"]>;
  programmingLanguageId?: Maybe<Scalars["ID"]>;
  generatedFromId?: Maybe<Scalars["ID"]>;
  blockLanguageIds?: Maybe<Array<Scalars["ID"]>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateGrammar */
export type UpdateGrammarPayload = {
  __typename?: "UpdateGrammarPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  errors: Array<Scalars["String"]>;
  grammar?: Maybe<Grammar>;
};

/** Autogenerated input type of UpdateNews */
export type UpdateNewsInput = {
  id?: Maybe<Scalars["ID"]>;
  title?: Maybe<Scalars["LangJson"]>;
  text?: Maybe<Scalars["LangJson"]>;
  publishedFrom?: Maybe<Scalars["ISO8601DateTime"]>;
  userId?: Maybe<Scalars["ID"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateNews */
export type UpdateNewsPayload = {
  __typename?: "UpdateNewsPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]>;
  errors: Array<Scalars["String"]>;
  id?: Maybe<Scalars["ID"]>;
  news?: Maybe<News>;
};

export type User = {
  __typename?: "User";
  createdAt: Scalars["ISO8601DateTime"];
  displayName?: Maybe<Scalars["String"]>;
  email?: Maybe<Scalars["String"]>;
  id: Scalars["ID"];
  identities?: Maybe<Array<Identity>>;
  news?: Maybe<Array<News>>;
  projects?: Maybe<Array<Project>>;
  roles: Role;
  updatedAt: Scalars["ISO8601DateTime"];
};

export type AdminMetaCodeResourcesQueryVariables = {
  programmingLanguageId: Scalars["ID"];
};

export type AdminMetaCodeResourcesQuery = { __typename?: "Query" } & {
  codeResources: { __typename?: "CodeResourceConnection" } & {
    nodes?: Maybe<
      Array<
        Maybe<
          { __typename?: "CodeResource" } & Pick<CodeResource, "id" | "name">
        >
      >
    >;
  };
};

export type CodeResourcesGalleryQueryVariables = {
  id: Scalars["ID"];
};

export type CodeResourcesGalleryQuery = { __typename?: "Query" } & {
  codeResources: { __typename?: "CodeResourceConnection" } & {
    nodes?: Maybe<
      Array<
        Maybe<
          { __typename?: "CodeResource" } & Pick<CodeResource, "id" | "name">
        >
      >
    >;
  };
};

export type CreateProjectMutationVariables = {
  name: Scalars["LangJson"];
  slug: Scalars["String"];
};

export type CreateProjectMutation = { __typename?: "Mutation" } & {
  createProject?: Maybe<
    { __typename?: "CreateProjectPayload" } & Pick<
      CreateProjectPayload,
      "errors" | "id"
    >
  >;
};

export type AdminListProjectsQueryVariables = {
  first?: Maybe<Scalars["Int"]>;
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  last?: Maybe<Scalars["Int"]>;
  input?: Maybe<ProjectInputType>;
};

export type AdminListProjectsQuery = { __typename?: "Query" } & {
  projects: { __typename?: "ProjectConnection" } & Pick<
    ProjectConnection,
    "totalCount"
  > & {
      nodes?: Maybe<
        Array<
          Maybe<
            { __typename?: "Project" } & Pick<
              Project,
              "id" | "name" | "slug" | "codeResourceCount"
            >
          >
        >
      >;
      pageInfo: { __typename?: "PageInfo" } & Pick<
        PageInfo,
        "hasPreviousPage" | "hasNextPage" | "startCursor" | "endCursor"
      >;
    };
};

export type FrontpageListProjectsQueryVariables = {};

export type FrontpageListProjectsQuery = { __typename?: "Query" } & {
  projects: { __typename?: "ProjectConnection" } & {
    nodes?: Maybe<
      Array<
        Maybe<
          { __typename?: "Project" } & Pick<
            Project,
            | "id"
            | "slug"
            | "name"
            | "public"
            | "description"
            | "preview"
            | "indexPageId"
            | "createdAt"
            | "updatedAt"
            | "userId"
          > & {
              blockLanguages: Array<
                { __typename?: "BlockLanguage" } & {
                  defaultProgrammingLanguage: {
                    __typename?: "ProgrammingLanguage";
                  } & Pick<ProgrammingLanguage, "id" | "name">;
                }
              >;
            }
        >
      >
    >;
  };
};

export type AdminEditBlockLanguageQueryVariables = {
  id: Scalars["ID"];
};

export type AdminEditBlockLanguageQuery = { __typename?: "Query" } & {
  singleBlockLanguage: { __typename?: "BlockLanguageDescription" } & Pick<
    BlockLanguageDescription,
    | "id"
    | "name"
    | "slug"
    | "generated"
    | "grammarId"
    | "sidebars"
    | "editorBlocks"
    | "editorComponents"
    | "rootCssClasses"
    | "localGeneratorInstructions"
    | "createdAt"
    | "updatedAt"
    | "defaultProgrammingLanguageId"
  >;
};

export type AdminListBlockLanguagesQueryVariables = {
  first?: Maybe<Scalars["Int"]>;
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  last?: Maybe<Scalars["Int"]>;
  input?: Maybe<BlockLanguageInputType>;
};

export type AdminListBlockLanguagesQuery = { __typename?: "Query" } & {
  blockLanguages: { __typename?: "BlockLanguageConnection" } & Pick<
    BlockLanguageConnection,
    "totalCount"
  > & {
      nodes?: Maybe<
        Array<
          Maybe<
            { __typename?: "BlockLanguage" } & Pick<
              BlockLanguage,
              "id" | "name" | "slug" | "generated" | "grammarId"
            >
          >
        >
      >;
      pageInfo: { __typename?: "PageInfo" } & Pick<
        PageInfo,
        "hasPreviousPage" | "hasNextPage" | "startCursor" | "endCursor"
      >;
    };
};

export type AdminListGrammarsQueryVariables = {
  first?: Maybe<Scalars["Int"]>;
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  last?: Maybe<Scalars["Int"]>;
  input?: Maybe<GrammarInputType>;
};

export type AdminListGrammarsQuery = { __typename?: "Query" } & {
  grammars: { __typename?: "GrammarConnection" } & Pick<
    GrammarConnection,
    "totalCount"
  > & {
      nodes?: Maybe<
        Array<
          Maybe<
            { __typename?: "Grammar" } & Pick<
              Grammar,
              "id" | "name" | "slug" | "programmingLanguageId"
            >
          >
        >
      >;
      pageInfo: { __typename?: "PageInfo" } & Pick<
        PageInfo,
        "hasPreviousPage" | "hasNextPage" | "startCursor" | "endCursor"
      >;
    };
};

export type AdminListNewsQueryVariables = {
  first?: Maybe<Scalars["Int"]>;
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  last?: Maybe<Scalars["Int"]>;
  input?: Maybe<NewsInputType>;
};

export type AdminListNewsQuery = { __typename?: "Query" } & {
  news: { __typename?: "NewsConnection" } & Pick<
    NewsConnection,
    "totalCount"
  > & {
      nodes?: Maybe<
        Array<
          Maybe<
            { __typename?: "News" } & Pick<
              News,
              | "id"
              | "title"
              | "text"
              | "publishedFrom"
              | "createdAt"
              | "updatedAt"
              | "userId"
            >
          >
        >
      >;
      pageInfo: { __typename?: "PageInfo" } & Pick<
        PageInfo,
        "hasPreviousPage" | "hasNextPage" | "startCursor" | "endCursor"
      >;
    };
};

export type AdminSingleGrammarQueryVariables = {
  id: Scalars["ID"];
};

export type AdminSingleGrammarQuery = { __typename?: "Query" } & {
  singleGrammar: { __typename?: "Grammar" } & Pick<
    Grammar,
    | "id"
    | "name"
    | "programmingLanguageId"
    | "slug"
    | "generatedFromId"
    | "foreignTypes"
    | "root"
    | "types"
    | "includes"
    | "visualizes"
  > & {
      blockLanguages?: Maybe<
        { __typename?: "BlockLanguageConnection" } & {
          nodes?: Maybe<
            Array<
              Maybe<
                { __typename?: "BlockLanguage" } & Pick<
                  BlockLanguage,
                  "id" | "name"
                >
              >
            >
          >;
        }
      >;
    };
};

export type AdminSingleNewsQueryVariables = {
  id: Scalars["ID"];
};

export type AdminSingleNewsQuery = { __typename?: "Query" } & {
  adminSingleNews: { __typename?: "News" } & Pick<
    News,
    | "id"
    | "title"
    | "text"
    | "publishedFrom"
    | "createdAt"
    | "updatedAt"
    | "userId"
  >;
};

export type CreateBlockLanguageMutationVariables = {
  name: Scalars["String"];
  slug?: Maybe<Scalars["String"]>;
  defaultProgrammingLanguageId?: Maybe<Scalars["ID"]>;
  grammarId?: Maybe<Scalars["ID"]>;
  sidebars: Scalars["JSON"];
  editorBlocks: Scalars["JSON"];
  editorComponents: Scalars["JSON"];
  rootCssClasses?: Maybe<Scalars["JSON"]>;
  localGeneratorInstructions?: Maybe<Scalars["JSON"]>;
};

export type CreateBlockLanguageMutation = { __typename?: "Mutation" } & {
  createBlockLanguage?: Maybe<
    { __typename?: "CreateBlockLanguagePayload" } & Pick<
      CreateBlockLanguagePayload,
      "id" | "errors"
    >
  >;
};

export type CreateGrammarMutationVariables = {
  name: Scalars["String"];
  slug?: Maybe<Scalars["String"]>;
  types: Scalars["JSON"];
  foreignTypes?: Maybe<Scalars["JSON"]>;
  root?: Maybe<Scalars["QualifiedTypeName"]>;
  programmingLanguageId: Scalars["ID"];
};

export type CreateGrammarMutation = { __typename?: "Mutation" } & {
  createGrammar?: Maybe<
    { __typename?: "CreateGrammarPayload" } & Pick<
      CreateGrammarPayload,
      "errors"
    > & {
        grammar?: Maybe<
          { __typename?: "Grammar" } & Pick<
            Grammar,
            | "id"
            | "name"
            | "programmingLanguageId"
            | "slug"
            | "generatedFromId"
            | "foreignTypes"
            | "root"
            | "types"
            | "visualizes"
            | "includes"
          > & {
              blockLanguages?: Maybe<
                { __typename?: "BlockLanguageConnection" } & {
                  nodes?: Maybe<
                    Array<
                      Maybe<
                        { __typename?: "BlockLanguage" } & Pick<
                          BlockLanguage,
                          "id" | "name"
                        >
                      >
                    >
                  >;
                }
              >;
            }
        >;
      }
  >;
};

export type CreateNewsMutationVariables = {
  title: Scalars["LangJson"];
  text: Scalars["LangJson"];
  publishedFrom: Scalars["ISO8601DateTime"];
};

export type CreateNewsMutation = { __typename?: "Mutation" } & {
  createNews?: Maybe<
    { __typename?: "CreateNewsPayload" } & Pick<CreateNewsPayload, "errors"> & {
        news?: Maybe<
          { __typename?: "News" } & Pick<
            News,
            | "id"
            | "createdAt"
            | "updatedAt"
            | "publishedFrom"
            | "text"
            | "title"
            | "userId"
          >
        >;
      }
  >;
};

export type DestroyBlockLanguageMutationVariables = {
  id: Scalars["ID"];
};

export type DestroyBlockLanguageMutation = { __typename?: "Mutation" } & {
  destroyBlockLanguage?: Maybe<
    { __typename?: "DestroyBlockLanguagePayload" } & Pick<
      DestroyBlockLanguagePayload,
      "id" | "errors"
    >
  >;
};

export type DestroyGrammarMutationVariables = {
  id: Scalars["ID"];
};

export type DestroyGrammarMutation = { __typename?: "Mutation" } & {
  destroyGrammar?: Maybe<
    { __typename?: "DestroyGrammarPayload" } & Pick<
      DestroyGrammarPayload,
      "errors"
    >
  >;
};

export type DestroyNewsMutationVariables = {
  id: Scalars["ID"];
};

export type DestroyNewsMutation = { __typename?: "Mutation" } & {
  destroyNews?: Maybe<
    { __typename?: "DestroyNewsPayload" } & Pick<
      DestroyNewsPayload,
      "id" | "errors"
    >
  >;
};

export type FrontpageListNewsQueryVariables = {
  languages?: Maybe<Array<LanguageEnum>>;
};

export type FrontpageListNewsQuery = { __typename?: "Query" } & {
  frontpageListNews: { __typename?: "NewsConnection" } & {
    nodes?: Maybe<
      Array<
        Maybe<
          { __typename?: "News" } & Pick<
            News,
            "id" | "title" | "text" | "publishedFrom"
          >
        >
      >
    >;
  };
};

export type FrontpageSingleNewsQueryVariables = {
  id: Scalars["ID"];
};

export type FrontpageSingleNewsQuery = { __typename?: "Query" } & {
  frontpageSingleNews: { __typename?: "News" } & Pick<
    News,
    "id" | "title" | "text" | "publishedFrom"
  >;
};

export type FullProjectQueryVariables = {
  id: Scalars["ID"];
};

export type FullProjectQuery = { __typename?: "Query" } & {
  projects: { __typename?: "ProjectConnection" } & {
    nodes?: Maybe<
      Array<
        Maybe<
          { __typename?: "Project" } & Pick<
            Project,
            "id" | "slug" | "name" | "description" | "public" | "indexPageId"
          > & {
              codeResources: Array<
                { __typename?: "CodeResource" } & Pick<
                  CodeResource,
                  | "id"
                  | "name"
                  | "ast"
                  | "blockLanguageId"
                  | "programmingLanguageId"
                >
              >;
              blockLanguages: Array<
                { __typename?: "BlockLanguage" } & Pick<
                  BlockLanguage,
                  | "id"
                  | "name"
                  | "sidebars"
                  | "editorBlocks"
                  | "editorComponents"
                  | "localGeneratorInstructions"
                  | "rootCssClasses"
                  | "grammarId"
                  | "defaultProgrammingLanguageId"
                >
              >;
              grammars: Array<
                { __typename?: "Grammar" } & Pick<
                  Grammar,
                  | "id"
                  | "name"
                  | "root"
                  | "types"
                  | "foreignTypes"
                  | "includes"
                  | "visualizes"
                  | "programmingLanguageId"
                >
              >;
              projectUsesBlockLanguages: Array<
                { __typename?: "ProjectUsesBlockLanguage" } & Pick<
                  ProjectUsesBlockLanguage,
                  "id" | "blockLanguageId"
                >
              >;
              projectSources: Array<
                { __typename?: "ProjectSource" } & Pick<
                  ProjectSource,
                  "id" | "kind" | "readOnly" | "display" | "title" | "url"
                >
              >;
              schema: Array<
                { __typename?: "SqlTable" } & Pick<
                  SqlTable,
                  "name" | "systemTable"
                > & {
                    columns: Array<
                      { __typename?: "SqlColumn" } & Pick<
                        SqlColumn,
                        | "index"
                        | "name"
                        | "type"
                        | "notNull"
                        | "dfltValue"
                        | "primary"
                      >
                    >;
                    foreignKeys: Array<
                      { __typename?: "SqlForeignKey" } & {
                        references: Array<
                          { __typename?: "SqlForeignKeyReference" } & Pick<
                            SqlForeignKeyReference,
                            "fromColumn" | "toTable" | "toColumn"
                          >
                        >;
                      }
                    >;
                  }
              >;
            }
        >
      >
    >;
  };
};

export type GrammarDescriptionItemQueryVariables = {
  id: Scalars["ID"];
};

export type GrammarDescriptionItemQuery = { __typename?: "Query" } & {
  singleGrammar: { __typename?: "Grammar" } & Pick<
    Grammar,
    | "id"
    | "name"
    | "programmingLanguageId"
    | "slug"
    | "generatedFromId"
    | "foreignTypes"
    | "root"
    | "types"
  >;
};

export type RegenerateForeignTypesMutationVariables = {
  id: Scalars["ID"];
};

export type RegenerateForeignTypesMutation = { __typename?: "Mutation" } & {
  regenerateForeignTypes?: Maybe<
    { __typename?: "RegenerateForeignTypesPayload" } & {
      grammar: { __typename?: "Grammar" } & Pick<Grammar, "foreignTypes">;
    }
  >;
};

export type SelectionListBlockLanguagesQueryVariables = {};

export type SelectionListBlockLanguagesQuery = { __typename?: "Query" } & {
  blockLanguages: { __typename?: "BlockLanguageConnection" } & {
    nodes?: Maybe<
      Array<
        Maybe<
          { __typename?: "BlockLanguage" } & Pick<BlockLanguage, "id" | "name">
        >
      >
    >;
  };
};

export type SelectionListGrammarsQueryVariables = {};

export type SelectionListGrammarsQuery = { __typename?: "Query" } & {
  grammars: { __typename?: "GrammarConnection" } & {
    nodes?: Maybe<
      Array<Maybe<{ __typename?: "Grammar" } & Pick<Grammar, "id" | "name">>>
    >;
  };
};

export type UpdateBlockLanguageMutationVariables = {
  id?: Maybe<Scalars["ID"]>;
  name?: Maybe<Scalars["String"]>;
  slug?: Maybe<Scalars["String"]>;
  defaultProgrammingLanguageId?: Maybe<Scalars["ID"]>;
  grammarId?: Maybe<Scalars["ID"]>;
  sidebars?: Maybe<Scalars["JSON"]>;
  editorBlocks?: Maybe<Scalars["JSON"]>;
  rootCssClasses?: Maybe<Scalars["JSON"]>;
  editorComponents?: Maybe<Scalars["JSON"]>;
  localGeneratorInstructions?: Maybe<Scalars["JSON"]>;
};

export type UpdateBlockLanguageMutation = { __typename?: "Mutation" } & {
  updateBlockLanguage?: Maybe<
    { __typename?: "UpdateBlockLanguagePayload" } & Pick<
      UpdateBlockLanguagePayload,
      "id" | "errors"
    >
  >;
};

export type UpdateGrammarMutationVariables = {
  id: Scalars["ID"];
  name?: Maybe<Scalars["String"]>;
  slug?: Maybe<Scalars["String"]>;
  types?: Maybe<Scalars["JSON"]>;
  foreignTypes?: Maybe<Scalars["JSON"]>;
  root?: Maybe<Scalars["QualifiedTypeName"]>;
  programmingLanguageId?: Maybe<Scalars["ID"]>;
  generatedFromId?: Maybe<Scalars["ID"]>;
  blockLanguageIds?: Maybe<Array<Scalars["ID"]>>;
};

export type UpdateGrammarMutation = { __typename?: "Mutation" } & {
  updateGrammar?: Maybe<
    { __typename?: "UpdateGrammarPayload" } & Pick<
      UpdateGrammarPayload,
      "errors"
    > & {
        grammar?: Maybe<
          { __typename?: "Grammar" } & Pick<
            Grammar,
            | "id"
            | "name"
            | "programmingLanguageId"
            | "slug"
            | "generatedFromId"
            | "foreignTypes"
            | "root"
            | "types"
            | "includes"
            | "visualizes"
          > & {
              blockLanguages?: Maybe<
                { __typename?: "BlockLanguageConnection" } & {
                  nodes?: Maybe<
                    Array<
                      Maybe<
                        { __typename?: "BlockLanguage" } & Pick<
                          BlockLanguage,
                          "id" | "name"
                        >
                      >
                    >
                  >;
                }
              >;
            }
        >;
      }
  >;
};

export type UpdateNewsMutationVariables = {
  id: Scalars["ID"];
  title: Scalars["LangJson"];
  text: Scalars["LangJson"];
  publishedFrom: Scalars["ISO8601DateTime"];
};

export type UpdateNewsMutation = { __typename?: "Mutation" } & {
  updateNews?: Maybe<
    { __typename?: "UpdateNewsPayload" } & Pick<UpdateNewsPayload, "errors"> & {
        news?: Maybe<
          { __typename?: "News" } & Pick<
            News,
            | "id"
            | "createdAt"
            | "updatedAt"
            | "publishedFrom"
            | "text"
            | "title"
            | "userId"
          >
        >;
      }
  >;
};

export const AdminMetaCodeResourcesDocument = gql`
  query AdminMetaCodeResources($programmingLanguageId: ID!) {
    codeResources(
      input: { filter: { programmingLanguageId: $programmingLanguageId } }
    ) {
      nodes {
        id
        name
      }
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class AdminMetaCodeResourcesGQL extends Apollo.Query<
  AdminMetaCodeResourcesQuery,
  AdminMetaCodeResourcesQueryVariables
> {
  document = AdminMetaCodeResourcesDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const CodeResourcesGalleryDocument = gql`
  query CodeResourcesGallery($id: ID!) {
    codeResources {
      nodes {
        id
        name
      }
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class CodeResourcesGalleryGQL extends Apollo.Query<
  CodeResourcesGalleryQuery,
  CodeResourcesGalleryQueryVariables
> {
  document = CodeResourcesGalleryDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const CreateProjectDocument = gql`
  mutation CreateProject($name: LangJson!, $slug: String!) {
    createProject(input: { name: $name, slug: $slug }) {
      errors
      id
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class CreateProjectGQL extends Apollo.Mutation<
  CreateProjectMutation,
  CreateProjectMutationVariables
> {
  document = CreateProjectDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const AdminListProjectsDocument = gql`
  query AdminListProjects(
    $first: Int
    $after: String
    $before: String
    $last: Int
    $input: ProjectInputType
  ) {
    projects(
      first: $first
      after: $after
      before: $before
      last: $last
      input: $input
    ) {
      nodes {
        id
        name
        slug
        codeResourceCount
      }
      totalCount
      pageInfo {
        hasPreviousPage
        hasNextPage
        startCursor
        endCursor
      }
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class AdminListProjectsGQL extends Apollo.Query<
  AdminListProjectsQuery,
  AdminListProjectsQueryVariables
> {
  document = AdminListProjectsDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const FrontpageListProjectsDocument = gql`
  query FrontpageListProjects {
    projects(input: { filter: { public: true } }) {
      nodes {
        id
        slug
        name
        public
        description
        preview
        indexPageId
        createdAt
        updatedAt
        userId
        blockLanguages {
          defaultProgrammingLanguage {
            id
            name
          }
        }
      }
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class FrontpageListProjectsGQL extends Apollo.Query<
  FrontpageListProjectsQuery,
  FrontpageListProjectsQueryVariables
> {
  document = FrontpageListProjectsDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const AdminEditBlockLanguageDocument = gql`
  query AdminEditBlockLanguage($id: ID!) {
    singleBlockLanguage(id: $id) {
      id
      name
      slug
      generated
      grammarId
      sidebars
      editorBlocks
      editorComponents
      rootCssClasses
      localGeneratorInstructions
      createdAt
      updatedAt
      defaultProgrammingLanguageId
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class AdminEditBlockLanguageGQL extends Apollo.Query<
  AdminEditBlockLanguageQuery,
  AdminEditBlockLanguageQueryVariables
> {
  document = AdminEditBlockLanguageDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const AdminListBlockLanguagesDocument = gql`
  query AdminListBlockLanguages(
    $first: Int
    $after: String
    $before: String
    $last: Int
    $input: BlockLanguageInputType
  ) {
    blockLanguages(
      first: $first
      after: $after
      before: $before
      last: $last
      input: $input
    ) {
      nodes {
        id
        name
        slug
        generated
        grammarId
      }
      totalCount
      pageInfo {
        hasPreviousPage
        hasNextPage
        startCursor
        endCursor
      }
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class AdminListBlockLanguagesGQL extends Apollo.Query<
  AdminListBlockLanguagesQuery,
  AdminListBlockLanguagesQueryVariables
> {
  document = AdminListBlockLanguagesDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const AdminListGrammarsDocument = gql`
  query AdminListGrammars(
    $first: Int
    $after: String
    $before: String
    $last: Int
    $input: GrammarInputType
  ) {
    grammars(
      first: $first
      after: $after
      before: $before
      last: $last
      input: $input
    ) {
      nodes {
        id
        name
        slug
        programmingLanguageId
      }
      totalCount
      pageInfo {
        hasPreviousPage
        hasNextPage
        startCursor
        endCursor
      }
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class AdminListGrammarsGQL extends Apollo.Query<
  AdminListGrammarsQuery,
  AdminListGrammarsQueryVariables
> {
  document = AdminListGrammarsDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const AdminListNewsDocument = gql`
  query AdminListNews(
    $first: Int
    $after: String
    $before: String
    $last: Int
    $input: NewsInputType
  ) {
    news(
      first: $first
      after: $after
      before: $before
      last: $last
      input: $input
    ) {
      nodes {
        id
        title
        text
        publishedFrom
        createdAt
        updatedAt
        userId
      }
      totalCount
      pageInfo {
        hasPreviousPage
        hasNextPage
        startCursor
        endCursor
      }
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class AdminListNewsGQL extends Apollo.Query<
  AdminListNewsQuery,
  AdminListNewsQueryVariables
> {
  document = AdminListNewsDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const AdminSingleGrammarDocument = gql`
  query AdminSingleGrammar($id: ID!) {
    singleGrammar(id: $id) {
      id
      name
      programmingLanguageId
      slug
      generatedFromId
      foreignTypes
      root
      types
      includes
      visualizes
      blockLanguages {
        nodes {
          id
          name
        }
      }
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class AdminSingleGrammarGQL extends Apollo.Query<
  AdminSingleGrammarQuery,
  AdminSingleGrammarQueryVariables
> {
  document = AdminSingleGrammarDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const AdminSingleNewsDocument = gql`
  query AdminSingleNews($id: ID!) {
    adminSingleNews(id: $id) {
      id
      title
      text
      publishedFrom
      createdAt
      updatedAt
      userId
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class AdminSingleNewsGQL extends Apollo.Query<
  AdminSingleNewsQuery,
  AdminSingleNewsQueryVariables
> {
  document = AdminSingleNewsDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const CreateBlockLanguageDocument = gql`
  mutation CreateBlockLanguage(
    $name: String!
    $slug: String
    $defaultProgrammingLanguageId: ID
    $grammarId: ID
    $sidebars: JSON!
    $editorBlocks: JSON!
    $editorComponents: JSON!
    $rootCssClasses: JSON
    $localGeneratorInstructions: JSON
  ) {
    createBlockLanguage(
      input: {
        name: $name
        slug: $slug
        defaultProgrammingLanguageId: $defaultProgrammingLanguageId
        grammarId: $grammarId
        sidebars: $sidebars
        editorBlocks: $editorBlocks
        editorComponents: $editorComponents
        rootCssClasses: $rootCssClasses
        localGeneratorInstructions: $localGeneratorInstructions
      }
    ) {
      id
      errors
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class CreateBlockLanguageGQL extends Apollo.Mutation<
  CreateBlockLanguageMutation,
  CreateBlockLanguageMutationVariables
> {
  document = CreateBlockLanguageDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const CreateGrammarDocument = gql`
  mutation CreateGrammar(
    $name: String!
    $slug: String
    $types: JSON!
    $foreignTypes: JSON
    $root: QualifiedTypeName
    $programmingLanguageId: ID!
  ) {
    createGrammar(
      input: {
        name: $name
        slug: $slug
        types: $types
        foreignTypes: $foreignTypes
        root: $root
        programmingLanguageId: $programmingLanguageId
      }
    ) {
      grammar {
        id
        name
        programmingLanguageId
        slug
        generatedFromId
        foreignTypes
        root
        types
        visualizes
        includes
        blockLanguages {
          nodes {
            id
            name
          }
        }
      }
      errors
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class CreateGrammarGQL extends Apollo.Mutation<
  CreateGrammarMutation,
  CreateGrammarMutationVariables
> {
  document = CreateGrammarDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const CreateNewsDocument = gql`
  mutation CreateNews(
    $title: LangJson!
    $text: LangJson!
    $publishedFrom: ISO8601DateTime!
  ) {
    createNews(
      input: { title: $title, text: $text, publishedFrom: $publishedFrom }
    ) {
      news {
        id
        createdAt
        updatedAt
        publishedFrom
        text
        title
        userId
      }
      errors
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class CreateNewsGQL extends Apollo.Mutation<
  CreateNewsMutation,
  CreateNewsMutationVariables
> {
  document = CreateNewsDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const DestroyBlockLanguageDocument = gql`
  mutation DestroyBlockLanguage($id: ID!) {
    destroyBlockLanguage(input: { id: $id }) {
      id
      errors
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class DestroyBlockLanguageGQL extends Apollo.Mutation<
  DestroyBlockLanguageMutation,
  DestroyBlockLanguageMutationVariables
> {
  document = DestroyBlockLanguageDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const DestroyGrammarDocument = gql`
  mutation DestroyGrammar($id: ID!) {
    destroyGrammar(input: { id: $id }) {
      errors
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class DestroyGrammarGQL extends Apollo.Mutation<
  DestroyGrammarMutation,
  DestroyGrammarMutationVariables
> {
  document = DestroyGrammarDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const DestroyNewsDocument = gql`
  mutation DestroyNews($id: ID!) {
    destroyNews(input: { id: $id }) {
      id
      errors
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class DestroyNewsGQL extends Apollo.Mutation<
  DestroyNewsMutation,
  DestroyNewsMutationVariables
> {
  document = DestroyNewsDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const FrontpageListNewsDocument = gql`
  query FrontpageListNews($languages: [LanguageEnum!]) {
    frontpageListNews(
      first: 10
      input: {
        filter: { publishedFrom: { until: true } }
        textLength: short
        languages: $languages
        order: { orderField: publishedFrom, orderDirection: desc }
      }
    ) {
      nodes {
        id
        title
        text
        publishedFrom
      }
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class FrontpageListNewsGQL extends Apollo.Query<
  FrontpageListNewsQuery,
  FrontpageListNewsQueryVariables
> {
  document = FrontpageListNewsDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const FrontpageSingleNewsDocument = gql`
  query FrontpageSingleNews($id: ID!) {
    frontpageSingleNews(id: $id) {
      id
      title
      text
      publishedFrom
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class FrontpageSingleNewsGQL extends Apollo.Query<
  FrontpageSingleNewsQuery,
  FrontpageSingleNewsQueryVariables
> {
  document = FrontpageSingleNewsDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const FullProjectDocument = gql`
  query FullProject($id: ID!) {
    projects(input: { filter: { id: $id } }) {
      nodes {
        id
        slug
        name
        description
        public
        indexPageId
        codeResources {
          id
          name
          ast
          blockLanguageId
          programmingLanguageId
        }
        blockLanguages {
          id
          name
          sidebars
          editorBlocks
          editorComponents
          localGeneratorInstructions
          rootCssClasses
          grammarId
          defaultProgrammingLanguageId
        }
        grammars {
          id
          name
          root
          types
          foreignTypes
          includes
          visualizes
          programmingLanguageId
        }
        projectUsesBlockLanguages {
          id
          blockLanguageId
        }
        projectSources {
          id
          kind
          readOnly
          display
          title
          url
        }
        schema {
          name
          columns {
            index
            name
            type
            notNull
            dfltValue
            primary
          }
          foreignKeys {
            references {
              fromColumn
              toTable
              toColumn
            }
          }
          systemTable
        }
      }
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class FullProjectGQL extends Apollo.Query<
  FullProjectQuery,
  FullProjectQueryVariables
> {
  document = FullProjectDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const GrammarDescriptionItemDocument = gql`
  query GrammarDescriptionItem($id: ID!) {
    singleGrammar(id: $id) {
      id
      name
      programmingLanguageId
      slug
      generatedFromId
      foreignTypes
      root
      types
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class GrammarDescriptionItemGQL extends Apollo.Query<
  GrammarDescriptionItemQuery,
  GrammarDescriptionItemQueryVariables
> {
  document = GrammarDescriptionItemDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const RegenerateForeignTypesDocument = gql`
  mutation RegenerateForeignTypes($id: ID!) {
    regenerateForeignTypes(input: { id: $id }) {
      grammar {
        foreignTypes
      }
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class RegenerateForeignTypesGQL extends Apollo.Mutation<
  RegenerateForeignTypesMutation,
  RegenerateForeignTypesMutationVariables
> {
  document = RegenerateForeignTypesDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const SelectionListBlockLanguagesDocument = gql`
  query SelectionListBlockLanguages {
    blockLanguages {
      nodes {
        id
        name
      }
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class SelectionListBlockLanguagesGQL extends Apollo.Query<
  SelectionListBlockLanguagesQuery,
  SelectionListBlockLanguagesQueryVariables
> {
  document = SelectionListBlockLanguagesDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const SelectionListGrammarsDocument = gql`
  query SelectionListGrammars {
    grammars {
      nodes {
        id
        name
      }
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class SelectionListGrammarsGQL extends Apollo.Query<
  SelectionListGrammarsQuery,
  SelectionListGrammarsQueryVariables
> {
  document = SelectionListGrammarsDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const UpdateBlockLanguageDocument = gql`
  mutation UpdateBlockLanguage(
    $id: ID
    $name: String
    $slug: String
    $defaultProgrammingLanguageId: ID
    $grammarId: ID
    $sidebars: JSON
    $editorBlocks: JSON
    $rootCssClasses: JSON
    $editorComponents: JSON
    $localGeneratorInstructions: JSON
  ) {
    updateBlockLanguage(
      input: {
        id: $id
        name: $name
        slug: $slug
        defaultProgrammingLanguageId: $defaultProgrammingLanguageId
        grammarId: $grammarId
        sidebars: $sidebars
        editorBlocks: $editorBlocks
        rootCssClasses: $rootCssClasses
        editorComponents: $editorComponents
        localGeneratorInstructions: $localGeneratorInstructions
      }
    ) {
      id
      errors
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class UpdateBlockLanguageGQL extends Apollo.Mutation<
  UpdateBlockLanguageMutation,
  UpdateBlockLanguageMutationVariables
> {
  document = UpdateBlockLanguageDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const UpdateGrammarDocument = gql`
  mutation UpdateGrammar(
    $id: ID!
    $name: String
    $slug: String
    $types: JSON
    $foreignTypes: JSON
    $root: QualifiedTypeName
    $programmingLanguageId: ID
    $generatedFromId: ID
    $blockLanguageIds: [ID!]
  ) {
    updateGrammar(
      input: {
        id: $id
        name: $name
        slug: $slug
        types: $types
        foreignTypes: $foreignTypes
        root: $root
        programmingLanguageId: $programmingLanguageId
        generatedFromId: $generatedFromId
        blockLanguageIds: $blockLanguageIds
      }
    ) {
      grammar {
        id
        name
        programmingLanguageId
        slug
        generatedFromId
        foreignTypes
        root
        types
        includes
        visualizes
        blockLanguages {
          nodes {
            id
            name
          }
        }
      }
      errors
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class UpdateGrammarGQL extends Apollo.Mutation<
  UpdateGrammarMutation,
  UpdateGrammarMutationVariables
> {
  document = UpdateGrammarDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
export const UpdateNewsDocument = gql`
  mutation UpdateNews(
    $id: ID!
    $title: LangJson!
    $text: LangJson!
    $publishedFrom: ISO8601DateTime!
  ) {
    updateNews(
      input: {
        id: $id
        title: $title
        text: $text
        publishedFrom: $publishedFrom
      }
    ) {
      news {
        id
        createdAt
        updatedAt
        publishedFrom
        text
        title
        userId
      }
      errors
    }
  }
`;

@Injectable({
  providedIn: "root",
})
export class UpdateNewsGQL extends Apollo.Mutation<
  UpdateNewsMutation,
  UpdateNewsMutationVariables
> {
  document = UpdateNewsDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
