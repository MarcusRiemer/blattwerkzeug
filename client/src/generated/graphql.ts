import gql from 'graphql-tag';
import { Injectable } from '@angular/core';
import * as Apollo from 'apollo-angular';
export type Maybe<T> = T | null;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  NodeDescription: any;
  Datetime: any;
  /** Represents untyped JSON */
  JSON: any;
  LangJson: any;
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: any;
};



export type BlockLanguage = {
  __typename?: 'BlockLanguage';
  codeResources?: Maybe<Array<CodeResource>>;
  createdAt?: Maybe<Scalars['Datetime']>;
  defaultProgrammingLanguage: ProgrammingLanguage;
  generated?: Maybe<Scalars['Boolean']>;
  grammar?: Maybe<Grammar>;
  grammarId?: Maybe<Scalars['ID']>;
  id: Scalars['ID'];
  model: Scalars['JSON'];
  name: Scalars['String'];
  slug?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** The connection type for BlockLanguage. */
export type BlockLanguageConnection = {
  __typename?: 'BlockLanguageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BlockLanguageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BlockLanguage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type BlockLanguageEdge = {
  __typename?: 'BlockLanguageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<BlockLanguage>;
};

export type BlockLanguageFilterFieldType = {
  id?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  grammar?: Maybe<Scalars['String']>;
};

export type BlockLanguageInputType = {
  order?: Maybe<BlockLanguageOrderType>;
  filter?: Maybe<BlockLanguageFilterFieldType>;
  languages?: Maybe<Array<LanguageEnum>>;
};

export enum BlockLanguageOrderFieldEnum {
  Name = 'name',
  Slug = 'slug',
  Grammar = 'grammar'
}

export type BlockLanguageOrderType = {
  orderField?: Maybe<BlockLanguageOrderFieldEnum>;
  orderDirection?: Maybe<OrderDirectionEnum>;
};

export type CodeResource = {
  __typename?: 'CodeResource';
  ast?: Maybe<Scalars['NodeDescription']>;
  blockLanguage: BlockLanguage;
  compiled?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  grammars?: Maybe<Grammar>;
  id: Scalars['ID'];
  name: Scalars['String'];
  programmingLanguage: ProgrammingLanguage;
  project: Project;
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** The connection type for CodeResource. */
export type CodeResourceConnection = {
  __typename?: 'CodeResourceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CodeResourceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CodeResource>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CodeResourceEdge = {
  __typename?: 'CodeResourceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CodeResource>;
};

/** Autogenerated input type of CreateBlockLanguageMutation */
export type CreateBlockLanguageMutationInput = {
  name: Scalars['String'];
  slug?: Maybe<Scalars['String']>;
  defaultProgrammingLanguageId?: Maybe<Scalars['ID']>;
  grammarId?: Maybe<Scalars['ID']>;
  sidebars: Scalars['JSON'];
  editorBlocks: Scalars['JSON'];
  editorComponents: Scalars['JSON'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreateBlockLanguageMutation */
export type CreateBlockLanguageMutationPayload = {
  __typename?: 'CreateBlockLanguageMutationPayload';
  blockLanguage?: Maybe<BlockLanguage>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<Scalars['String']>;
  id?: Maybe<Scalars['ID']>;
};

/** Autogenerated input type of CreateGrammarMutation */
export type CreateGrammarMutationInput = {
  name: Scalars['String'];
  slug?: Maybe<Scalars['String']>;
  types: Scalars['JSON'];
  foreignTypes: Scalars['JSON'];
  root: Scalars['JSON'];
  programmingLanguageId: Scalars['ID'];
  generatedFromId?: Maybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreateGrammarMutation */
export type CreateGrammarMutationPayload = {
  __typename?: 'CreateGrammarMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<Scalars['String']>;
  grammar?: Maybe<Grammar>;
  id: Scalars['ID'];
};

/** Autogenerated input type of CreateNewsMutation */
export type CreateNewsMutationInput = {
  title: Scalars['JSON'];
  text: Scalars['JSON'];
  publishedFrom?: Maybe<Scalars['Datetime']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CreateNewsMutation */
export type CreateNewsMutationPayload = {
  __typename?: 'CreateNewsMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<Scalars['String']>;
  id: Scalars['ID'];
  news?: Maybe<News>;
};


/** Autogenerated input type of DestroyGrammarMutation */
export type DestroyGrammarMutationInput = {
  id: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of DestroyGrammarMutation */
export type DestroyGrammarMutationPayload = {
  __typename?: 'DestroyGrammarMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<Scalars['String']>;
  grammar?: Maybe<Grammar>;
  id: Scalars['ID'];
};

export type Grammar = {
  __typename?: 'Grammar';
  blockLanguages?: Maybe<BlockLanguageConnection>;
  codeResources?: Maybe<CodeResourceConnection>;
  createdAt: Scalars['Datetime'];
  foreignTypes: Scalars['JSON'];
  generatedFrom?: Maybe<CodeResource>;
  generatedFromId?: Maybe<Scalars['ID']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  programmingLanguage: ProgrammingLanguage;
  programmingLanguageId: Scalars['ID'];
  root: Scalars['JSON'];
  slug?: Maybe<Scalars['String']>;
  types: Scalars['JSON'];
  updatedAt: Scalars['Datetime'];
};


export type GrammarBlockLanguagesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type GrammarCodeResourcesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** The connection type for Grammar. */
export type GrammarConnection = {
  __typename?: 'GrammarConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GrammarEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Grammar>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GrammarEdge = {
  __typename?: 'GrammarEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Grammar>;
};

export type GrammarFilterFieldType = {
  id?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
};

export type GrammarInputType = {
  order?: Maybe<GrammarOrderType>;
  filter?: Maybe<GrammarFilterFieldType>;
  languages?: Maybe<Array<LanguageEnum>>;
};

export enum GrammarOrderFieldEnum {
  Name = 'name',
  Slug = 'slug'
}

export type GrammarOrderType = {
  orderField?: Maybe<GrammarOrderFieldEnum>;
  orderDirection?: Maybe<OrderDirectionEnum>;
};

export type Identity = {
  __typename?: 'Identity';
  createdAt?: Maybe<Scalars['Datetime']>;
  id: Scalars['ID'];
  ownData?: Maybe<Scalars['JSON']>;
  provider: Scalars['String'];
  providerData?: Maybe<Scalars['JSON']>;
  type: Scalars['String'];
  updatedAt?: Maybe<Scalars['Datetime']>;
  user: User;
};




export enum LanguageEnum {
  De = 'de',
  En = 'en'
}

export type Mutation = {
  __typename?: 'Mutation';
  createBlockLanguage?: Maybe<CreateBlockLanguageMutationPayload>;
  createGrammar?: Maybe<CreateGrammarMutationPayload>;
  createNews?: Maybe<CreateNewsMutationPayload>;
  destroyGrammar?: Maybe<DestroyGrammarMutationPayload>;
  id: Scalars['ID'];
  updateGrammar?: Maybe<UpdateGrammarMutationPayload>;
};


export type MutationCreateBlockLanguageArgs = {
  input: CreateBlockLanguageMutationInput;
};


export type MutationCreateGrammarArgs = {
  input: CreateGrammarMutationInput;
};


export type MutationCreateNewsArgs = {
  input: CreateNewsMutationInput;
};


export type MutationDestroyGrammarArgs = {
  input: DestroyGrammarMutationInput;
};


export type MutationUpdateGrammarArgs = {
  input: UpdateGrammarMutationInput;
};

export type News = {
  __typename?: 'News';
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  publishedFrom?: Maybe<Scalars['ISO8601DateTime']>;
  text: Scalars['LangJson'];
  title: Scalars['LangJson'];
  updatedAt: Scalars['ISO8601DateTime'];
  user?: Maybe<User>;
};

/** The connection type for News. */
export type NewsConnection = {
  __typename?: 'NewsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NewsEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<News>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type NewsEdge = {
  __typename?: 'NewsEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<News>;
};


export enum OrderDirectionEnum {
  Asc = 'asc',
  Desc = 'desc'
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

export type ProgrammingLanguage = {
  __typename?: 'ProgrammingLanguage';
  id: Scalars['ID'];
  name: Scalars['String'];
};

/** The connection type for ProgrammingLanguage. */
export type ProgrammingLanguageConnection = {
  __typename?: 'ProgrammingLanguageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProgrammingLanguageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProgrammingLanguage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ProgrammingLanguageEdge = {
  __typename?: 'ProgrammingLanguageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ProgrammingLanguage>;
};

export type Project = {
  __typename?: 'Project';
  blockLanguages?: Maybe<BlockLanguageConnection>;
  codeResourceCount?: Maybe<Scalars['Int']>;
  codeResources?: Maybe<CodeResourceConnection>;
  createdAt?: Maybe<Scalars['Datetime']>;
  defaultDatabase?: Maybe<ProjectDatabase>;
  description: Scalars['LangJson'];
  grammars?: Maybe<GrammarConnection>;
  id: Scalars['ID'];
  indexPageId?: Maybe<Scalars['String']>;
  name: Scalars['LangJson'];
  preview?: Maybe<Scalars['String']>;
  projectSources?: Maybe<ProjectSourceConnection>;
  public?: Maybe<Scalars['Boolean']>;
  slug?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['Datetime']>;
  user?: Maybe<User>;
};


export type ProjectBlockLanguagesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type ProjectCodeResourcesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type ProjectGrammarsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type ProjectProjectSourcesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};

/** The connection type for Project. */
export type ProjectConnection = {
  __typename?: 'ProjectConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Project>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

export type ProjectDatabase = {
  __typename?: 'ProjectDatabase';
  createdAt: Scalars['Datetime'];
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  project?: Maybe<Project>;
  schema?: Maybe<Scalars['JSON']>;
  updatedAt: Scalars['Datetime'];
};

/** The connection type for ProjectDatabase. */
export type ProjectDatabaseConnection = {
  __typename?: 'ProjectDatabaseConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectDatabaseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectDatabase>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ProjectDatabaseEdge = {
  __typename?: 'ProjectDatabaseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectDatabase>;
};

/** An edge in a connection. */
export type ProjectEdge = {
  __typename?: 'ProjectEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Project>;
};

export type ProjectFilterFieldType = {
  id?: Maybe<Scalars['ID']>;
  name?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  public?: Maybe<Scalars['Boolean']>;
};

export type ProjectInputType = {
  order?: Maybe<ProjectOrderType>;
  filter?: Maybe<ProjectFilterFieldType>;
  languages?: Maybe<Array<LanguageEnum>>;
};

export enum ProjectOrderFieldEnum {
  Name = 'name',
  Slug = 'slug'
}

export type ProjectOrderType = {
  orderField?: Maybe<ProjectOrderFieldEnum>;
  orderDirection?: Maybe<OrderDirectionEnum>;
};

export type ProjectSource = {
  __typename?: 'ProjectSource';
  createdAt?: Maybe<Scalars['Datetime']>;
  display: Scalars['String'];
  id: Scalars['ID'];
  project: Project;
  readOnly: Scalars['Boolean'];
  title: Scalars['String'];
  updatedAt?: Maybe<Scalars['Datetime']>;
  url: Scalars['String'];
};

/** The connection type for ProjectSource. */
export type ProjectSourceConnection = {
  __typename?: 'ProjectSourceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProjectSourceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProjectSource>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ProjectSourceEdge = {
  __typename?: 'ProjectSourceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ProjectSource>;
};

export type Query = {
  __typename?: 'Query';
  blockLanguages: BlockLanguageConnection;
  codeResources: CodeResourceConnection;
  grammars: GrammarConnection;
  news: NewsConnection;
  programmingLanguages: ProgrammingLanguageConnection;
  projectDatabases: ProjectDatabaseConnection;
  projectSources: ProjectSourceConnection;
  projects: ProjectConnection;
};


export type QueryBlockLanguagesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  input?: Maybe<BlockLanguageInputType>;
};


export type QueryCodeResourcesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type QueryGrammarsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  input?: Maybe<GrammarInputType>;
};


export type QueryNewsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type QueryProgrammingLanguagesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type QueryProjectDatabasesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type QueryProjectSourcesArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type QueryProjectsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  input?: Maybe<ProjectInputType>;
};

export type Role = {
  __typename?: 'Role';
  createdAt: Scalars['Datetime'];
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  resourceId?: Maybe<Scalars['String']>;
  resourceType?: Maybe<Scalars['String']>;
  updatedAt: Scalars['Datetime'];
  users?: Maybe<Array<User>>;
};

/** Autogenerated input type of UpdateGrammarMutation */
export type UpdateGrammarMutationInput = {
  id: Scalars['ID'];
  name: Scalars['String'];
  slug?: Maybe<Scalars['String']>;
  types?: Maybe<Scalars['JSON']>;
  foreignTypes?: Maybe<Scalars['JSON']>;
  root?: Maybe<Scalars['JSON']>;
  programmingLanguageId?: Maybe<Scalars['ID']>;
  generatedFromId?: Maybe<Scalars['ID']>;
  blockLanguageIds?: Maybe<Array<Scalars['ID']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateGrammarMutation */
export type UpdateGrammarMutationPayload = {
  __typename?: 'UpdateGrammarMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<Scalars['String']>;
  grammar?: Maybe<Grammar>;
  id: Scalars['ID'];
};

export type User = {
  __typename?: 'User';
  createdAt: Scalars['Datetime'];
  displayName?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  identities?: Maybe<Array<Identity>>;
  news?: Maybe<Array<News>>;
  projects?: Maybe<Array<Project>>;
  roles: Role;
  updatedAt: Scalars['Datetime'];
};

export type CreateBlockLanguageMutationMutationVariables = {
  name: Scalars['String'];
  slug?: Maybe<Scalars['String']>;
  defaultProgrammingLanguageId?: Maybe<Scalars['ID']>;
  grammarId?: Maybe<Scalars['ID']>;
  sidebars: Scalars['JSON'];
  editorBlocks: Scalars['JSON'];
  editorComponents: Scalars['JSON'];
};


export type CreateBlockLanguageMutationMutation = (
  { __typename?: 'Mutation' }
  & { createBlockLanguage?: Maybe<(
    { __typename?: 'CreateBlockLanguageMutationPayload' }
    & Pick<CreateBlockLanguageMutationPayload, 'id' | 'errors'>
  )> }
);

export type AdminListBlockLanguagesQueryVariables = {
  first?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['Int']>;
  input?: Maybe<BlockLanguageInputType>;
};


export type AdminListBlockLanguagesQuery = (
  { __typename?: 'Query' }
  & { blockLanguages: (
    { __typename?: 'BlockLanguageConnection' }
    & Pick<BlockLanguageConnection, 'totalCount'>
    & { nodes?: Maybe<Array<Maybe<(
      { __typename?: 'BlockLanguage' }
      & Pick<BlockLanguage, 'id' | 'name' | 'slug' | 'generated' | 'grammarId'>
    )>>>, pageInfo: (
      { __typename?: 'PageInfo' }
      & Pick<PageInfo, 'hasPreviousPage' | 'hasNextPage' | 'startCursor' | 'endCursor'>
    ) }
  ) }
);

export type CreateGrammarMutationMutationVariables = {
  name: Scalars['String'];
  slug?: Maybe<Scalars['String']>;
  types: Scalars['JSON'];
  foreignTypes: Scalars['JSON'];
  root: Scalars['JSON'];
  programmingLanguageId: Scalars['ID'];
};


export type CreateGrammarMutationMutation = (
  { __typename?: 'Mutation' }
  & { createGrammar?: Maybe<(
    { __typename?: 'CreateGrammarMutationPayload' }
    & Pick<CreateGrammarMutationPayload, 'errors'>
    & { grammar?: Maybe<(
      { __typename?: 'Grammar' }
      & Pick<Grammar, 'id'>
    )> }
  )> }
);

export type UpdateGrammarMutationMutationVariables = {
  id: Scalars['ID'];
  name: Scalars['String'];
  slug?: Maybe<Scalars['String']>;
  types: Scalars['JSON'];
  foreignTypes: Scalars['JSON'];
  root?: Maybe<Scalars['JSON']>;
  programmingLanguageId: Scalars['ID'];
  generatedFromId?: Maybe<Scalars['ID']>;
  blockLanguageIds?: Maybe<Array<Scalars['ID']>>;
};


export type UpdateGrammarMutationMutation = (
  { __typename?: 'Mutation' }
  & { updateGrammar?: Maybe<(
    { __typename?: 'UpdateGrammarMutationPayload' }
    & Pick<UpdateGrammarMutationPayload, 'errors'>
    & { grammar?: Maybe<(
      { __typename?: 'Grammar' }
      & Pick<Grammar, 'id'>
    )> }
  )> }
);

export type DestroyGrammarMutationMutationVariables = {
  id: Scalars['ID'];
};


export type DestroyGrammarMutationMutation = (
  { __typename?: 'Mutation' }
  & { destroyGrammar?: Maybe<(
    { __typename?: 'DestroyGrammarMutationPayload' }
    & Pick<DestroyGrammarMutationPayload, 'errors'>
  )> }
);

export type AdminListGrammarsQueryVariables = {
  first?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['Int']>;
  input?: Maybe<GrammarInputType>;
};


export type AdminListGrammarsQuery = (
  { __typename?: 'Query' }
  & { grammars: (
    { __typename?: 'GrammarConnection' }
    & Pick<GrammarConnection, 'totalCount'>
    & { nodes?: Maybe<Array<Maybe<(
      { __typename?: 'Grammar' }
      & Pick<Grammar, 'id' | 'name' | 'slug'>
    )>>>, pageInfo: (
      { __typename?: 'PageInfo' }
      & Pick<PageInfo, 'hasPreviousPage' | 'hasNextPage' | 'startCursor' | 'endCursor'>
    ) }
  ) }
);

export type GrammarDescriptionItemQueryVariables = {
  id: Scalars['ID'];
};


export type GrammarDescriptionItemQuery = (
  { __typename?: 'Query' }
  & { grammars: (
    { __typename?: 'GrammarConnection' }
    & { nodes?: Maybe<Array<Maybe<(
      { __typename?: 'Grammar' }
      & Pick<Grammar, 'id' | 'name' | 'programmingLanguageId' | 'slug' | 'generatedFromId' | 'foreignTypes' | 'root' | 'types'>
    )>>> }
  ) }
);

export type AdminEditGrammarQueryVariables = {
  id: Scalars['ID'];
};


export type AdminEditGrammarQuery = (
  { __typename?: 'Query' }
  & { grammars: (
    { __typename?: 'GrammarConnection' }
    & { nodes?: Maybe<Array<Maybe<(
      { __typename?: 'Grammar' }
      & Pick<Grammar, 'id' | 'name' | 'programmingLanguageId' | 'slug' | 'generatedFromId' | 'foreignTypes' | 'root' | 'types'>
      & { blockLanguages?: Maybe<(
        { __typename?: 'BlockLanguageConnection' }
        & { nodes?: Maybe<Array<Maybe<(
          { __typename?: 'BlockLanguage' }
          & Pick<BlockLanguage, 'id' | 'name'>
        )>>> }
      )> }
    )>>> }
  ) }
);

export type SelectionListGrammarsQueryVariables = {};


export type SelectionListGrammarsQuery = (
  { __typename?: 'Query' }
  & { grammars: (
    { __typename?: 'GrammarConnection' }
    & { nodes?: Maybe<Array<Maybe<(
      { __typename?: 'Grammar' }
      & Pick<Grammar, 'id' | 'name'>
    )>>> }
  ) }
);

export type AdminListProjectsQueryVariables = {
  first?: Maybe<Scalars['Int']>;
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['Int']>;
  input?: Maybe<ProjectInputType>;
};


export type AdminListProjectsQuery = (
  { __typename?: 'Query' }
  & { projects: (
    { __typename?: 'ProjectConnection' }
    & Pick<ProjectConnection, 'totalCount'>
    & { nodes?: Maybe<Array<Maybe<(
      { __typename?: 'Project' }
      & Pick<Project, 'id' | 'name' | 'slug' | 'codeResourceCount'>
    )>>>, pageInfo: (
      { __typename?: 'PageInfo' }
      & Pick<PageInfo, 'hasPreviousPage' | 'hasNextPage' | 'startCursor' | 'endCursor'>
    ) }
  ) }
);

export const CreateBlockLanguageMutationDocument = gql`
    mutation CreateBlockLanguageMutation($name: String!, $slug: String, $defaultProgrammingLanguageId: ID, $grammarId: ID, $sidebars: JSON!, $editorBlocks: JSON!, $editorComponents: JSON!) {
  createBlockLanguage(input: {name: $name, slug: $slug, defaultProgrammingLanguageId: $defaultProgrammingLanguageId, grammarId: $grammarId, sidebars: $sidebars, editorBlocks: $editorBlocks, editorComponents: $editorComponents}) {
    id
    errors
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateBlockLanguageMutationGQL extends Apollo.Mutation<CreateBlockLanguageMutationMutation, CreateBlockLanguageMutationMutationVariables> {
    document = CreateBlockLanguageMutationDocument;
    
  }
export const AdminListBlockLanguagesDocument = gql`
    query AdminListBlockLanguages($first: Int, $after: String, $before: String, $last: Int, $input: BlockLanguageInputType) {
  blockLanguages(first: $first, after: $after, before: $before, last: $last, input: $input) {
    nodes {
      id
      name
      slug
      generated
      grammarId
    }
    totalCount
    pageInfo {
      hasPreviousPage
      hasNextPage
      startCursor
      endCursor
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AdminListBlockLanguagesGQL extends Apollo.Query<AdminListBlockLanguagesQuery, AdminListBlockLanguagesQueryVariables> {
    document = AdminListBlockLanguagesDocument;
    
  }
export const CreateGrammarMutationDocument = gql`
    mutation CreateGrammarMutation($name: String!, $slug: String, $types: JSON!, $foreignTypes: JSON!, $root: JSON!, $programmingLanguageId: ID!) {
  createGrammar(input: {name: $name, slug: $slug, types: $types, foreignTypes: $foreignTypes, root: $root, programmingLanguageId: $programmingLanguageId}) {
    grammar {
      id
    }
    errors
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class CreateGrammarMutationGQL extends Apollo.Mutation<CreateGrammarMutationMutation, CreateGrammarMutationMutationVariables> {
    document = CreateGrammarMutationDocument;
    
  }
export const UpdateGrammarMutationDocument = gql`
    mutation UpdateGrammarMutation($id: ID!, $name: String!, $slug: String, $types: JSON!, $foreignTypes: JSON!, $root: JSON, $programmingLanguageId: ID!, $generatedFromId: ID, $blockLanguageIds: [ID!]) {
  updateGrammar(input: {id: $id, name: $name, slug: $slug, types: $types, foreignTypes: $foreignTypes, root: $root, programmingLanguageId: $programmingLanguageId, generatedFromId: $generatedFromId, blockLanguageIds: $blockLanguageIds}) {
    grammar {
      id
    }
    errors
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class UpdateGrammarMutationGQL extends Apollo.Mutation<UpdateGrammarMutationMutation, UpdateGrammarMutationMutationVariables> {
    document = UpdateGrammarMutationDocument;
    
  }
export const DestroyGrammarMutationDocument = gql`
    mutation DestroyGrammarMutation($id: ID!) {
  destroyGrammar(input: {id: $id}) {
    errors
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class DestroyGrammarMutationGQL extends Apollo.Mutation<DestroyGrammarMutationMutation, DestroyGrammarMutationMutationVariables> {
    document = DestroyGrammarMutationDocument;
    
  }
export const AdminListGrammarsDocument = gql`
    query AdminListGrammars($first: Int, $after: String, $before: String, $last: Int, $input: GrammarInputType) {
  grammars(first: $first, after: $after, before: $before, last: $last, input: $input) {
    nodes {
      id
      name
      slug
    }
    totalCount
    pageInfo {
      hasPreviousPage
      hasNextPage
      startCursor
      endCursor
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AdminListGrammarsGQL extends Apollo.Query<AdminListGrammarsQuery, AdminListGrammarsQueryVariables> {
    document = AdminListGrammarsDocument;
    
  }
export const GrammarDescriptionItemDocument = gql`
    query GrammarDescriptionItem($id: ID!) {
  grammars(input: {filter: {id: $id}}) {
    nodes {
      id
      name
      programmingLanguageId
      slug
      generatedFromId
      foreignTypes
      root
      types
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class GrammarDescriptionItemGQL extends Apollo.Query<GrammarDescriptionItemQuery, GrammarDescriptionItemQueryVariables> {
    document = GrammarDescriptionItemDocument;
    
  }
export const AdminEditGrammarDocument = gql`
    query AdminEditGrammar($id: ID!) {
  grammars(input: {filter: {id: $id}}) {
    nodes {
      id
      name
      programmingLanguageId
      slug
      generatedFromId
      foreignTypes
      root
      types
      blockLanguages {
        nodes {
          id
          name
        }
      }
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AdminEditGrammarGQL extends Apollo.Query<AdminEditGrammarQuery, AdminEditGrammarQueryVariables> {
    document = AdminEditGrammarDocument;
    
  }
export const SelectionListGrammarsDocument = gql`
    query SelectionListGrammars {
  grammars {
    nodes {
      id
      name
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class SelectionListGrammarsGQL extends Apollo.Query<SelectionListGrammarsQuery, SelectionListGrammarsQueryVariables> {
    document = SelectionListGrammarsDocument;
    
  }
export const AdminListProjectsDocument = gql`
    query AdminListProjects($first: Int, $after: String, $before: String, $last: Int, $input: ProjectInputType) {
  projects(first: $first, after: $after, before: $before, last: $last, input: $input) {
    nodes {
      id
      name
      slug
      codeResourceCount
    }
    totalCount
    pageInfo {
      hasPreviousPage
      hasNextPage
      startCursor
      endCursor
    }
  }
}
    `;

  @Injectable({
    providedIn: 'root'
  })
  export class AdminListProjectsGQL extends Apollo.Query<AdminListProjectsQuery, AdminListProjectsQueryVariables> {
    document = AdminListProjectsDocument;
    
  }