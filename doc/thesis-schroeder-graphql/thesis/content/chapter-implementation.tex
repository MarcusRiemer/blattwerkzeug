%! Author = yannux
%! Date = 24.08.20


% Postgres wird benutzt als Dokumenten Datenbank in bezug auf jsonb und hstore
\chapter{Implementierung}
Dieses Kapitel beschreibt den Implementierungsprozess bei der Migration von GraphQL in die Webapplikation Blattwerkzeug. Zusätzlich wird anhand eines Praxisbeispiel der Prozess zum Erweitern des Datenmodells mit einem neuen Datensatz zur Prozedur im vorherigen Systems verglichen. Aus dem Implementierungsprozess und dem Praxisbeispiel lässt sich der erfolgte Entwicklungsaufwand unter Berücksichtigung der in Kapitel \fullref{sec:requirements} beschriebenen Anforderungen evaluieren.

\section{GraphQL}
Bei der Migration muss vor Beginn des Entwicklungsprozesses entschieden werden, nach welchem der folgenden Ansätze die Migration vollzogen werden soll.

\begin{description}
	\item[Schema-first\label{graphql:schema-first}] \ \\
	Bei dem Schema-first Ansatz wird zuerst das Schema in der GraphQL SDL (schema definition language)~\cite{graphql-sdl} entwickelt, welches die Quelle der Wahrheit sein soll. Es wird in die Serverapplikation geladen und in eine interne Repräsentation geparst (siehe Abbildung~\ref{fig:schema-first}). Anschließend werden Resolver geschrieben, um Queries aufzulösen und den angefragten Feldern Werte liefern zu können. Diese müssen stets konsistent zu den SDL Definitionen sein, da es sonst zu Fehlverhalten kommt. 
	Die SDL ist so konzipiert, dass sie sprachunabhängig ist. Jedoch werden im Entwicklungsprozess unzählige Tools benötigt, um verschiedenste Problematiken zu bekämpfen, wie:
	
	\begin{itemize}
		\setlength\itemsep{-1em}
		\item Inkonsistenzen zwischen Schemadefinition und Resolver
		\item Modularisierung von GraphQL-Schemata
		\item Redundanzen in Schemadefinitionen
	\end{itemize}
	
	\begin{figure}[h!]
		\centering
		\includegraphics[width=\linewidth]{snippets/schema-first.pdf}
		\caption{Entwicklungsprozess beim Schema-first Ansatz}
		\label{fig:schema-first}
	\end{figure}

	\item[Code-first\label{graphql:code-first}] \ \\
	Bei Code-first gibt es keine manuell gepflegte Version des Schemas, sondern Code in der Sprache des Servers, der das Schema implementiert und aus dem sich SDL generieren lässt, um das Schema dem Client zugänglich zu machen (siehe Abbildung~\ref{fig:code-first}). 
	
	\begin{figure}[h!]
		\centering
		\includegraphics[width=\linewidth]{snippets/code-first.pdf}
		\caption{Entwicklungsprozess beim Code-first Ansatz}
		\label{fig:code-first}
	\end{figure}
	
	
	Es gibt eine breite Auswahl an Frameworks in verschiedenen Sprachen~\cite{code-first-frameworks}, unter anderem auch das Framework graphql-ruby~\cite{graphql-ruby}, welches für Ruby on Rails Webapplikationen entwickelt wurde. 
	Aus folgenden Gründen ist der Code-first Ansatz gewählt worden, da graphql-ruby:

\begin{itemize}
	\setlength\itemsep{-1em}
	\item ein neuerer Ansatz (siehe Abbildung~\ref{graphql:evolution}) und auf Ruby on Rails zugeschnitten ist.
	\item ausführliche und für die Migration ausreichende Dokumentationen wie graphql-ruby Guides~\cite{graphql-ruby-guides} und graphql rubydoc~\cite{graphql-rubydoc}, sowie Tutorials von howtographql.com~\cite{howto-graphql-ruby}, dev.to~\cite{dev.to-graphql-ruby}, web-crunch.com~\cite{web-crunch-graphql-ruby} und viele mehr bereitstellt.
	\item bereits im Einsatz bei GitHub, Shopify und Kickstarter und damit auch in größeren Applikationen skalieren kann.
	\item im Gegensatz zu Schema-first den geringeren Einsatz von Tools erfordert~\cite{schema-first-tooling}.

\end{itemize}
\end{description}

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{snippets/graphql-implementation-timeline.png}
	\caption{Die Evolution der GraphQL-Server-Entwicklung ~\cite{graphql-evolution-graphic}}
	\label{graphql:evolution}
\end{figure}

\subsection{Integration von graphql-ruby}
In graphql-ruby wird das Schema serverseitig in Ruby implementiert.
Zur Umsetzung wurde das Rubygem \emph{graphql}~\cite{graphql-rubygem} in der Rails Applikation installiert und ein \texttt{/graphql} Verzeichnis im app-Ordner auf Ebene der Models und Controller erstellt.
Innerhalb des Ordners wurde die in Listing~\ref{lst:graphql:directory} gezeigte Ordnerstruktur gewählt.

\begin{lstlisting}[language=Ruby,float=h!,caption={Ordnerstruktur des \texttt{/graphql} Verzeichnisses}, label={lst:graphql:directory}]
|-- graphql
|   |-- mutations
|   |   |-- block_language
|   |   |-- grammar
|   |   |-- news
|   |   |-- projects
|   |-- resolvers
|   |-- types
|   |   |-- base
|   |   |-- scalar
|   |-- validators
\end{lstlisting}

Wie in der SDL in Listing~\ref{fig:basics:graphql:schema} wird nun auf oberster Ebene das Schema mit den zugehörigen Einstiegspunkten definiert. Dafür wurde die Datei \lstinline|/graphql/server-schema.rb| erstellt (sieh Listing~\ref{lst:graphql:schema}).

\begin{lstlisting}[language=Ruby,float=h!,caption={graphql-ruby Schema Definition und Festlegung der Einstiegpunkte query und mutation}, label={lst:graphql:schema}]
class ServerSchema < GraphQL::Schema
  default_max_page_size 100
  
  # Erwartet
  query(Types::QueryType)
  # Optional
  mutation(Types::MutationType)

  # Fügt eingebaute Connections zur Paginierung hinzu
  use GraphQL::Pagination::Connections
end
\end{lstlisting}

\begin{itemize}
	\setlength\itemsep{-1em}
	\item Zeile 1: Definition des Schemas.
	\item Zeile 2: Setzen einer maximalen Seitengröße für die Paginierung mit Connections.
	\item Zeile 5: Definition des Einstiegspunktes aller Queries.
	\item Zeile 7: Definition des Einstiegspunktes aller Mutationen.
	\item Zeile 10: Hinzufügen von Connections (siehe Unterabschnitt~\ref{graphql:connections}).
\end{itemize}

Die Klasse GraphQL::Schema vererbt die Funktion \texttt{.execute} zum Ausführen von GraphQL Anfragen gegen das definierte Schema. Der Rails Server benötigt also eine Route, die alle GraphQL Anfragen entgegen nimmt und an eine Controller Funktion verweist, in der die \texttt{.exectue} Funktion aufgerufen wird. Innerhalb dieser Funktion wird der Name der Query (operationName) genutzt und nach einer gleichnamigen Query im Schema Ordner gesucht. Ist eine solche Query vorhanden, wird diese geladen und der \texttt{.execute} Funktion anstelle der in der Anfrage enthaltenen Query übergeben.
Kann eine Query mit dem angefragten Namen nicht gefunden werden oder wurde kein Name übergeben, wird eine Fehlermeldung an den Client zurückgegeben. Dieses Verfahren stellt sicher, dass keine schädlichen GraphQL Queries ausgeführt werden können, sondern nur die im Projekt genutzten.
Zusätzlich werden die Meta Daten (Context), welcher Nutzer die Anfrage geschickt hat und in welcher Sprache der Nutzer die Webseite lädt, beigefügt (siehe Abbildung~\ref{graphql:integration}). Anschließend werden die Anfragen vom GraphQL Modul verarbeitet. Dieser kommuniziert mit der Datenbank, erzeugt eine Antwort und gibt diese als Rückgabewert der \texttt{.execute} Funktion an den Controller zurück, der die Antwort an den Client weiterleitet.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{snippets/system-components.pdf}
	\caption{Koppelung des GraphQL Modules an die bestehende Applikation}
	\label{graphql:integration}
\end{figure}

Auf dem Client könnten eigens Angular Services entwickelt werden, um GraphQL Queries an den Server zu schicken. Eine bessere Alternative dazu, die zudem Features, wie Batching oder Caching bietet, ist die Nutzung eines GraphQL Clients~\cite{graphql-client}. 

\begin{description}
	\item[Batching] \ \\
	Batching ist der Prozess, bei dem eine Gruppe von Anfragen zu einer einzigen zusammengefasst wird. 
\end{description}

Aufgrund der Bereitstellung dieser Features und der Kompatibilität zu Angular~\cite{apollo-angular-doc} wurde sich für den Apollo Client~\cite{apollo-angular} entschieden.

Nachfolgend wird anhand eines Praxisbeispiels die Umsetzung des gesamten Systems verbildlicht.
\section{Praxisbeispiel - Erweiterung des Datenmodels}
Nachfolgend wird das in Abschnitt~\ref{sec:requirements:example} beschriebene Praxisbeispiel nach erfolgter Migration von GraphQL wiederholt, um aufzuzeigen, welche Schritte bei Nutzung von GraphQL durchgeführt werden müssen und wie diese sich zum alten System unterscheiden.

\subsection{Anlegen des Models in Rails}
\label{impl:graphql:model}
Als ersten Schritt empfehle ich das Anlegen und Durchführen einer Datenbankmigration und das Erstellen des neuen Models, genau wie in Unterabschnitt~\fullref{sec:requirements:example:model} erläutert. 

\subsection{Anlegen eines GraphQL Objekttypen}
\label{impl:graphql:graphqltype}
\label{graphql:objecttype}
Wurde der GraphQL Typ nicht aus dem Datenbankschema generiert, müssen Datentypen, die den Model Instanzen aus der Rails Applikation entsprechen, in Form von GraphQL-Objekttypen definiert werden. 
Jedes GraphQL Objekt hat Felder, die Daten extrahieren und anhand des Namens abgefragt werden können. 
Die Felder sollten die Benennung der Model-Attribute übernehmen, um direkten Zugriff auf diese zu erlangen. Das spart Code, da für jedes Feld, dessen Name nicht einem Bezeichner einer Spalte in der Datenbank entspricht und diese Spalte auch nicht manuell durch einen SQL Alias hinzugefügt wurde, ein zusätzlicher Resolver bereitgestellt werden muss.

Nachfolgend wird der Projekt Typ aus Listing~\fullref{lst:example:projectdesc} in graphql-ruby ausgedrückt und erweitert.

\begin{lstlisting}[language=Ruby,float=h!,caption={Definition des ProjectTypes zum Abbilden von Project Model Instanzen}, label={lst:graphql:projecttype}]
# Base Klasse definiert einen benutzerdefinierten Connection Typ BaseConnection 
class Types::BaseObject < GraphQL::Schema::Object
  connection_type_class  Types::Base::BaseConnection
end

class Types::ProjectType < Types::Base::BaseObject
  field :id, ID, null:false
  field :name, Types::Scalar::LangJson, null: false
  field :public, Boolean, null:true
  field :slug, String, null:false
  field :user, Types::UserType, null:true
  field :code_resources, [Types::CodeResourceType], null:true
  field :code_resource_count, Integer, null:true
  
  field :created_at, GraphQL::Types::ISO8601DateTime, null:false
  field :updated_at, GraphQL::Types::ISO8601DateTime, null:false
  [...]
end
\end{lstlisting}

In Listing~\ref{lst:graphql:projecttype} sind mehrere Auffälligkeiten, die es zu erklären gilt.
Zuerst ist zu erwähnen, dass in Zeile 2 Listing~\ref{lst:graphql:projecttype} eine Base-Klasse eingeführt wird (siehe Abschnitt~\ref{graphql:baseclass}).
Darüber hinaus bekommt jedes Feld (\texttt{field}) mindestens drei Attribute zugewiesen. 

\subsubsection{Name des Feldes}
Das erste Attribut ist ein Symbol und beschreibt den Namen des Feldes. 

In Zeile 11 Listing~\ref{lst:graphql:projecttype} wird der Nutzer eines Projektes (user) modelliert. Dieses Feld erhält die Bezeichnung \texttt{:user} und entspricht damit nicht der Benennung \texttt{:user\_id} aus dem Model. Dennoch wird kein Resolver zum Auflösen des Feldes benötigt, da im \texttt{Project} Model aus Listing~\ref{lst:example:model} der Zugriff auf den in Beziehung stehenden Nutzer, mit dem Aufruf von \texttt{.user} auf einer Project-Instanz, ermöglicht wird. 

Zudem wurden in Zeile 15 und 16 Listing~\ref{lst:graphql:projecttype} die Felder \texttt{:created\_at} und \texttt{:updated\_at} in Snake Case definiert, was zwar der Benennungskonvention von Ruby entspricht, jedoch nicht der im Client verwendeten Camel Case Schreibweise und damit inkompatibel zum Client sein müsste (siehe Anforderung in Unterabschnitt~\ref{req:naming:convention}). Die Konvention sieht allerdings vor, dass Felder und Argumenten-Bezeichner in Snake Case geschrieben werden, da bei der Auflösung eines Feldes per Default versucht wird, eine Methode mit dem Namen des Feldes auf dem übergebenen Objekt aufzurufen.
Ist solch eine Methode nicht vorhanden und das Objekt ein Hash, wird nach einem Schlüssel, der den Namen als String oder Symbol entspricht, gesucht~\cite{graphql-field-resolution}. Anschließend werden die Felder im zugrundeliegenden GraphQL Typ zu Camel Case konvertiert~\cite{graphql-object-classes}.

Passend dazu wurde in Zeile 13 ein Feld hinzugefügt, dass keinem Attribut des Project Models oder einer Beziehung zu einem anderen Model entspricht. Die Auflösung dieses Feldes wird dennoch implizit durch Zugriff über den gleichnamigen Schlüssel im Ergebnis der Query (Scope) erreicht. Wie der Wert in das Ergebnis der Query gerät, wird im Unter-Unterabschnitt~\fullref{impl:graphql:resolver} erklärt.

\subsubsection{Datentyp des Feldes}
Das zweite Attribut bei der Deklarierung eines Feldes stellt den Datentyp dar. graphql-ruby bietet alle von GraphQL bereitgestellten Typen (Scalar Typen) an. Zu denen gehören ID, String, Int, Float und Boolean. Darüber hinaus hat graphql-ruby noch weitere Typen wie \texttt{ISO8601DateTime} im Repertoire. Da diese nicht ausreichen, wurden eigens Scalar Typen hinzugefügt (siehe Abschnitt ~\ref{graphql:scalartypes}). Einer davon ist der in Zeile 8 Listing~\ref{lst:graphql:projecttype} aufgeführte \texttt{LangJson}, der ein multilinguales Feld darstellt. Der Suffix \texttt{Types::Scalar::} beschreibt den Pfad vom \texttt{/graphql} Verzeichnis aus, wo der Typ zu finden ist - in diesem Fall \lstinline|/graphql/types/scalar/lang_json.rb|.

In Zeile 11 und 12 Listing~\ref{lst:graphql:projecttype} wurden Typen verwendet, die zu einer Model-Instanz aus der Rails Applikation passen. In Zeile 11 wird eine User-Instanz erwartet, in Zeile 12 ein Array gefüllt mit CodeResource-Instanzen.

\subsubsection{Nullable}
Als drittes Attribut wurde festgelegt, ob das Feld \texttt{null} als Rückgabewert haben darf. Diese Angabe kann aus dem Datenbankschema abgelesen werden.

Insgesamt gibt es noch  weitere Attribute, mit denen Felder eingeschränkt oder Meta Daten hinzugefügt werden können~\cite{graphql-field-introduction}.
Weitere Felder des \texttt{ProjectType} werden aus Gründen der Relevanz nicht aufgeführt. 

\subsection{Anlegen eines Input Typen}
\label{impl:graphql:input}
Input-Objekttypen sind komplexe Eingaben für GraphQL-Operationen. Sie eignen sich hervorragend für Felder, die viele strukturierte Eingaben benötigen, wie Mutationen oder Suchfelder~\cite{graphql-input-type}.
Bei der Migration von GraphQL wurden Input Typen für die Auswahl von Sprachen (\texttt{:languages}), für das Filtern (\texttt{:filter}) und für das Sortieren (\texttt{:order}) genutzt.
Für jeden Typen, der einer Model-Instanz entspricht und deren Instanzen im Client in Listen-Form dargestellt werden, wird definiert, welche der Attribute des Models sortierbar sind und nach welchen Attributen gefiltert werden kann. Diese Informationen fließen bei der Definition des zur Klasse gehörenden Input-Typen ein (siehe Listing~\ref{lst:graphql:inputtype}).

\begin{lstlisting}[language=Ruby,float=h!,caption={Definition der Input Typen in \lstinline|/graphql/types/project_type.rb|}, label={lst:graphql:inputtype}]
class Types::ProjectType < Types::Base::BaseObject
  [...]
  # Enum mit Feldern nach denen sortiert werden soll 
  class OrderFieldEnum < Types::Base::BaseEnum
    value 'name'
    value 'slug'
  end

  # Typ zum Sortieren nach den Feldern aus OrderFieldEnum mit der
  # Sortierrichtung aus dem OrderDirectionEnum aus der BaseEnum Klasse
  class OrderType < Types::Base::BaseInputObject
    argument :orderField, OrderFieldEnum, required: false
    argument :orderDirection, Types::Base::BaseEnum::GraphQL:OrderDirectionEnum, required: false
  end

  # Enum mit Feldern die multilingual sind
  class MultilingualColumnsEnum < Types::Base::BaseEnum
    value "name"
  end

  # Typ zum Filtern nach den als Argumenten aufgeführten Feldern
  class FilterFieldType < Types::Base::BaseInputObject
    argument :id, type: ID, required: false
    argument :name, type: String, required: false
    argument :slug, type: String, required: false
    argument :public, type: Boolean, required: false
  end

  # Input Typ zum Sortiere, Filter und Auswählen von Sprachen
  class InputType < Types::Base::BaseInputObject
    argument :order, OrderType, required: false
    argument :filter, FilterFieldType, required: false
    argument :languages, [Types::Base::BaseEnum::LanguageEnum], required: false
  end
end
\end{lstlisting}

Nach Hinzufügen des Input Typen ist die Klasse ProjectType fürs erste vollständig.
Also wurden bislang ein Schema definiert, eine Rails Migration durchgeführt und ein Objekttyp inkl. Input-Typ erstellt, der zur migrierten Datenbanktabelle passt. Nun folgt die Logik für die Verarbeitung von Queries.


\subsection{Anlegen eines Query Endpunktes}
\label{impl:graphql:querytype}
Damit der Datentyp über den Einstiegspunkt \texttt{query} aus dem Schema abgefragt werden kann, wurde die Klasse \texttt{QueryType} in Listing~\ref{lst:graphql:querytype} definiert.
Diese beinhaltet alle definierten Queries, die die Einstiegspunkte zu den Model-Instanzen widerspiegeln. Für jede Model-Instanz die, abgefragt werden soll, wurde somit ein Feld in der Klasse \texttt{QueryType} definiert.

\begin{lstlisting}[language=Ruby,float=h!,caption={Definition des QueryType als Einstiegspunkt in alle Queries. \lstinline|/graphql/types/query_type.rb|}, label={lst:graphql:querytype}]
class QueryType < GraphQL::Schema::Object
  field :projects, Types::ProjectType.connection_type, null: false do
    argument :input, Types::ProjectType::InputType, required: false
  end
  
  def projects(input: nil)
    if input
      Resolvers::ProjectsResolver::new(context: @context, **input).scope
    else
      Resolvers::ProjectsResolver::new(context: @context).scope
    end
  end
end
\end{lstlisting}

In Zeile 2 Listing~\ref{lst:graphql:querytype} wurde ein Feld mit dem Namen \texttt{:projects} vom Typ \texttt{ProjectType\-.connection\_type} erstellt, welches ein Argument (\texttt{argument}) mit dem Bezeichner \texttt{:input} vom Typ \texttt{ProjectType::InputType} mit der Einschränkung, dass das Argument nicht zwingend erwartet wird (\texttt{required: false}), besitzt.
Zusätzlich wurde in Zeile 6 Listing~\ref{lst:graphql:querytype} ein Resolver für die projects query hinzugefügt. Dieser bekommt das Argument als Parameter übergeben.

\subsection{Anlegen der Resolver Klasse}
\label{impl:graphql:resolver}
Der Resolver \texttt{projects} in Listing~\ref{lst:graphql:querytype} ist für das Auflösen einer Query zuständig. Im Falle, dass die Query eine Liste mit Filter- und Sortierfunktion erwartet,
delegiert ein Resolver diese Aufgabe an eine spezifisch zum angefragten Model passende Resolver Klasse weiter und gibt deren Instanzvariable \texttt{.scope} zurück. Das Argument \texttt{input} wird ebenfalls weiter an die Resolver Klasse übergeben, wenn dieses nicht \texttt{nil} ist. 

Die Klasse in Listing~\ref{lst:graphql:projectsresolver} und deren Oberklasse beinhalten umfangreiche Logik um effiziente SQL Queries zusammenzubasteln, die exakt nur die angefragten Felder mit Daten bedient. Hier werden die geforderten Lösungen des Overfetching, Underfetching und des N+1 Query Problems umgesetzt. Zudem wird das Sortieren, Filtern und Auswählen von Sprachen ermöglicht.

\begin{lstlisting}[language=Ruby,float=h!,caption={Klasse zum Auflösung der Query \lstinline|:projects|. \lstinline|/graphql/resolvers/projects_resolver.rb|}, label={lst:graphql:projectsresolver}]
class ProjectsResolver < Resolvers::BaseResolver

  attr_reader(:scope)

  def initialize(context:nil,filter:nil,order:nil,languages:nil)
    scope = Project
    # requested_columns gibt in der Query angefragte Felder als String Array zurück
    if requested_columns(context).include?("code_resource_count")
      # Löst das n+1 query Problem durch einen left join
      scope = scope.left_joins(:code_resources).select('COUNT(code_resources) AS code_resource_count').group('projects.id')
    end
    super(Project,context:context,scope:scope,filter:filter,order:order,languages:languages,order_dir: "asc",order_field:"name")
  end
end
\end{lstlisting}

Im Konstruktor in Listing~\ref{lst:graphql:projectsresolver} wird zunächst der Scope auf die von ApplicationRecord erbende (Model-)Klasse Project gesetzt, die der gleichnamigen Datenbanktabelle entspricht. Anschließend wird geprüft, ob das Feld \texttt{code\_resource\_count} in der Query abgefragt wird. Wenn das der Fall ist, wird ein Left Outer Join mit der CodeResource Tabelle durchgeführt, um die Anzahl der zu einem Projekt in Beziehung stehenden CodeResource-Instanzen zählen zu können und als \texttt{code\_resource\_count} zu selektieren, wodurch das angefragte Feld \texttt{:code\_resource\_count} aus dem Objekttypen  implizit aufgelöst werden kann. Durch dieses Verfahren können zum einen beliebige Felder einem Graphql-Objekttypen hinzugefügt werden, ohne dass es diese als Spalte in der Datenbank gibt, und zum anderen das N+1 Query Problem durch SQL Joins gelöst werden. 
Hieraus wird deutlich, dass obwohl GraphQL die SQL Queries automatisch zusammen stellt bei Bedarf in den Prozess des Zusammensetzens eingegriffen werden kann.

Zuletzt wird in Zeile 12 in Listing~\ref{lst:graphql:projectsresolver} der Konstruktor der Oberklasse \texttt{BaseResolver} (in Abschnitt~\ref{impl:base-resolver} beschrieben) aufgerufen und  Argumente zum Sortieren, Filtern und Auswählen von Sprachen übergeben.

Serverseitig wurde nun die Logik erstellt, um Project Datensätze abzufragen und eine Antwort zu erstellen.
Nun benötigt der Client eine Query, die genau die Daten abfragt, die er benötigt und den dazugehörigen Antworttyp als Typescript Interface, um die Antwort typsicher verarbeiten zu können.

%Beim Laden der Daten aus der Datenbank wird zwischen Lazy Loading und Eager Loading unterschieden. Wir möchten alle Freunde aller Nutzer herausfinden:

\subsection{Erstellen einer GraphQL Query}
\label{impl:graphql:query}
Für die gewollte Listendarstellung im Client muss eine zum Endpunkt aus Listing~\ref{lst:graphql:querytype} passende GraphQL Query geschrieben werden. Wir benötigen also eine Query, die den Bezeichner \texttt{projects} beinhaltet. Zusätzlich muss die Query einen einzigartigen Namen erhalten, damit Generatoren diesen den daraus generierten Typescript Interfaces zuweisen können und ein Entwickler die Interfaces intuitiv wiederfindet. Zusätzlich werden Argumente zum Filtern, Sortieren und für die Sprachauswahl hinzugefügt sowie für die Paginierung. Für letzteres werden Felder, die den Status der Paginierung anzeigen abgefragt. Neben den Argumenten und Metadaten 
sind noch die Felder abzufragen, die dargestellt werden sollen.
In Listing~\ref{lst:graphql:query} wird die Query eingeführt, die für die erweiterte Projekt Liste aus Tabelle~\ref{tbl:req:roles} genutzt wird.

\begin{lstlisting}[language=JavaScript,float=h!,caption={GraphQL Query für eine paginierte Listendarstellung mit Möglichkeit des Filterns, der Sortierung und der Sprachauswahl}, label={lst:graphql:query}]
query AdminListProjects(
  $first: Int
  $after: String
  $before: String
  $last: Int
  $input: ProjectInputType
) {
  projects(
    first: $first
    after: $after
    before: $before
    last: $last
    input: $input
  ) {
    nodes {
      id
      name
      slug
      codeResourceCount
    }
	totalCount
	pageInfo {
	  hasPreviousPage
	  hasNextPage
	  startCursor
	  endCursor
	}
  }
}
\end{lstlisting}

\begin{itemize}
	\setlength\itemsep{-1em}
	\item Zeile 1: Setzen von \texttt{AdminListProjects} als Namen der Query.
	\item Zeile 2-5: Definition von Argumenten, die für die Paginierung genutzt werden (siehe Abschnitt~\ref{impl:pagination}). \texttt{first} und \texttt{last} sind der erste und letzte Index beginnend mit 1 innerhalb der gelieferten Ergebnismenge und mit Base64 kodiert. \texttt{hasPreviousPage} und \texttt{hasNextPage} geben an, ob eine vorherige bzw. eine nächste Seite existiert.
	\item Zeile 8: Definition, welcher Einstiegspunkt gewählt werden soll.
	\item Zeile 9-13: Zuweisen der in der Query definierten Argumente auf die im Schema definierten Argumente.
	\item Zeile 15: \texttt{nodes} ist ein Feld aus der Connection und gibt Zugriff auf die Felder des ProjectTypes.
	\item Zeile 16-19: Setzen der für die Listendarstellung verwendeten Felder.
	\item Zeile 21: \texttt{totalCount} ist ein Feld aus der benutzerdefinierten Connection und gibt Auskunft darüber, wie viele Datensätze die Query im Ergebnis beinhaltet (siehe Abschnitt~\ref{graphql:connections}).
	\item Zeile 22-26: \texttt{pageInfo} ist ein Feld aus der Connection und beinhaltet Felder, die Auskunft über den Zustand der Paginierung geben.
\end{itemize}

Nun muss die Query dem Client durch Generierung eines Angular Services, der die Query und eine Funktion zum Abschicken beinhaltet, zugreifbar gemacht werden.

\subsection{Codegenerierung}
\label{impl:graphql:generation}
graphql-ruby stellt einen eingebauten Rake Task bereit, der aus dem GraphQL Schema eine JSON Darstellung generiert~\cite{graphql-rake-task}. Diese wird in einem Schema-Ordner auf Wurzelebene der gesamten Applikation (Ebene, auf der sich der Server und Client Ordner befindet) gehalten.
Durch Nutzung des Tools graphql-code-generator~\cite{graphql-code-generator} wird dann aus der in Listing~\ref{lst:graphql:query} vorgestellten Query und dem GraphQL Schema in JSON Darstellung folgender Typescript Code (siehe Listings~\ref{lst:graphql:gen-gql},~\ref{lst:graphql:gen-service},~\ref{lst:graphql:gen-responsetype} und~\ref{lst:graphql:gen-variables}) generiert:

\begin{lstlisting}[language=JavaScript,float=h!,caption={Generierter Aufruf der gql-Funktion erhält die AdminListProjects Query als String}, label={lst:graphql:gen-gql}]
export const AdminListProjectsDocument = gql`
  query AdminListProjects[...]
`;
\end{lstlisting}

\begin{lstlisting}[language=JavaScript,float=h!,caption={Generierter Service enthält den Aufruf der Query als Instanzvariable}, label={lst:graphql:gen-service}]
@Injectable({
  providedIn: "root",
})
export class AdminListProjectsGQL extends Apollo.Query<
  AdminListProjectsQuery,
  AdminListProjectsQueryVariables
> {
  document = AdminListProjectsDocument;
  constructor(apollo: Apollo.Apollo) {
    super(apollo);
  }
}
\end{lstlisting}

\begin{lstlisting}[language=JavaScript,float=h!,caption={Generierter Antworttyp}, label={lst:graphql:gen-responsetype}]
export type AdminListProjectsQuery = { __typename?: "Query" } & {
  projects: { __typename?: "ProjectConnection" } & Pick<
    ProjectConnection,
    "totalCount"
  > & {
    nodes?: Maybe<
      Array<
        Maybe<
          { __typename?: "Project" } & Pick<
            Project,
            "id" | "name" | "slug" | "codeResourceCount"
          >
        >
      >
    >;
    pageInfo: { __typename?: "PageInfo" } & Pick<
      PageInfo,
      "hasPreviousPage" | "hasNextPage" | "startCursor" | "endCursor"
    >;
  };
};
\end{lstlisting}
\begin{lstlisting}[language=JavaScript,float=h!,caption={Generierter Parametertyp}, label={lst:graphql:gen-variables}]
export type AdminListProjectsQueryVariables = {
  first?: Maybe<Scalars["Int"]>;
  after?: Maybe<Scalars["String"]>;
  before?: Maybe<Scalars["String"]>;
  last?: Maybe<Scalars["Int"]>;
  input?: Maybe<ProjectInputType>;
};
\end{lstlisting}


Die Ausführung des Rake Tasks und des anschließenden Codegenerators werden über ein Makefile realisiert, wodurch es nur der Aufruf des im Makefile zugewiesenen Kommandos benötigt, um alle Typen für den Client generieren zu können. 

\subsection{Anlegen einer Angular Komponenten}
\label{impl:graphql:component}

Zur Darstellung wird eine Komponente verwendet. Diese bekommt den generierten Service aus Listing~\ref{lst:graphql:gen-service} im Konstruktor "injiziert". 

Die in Listing~\ref{lst:graphql:component} gezeigte Komponente enthält aus Gründen der Übersichtlichkeit lediglich die Logik um eine Query abzuschicken. Im Gegensatz dazu verwendet die im System verbaute Komponente zusätzlich eine weitere Komponente \texttt{PaginatorTableGraphql\-Component} (siehe Abschnitt~\fullref{impl:paginator-component}) zur paginierten Darstellung des Ergebnisses aus der Query in einer Angular Material Tabelle~\cite{angular-material-table}.
Der Aufruf \texttt{.watch} in Listing~\ref{lst:graphql:component} Zeile 13 gibt ein \texttt{QueryRef} Objekt zurück, welches das Attribut \texttt{valueChanges} hat, das ein Observable~\cite{angular-observable} ist.
Durch den Aufruf von \texttt{.subscribe()} \cite{angular-subscribe} oder der Nutzung einer Async-Pipe~\cite{angular-async-pipe} im Angular template wird die Query abgefeuert.
Die in Listing~\ref{lst:graphql:component} Zeile 14 und 15 verwendeten Parameter der \texttt{.watch} Methode geben die Variablen der Query (Zeile 14) und die von Apollo bereitgestellten Optionen (Zeile 15) an.
\texttt{notifyOnNetworkStatusChange: true} ermöglicht die Nutzung einer Ladeanzeige (loading indicator). Des Weiteren gibt der Parameter \texttt{fetchPolicy} an, wie die Daten geladen werden sollen. Hier besteht die Möglichkeit anzugeben, dass ein Cache automatisch genutzt werden soll. Jedoch wurde nach Erstellung eines neuen Datensatzes und Weiterleitung auf die Listendarstellung der gerade erstellte Datensatz nicht gezeigt, da die Liste aus dem Cache geladen wurde. Als Lösung wurde an dieser Stelle die Option \texttt{"network-only"} genutzt. Diese verbietet die Verwendung eines Caches, so dass immer eine Query geschickt wird, wenn die Liste benötigt wird.

\begin{lstlisting}[language=JavaScript,float=h!,caption={Angular Komponente zum Anzeigen der Projekte in Listendarstellung}, label={lst:graphql:component}]
import {
  AdminListProjectsGQL,
} from "../../../generated/graphql";

@Component({
  templateUrl: "./templates/overview-project.html",
})
export class OverviewProjectComponent {  
  
  constructor(readonly projectsService: AdminListProjectsGQL) {}
  
  pageSize: number = 25;
  readonly query = this.projectsService.watch(
    { first: this.pageSize },
    { notifyOnNetworkStatusChange: true, fetchPolicy: "network-only" }
  ).valueChanges;
}
\end{lstlisting}

\subsection{Anlegen einer neuen Sicht}
Um das nach GraphQL migrierte System mit dem alten zu vergleichen, wird das Anlegen einer neuen Variante der Sicht auf Projekt-Daten, wie in Abschnitt~\fullref{sec:requirements:example} simuliert.
In Tabelle~\ref{impl:tbl:newview} sind alle Schritte aufgeführt, die für das Hinzufügen eines neuen Datensatzes durchlaufen werden müssen.
Zusätzlich sind die Schritte, die beim Erstellen einer neuen Sicht ausgeführt werden, mit einem Haken markiert worden.

Es wird deutlich, dass nur eine dezimierte Anzahl von Schritten (4 von 11) im Gegensatz zum alten System (8 von 12) benötigt werden.
Es mussten keine Routen, Controller Funktionen oder weitere Tests geschrieben werden, da es nur einen GraphQL Endpunkt (Route und Controller Funktion) auf dem Server gibt, der alle Anfragen entgegen nimmt und im GraphQL Modul verarbeitet. Dort werden die Anfragen auf Korrektheit geprüft,
SQL Anfragen zusammengestellt, ausgeführt und die Antwort an die Controller Funktion zurückgegeben.
Somit sind alle Schritte, die in Tabelle~\fullref{tbl:newview} serverseitig durchgeführt wurden, obsolet und der Server bedarf keiner Änderungen.

\begin{table}[h!]
	\begin{tabular}{|p{0.12\textwidth}|p{0.52\textwidth}|p{0.12\textwidth}|}
		\hline
		\textbf{Schritt} & \textbf{Beschreibung} & \textbf{GraphQL} \\ \hline
		\multirow{2}{*}{$\ref{impl:graphql:model}$}
			& Anlegen einer Datenbank Migration & $X$ \\
			& Anlegen des Models & $X$ \\ \hline
		$\ref{impl:graphql:graphqltype}$ & Anlegen eines GraphQL Objekttypen &  $X$ \\ \hline
		$\ref{impl:graphql:input}$ & Anlegen eines Input Typen &  $X$ \\ \hline
		\multirow{2}{*}{$\ref{impl:graphql:querytype}$}
			& Anlegen eines Query Endpunktes &  $X$ \\ 
			& Anlegen einer Resolver Funktion &  $X$ \\ \hline
		$\ref{impl:graphql:resolver}$ & Anlegen einer Resolver Klasse &  $X$ \\ \hline
		$\ref{impl:graphql:query}$ & Erstellen einer GraphQL Query &  $\surd$ \\ \hline
		$\ref{impl:graphql:generation}$ & Codegenerierung &  $\surd$ \\ \hline
		\multirow{2}{*}{$\ref{impl:graphql:component}$}
			& Anlegen einer Angular Komponenten & $\surd$ \\
			& Anlegen eines Templates & $\surd$ \\ \hline
	\end{tabular}
	\vspace{5pt}
	\centering
	\caption{Funktionsweise von GraphQL bei Erstellung neuer Sichten auf bereits vorhandene Datensätze}
	\label{impl:tbl:newview}
\end{table}


Letztendlich muss lediglich eine Angular Komponente mit zugehörigem Template geschrieben werden, in die der generierte Service injiziert wird.

\section{Scalar Typen}
\label{graphql:scalartypes}
Ein GraphQL-Objekttyp hat einen Namen und Felder, aber irgendwann müssen diese Felder in konkrete Daten aufgelöst werden. An dieser Stelle kommen die skalaren Typen ins Spiel: Sie stellen die Blätter der Abfrage dar. 
Skalare Typen sind Instanzen von sehr einfach strukturierten Ruby Klassen. Diese enthalten lediglich zwei Funktionen zum Auflösen des Feldes bei Queries \texttt{self.coerce\_result(value, \_context)} und zum Verarbeiten von Eingaben bei Mutationen \texttt{self.coerce\_input(value, \_context)}. Beide Funktionen erhaltenden einen Wert und den Context der Query. Die Funktion zum Auflösen eines Feldes wird ausgeführt, nachdem der zum Feld passende Wert aus der Datenbank ausgelesen wurde und bevor dieser an die anfragende Client Applikation zurückgegeben wird. Da Scalar Typen erst benötigt werden, wenn ein bisher genutzter Typ nicht mit der GraphQL SDL formuliert werden kann, ist die Funktion \texttt{coerce\_result} der beste Ort für die Validierung zum Beispiel gegen das JSON Schema, welches den Typ beschreibt. Das gleiche gilt bei der Ausführung einer Mutation zum Hinzufügen eines Datensatzes in die Datenbank. Die Funktion \texttt{coerce\_input} wird ausgeführt, bevor der Wert des Feldes an den zum Feld gehörenden Resolver gegeben wird. Somit ist dies ebenfalls der richtige Ort für die Validierung der Eingabe.

Wie diese Scalar Typen genau aussehen können, wird anhand eines Beispiels in Abschnitt~\fullref{graphql:validation} vorgeführt.

\section{Base Klassen}
\label{graphql:baseclass}
Base Klassen wie BaseObject in~\ref{lst:graphql:projecttype} können genutzt werden, um das Typsystem von graphql-ruby zu erweitern~\cite{graphql-extending}. 

\section{Enum Typen}
\label{graphql:enumtypes}
Die in Blattwerkzeug verfügbaren Sprachen (\texttt{LanguageEnum}) und Sortierrichtungen werden in Enums innerhalb der Klasse \texttt{Types::Base::BaseEnum} aus Listing~\ref{lst:graphql:enum_values} gespeichert. Zusätzlich gibt es eine statische Funktion \texttt{self.enum\_values}, die die Werte eines Enums extrahiert und diese als Array zurück liefert. Diese wird bei der Sortierung und Auswahl der Sprache im Base Resolver in Abschnitt~\ref{impl:base-resolver} genutzt.

\begin{lstlisting}[language=Ruby,float=h!,caption={Funktion zum Extrahieren der Enum Werte in ein Array. \lstinline|/graphql/types/base/base_enum.rb|}, label={lst:graphql:enum_values}]
class Types::Base::BaseEnum < GraphQL::Schema::Enum
  def self.enum_values
    values.values.map(&:value)
  end
  
  class LanguageEnum < Types::Base::BaseEnum
    value 'de'
    value 'en'
  end
  [...]
  # weitere Enum Definitionen
end
\end{lstlisting}

\section{Mutationen als Objekttypen}
In diesem Abschnitt wird beschrieben, wie die Funktionalitäten zum Erstellen, Ändern und Löschen von Datensätzen von den bestehenden Rails Controllern nach GraphQL Mutationen migriert wurden.
Zuerst müssen dem Schema für die Ausführung von Mutationen entsprechende Einstiegspunkte hinzugefügt werden (siehe Listing~\ref{lst:graphql:mutation-entrypoint}). Im Unterschied zu den Queries werden zur Auflösung der Anfrage keine Resolver Funktionen verwendet sondern Ruby Klassen, die von der Klasse \texttt{GraphQL::Schema::RelayClassic\-Mutation} erben. 

\begin{lstlisting}[language=Ruby,float=h!,caption={Definition eines Endpunktes zum Aufruf der Mutation für Erstellung eines Projektes \lstinline|/graphql/types/mutation_type.rb|}, label={lst:graphql:mutation-entrypoint}]
class MutationType < Types::Base::BaseObject
  field :create_project, mutation: Mutations::Projects::CreateProject
end
\end{lstlisting}

Der Einstiegspunkt aus Listing~\ref{lst:graphql:mutation-entrypoint} verweist auf die Klasse \texttt{Mutations::Projects::\-Create\-Project} aus Listing~\ref{lst:graphql:create_project}. Innerhalb der Klasse können neben Feldern auch Argumente definiert werden. Da die Funktionalität der benötigten Mutationen bereits in den Rails Controller Funktionen umgesetzt ist, wurde dort abgelesen, welche Argumente eine Mutation benötigt. 
Vorteilhaft ist, dass zu den Argumenten ein Typ angegeben wird und ob diese zwingend vorhanden sein müssen. Somit können sich ohne manuelle Prüfungen keine fehlerhaften Daten einschleichen, wenn die Definition der Argumente korrekt umgesetzt wurde.

Die Argumente einer Mutation werden der Funktion \texttt{resolve} übergeben. Der Methodenrumpf der Funktion konnte in diesem Fall (siehe Listing~\ref{lst:graphql:create_project}) ebenfalls von der passenden \texttt{create} Funktion aus dem ProjectsController übernommen werden. Dies gilt auch für jede andere Mutation, da der Rails Server zu jeder im Kontext dieser Arbeit benötigten Mutation eine äquivalente Controller Funktion besitzt.

\begin{lstlisting}[language=Ruby,float=h!,caption={Definition der Mutation CreateProject \lstinline|/graphql/mutations/projects/create_project.rb|}, label={lst:graphql:create_project}]
class Mutations::Projects::CreateProject < Mutations::Projects::Projects

  argument :name, Types::Scalar::LangJson, required:true
  argument :slug, String, required:true

  def resolve(**args)
    project = Project.new(
      name:args[:name],
      slug:args[:slug],
      user_id:context[:user].id)
    save_project(project)
  end
end
\end{lstlisting}

Zusätzlich zu den Argumenten lassen sich Felder hinzufügen. Möchte man zum Beispiel im Client über ein einfaches Formular einen Datensatz erstellen und dann anhand der Id des Datensatzes zu dessen Detailansicht weitergeleitet werden, kann als Rückgabewert der Mutation eben diese Information erfragt werden.
Jeder Mutation wird ein \texttt{:errors} Feld beigefügt (siehe Listing~\ref{lst:graphql:projects-mutation}) um auf Fehler in einer Mutation reagieren zu können.

\begin{lstlisting}[language=Ruby,float=h!,caption={Definition der Oberklasse aller projects Mutationen \lstinline|/graphql/mutations/projects/projects.rb|}, label={lst:graphql:projects-mutation}]
class BaseMutation < GraphQL::Schema::RelayClassicMutation
end

class Mutations::Projects::Projects < Mutations::BaseMutation

  field :id, ID, null: true
  field :errors, [String], null: false

  def save_project(project)
    if project.save
      {
        id: project.id,
        errors: []
      }
    else
      {
        id: nil,
        errors: project.errors.full_messages
      }
    end
  end
end
\end{lstlisting}

Die Anfrage der Mutation sieht dementsprechend wie in Listing~\ref{lst:graphql:mutation-query} aus.

\begin{lstlisting}[language=Ruby,float=h!,caption={Anfrage der CreateProject Mutation}, label={lst:graphql:mutation-query}] 
mutation CreateProject($name:LangJson!,$slug:String!){
  createProject(input:{name:$name,slug:$slug}) {
    errors
	id
  }
}
\end{lstlisting}

\section{Felder Auswahl, Sprachauswahl, Filtern und Sortieren}
\label{impl:base-resolver}
Erhält eine Query Argumente zum Filtern, Sortieren und für die Sprachauswahl, durchläuft sie im GraphQL Modul eine Reihe von Resolvern, (siehe Abbildung~\ref{graphql:sorting}) in der die Argumente sukzessive in eine SQL Abfrage integriert werden. Zuerst wird die Resolver Funktion zum Auflösen eines Query Einstiegspunktes aufgerufen. Innerhalb dieser wird eine Instanz einer spezifisch zum abgefragten Model passenden Resolver Klasse (hier ProjectsResolver) erstellt, Argumente übergeben und der Rückgabewert des Konstruktor zurückgegeben. Der Konstruktor der spezifischen Resolver Klasse erstellt einen Scope (SQL Abfrage) und inkludiert Beziehungen in die Ergebnismenge dieses Scopes. Anschließend wird der Konstruktor der Oberklasse (BaseResolver) aufgerufen, der Context, die Argumente, der Scope und der Name der Model Klasse übergeben sowie Default Werte für die Sortierung gesetzt (siehe Zeile 12 in Listing~\ref{lst:graphql:projectsresolver}). 
Der BaseResolver ist eine einheitliche Komponente die den Scope wie nachfolgend erklärt erweitert. 
Somit werden die in diesem Kapitel relevanten Funktionalitäten in der Resolver Funktion und in der spezifischen Resolver Klasse nur konfiguriert und erst im BaseResolver implementiert.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{snippets/filtern-sortieren-sprachauswahl.pdf}
	\caption{Durchlauf einer Query durch alle Resolver im GraphQL Modul}
	\label{graphql:sorting}
\end{figure}


\textbf{Felder- und Sprachauswahl} \ \\
Zu Beginn wird geprüft, ob dem BaseResolver ein Array mit Ländercodes (\texttt{languages}) übergeben wurde. Wenn das nicht der Fall ist, werden alle vorhandene Sprachen als Array auf eine Instanzvariable \texttt{@languages} gesetzt. In einer Methode \texttt{select\_relevant\-\_fields} werden dann alle angefragten Felder zuzüglich aller Felder, die eine Fremdschlüsselbeziehung darstellen (Felder, die auf \texttt{\_id} enden) sowie das Feld Id, in einem Array zusammengefasst. Für jedes Element des Arrays wird geprüft, ob es ein in der Datenbank als hstore gespeichertes Feld ist, also einen multilingualen String darstellt.
Trifft dies zu werden mithilfe der Funktion \texttt{SLICE}~\cite{postgresql-hstore} nur die Schlüssel/Wert-Paare extrahiert, deren Schlüssel im \texttt{@languages} Array enthalten sind, andernfalls wird das gesamte Feld selektiert.

\textbf{Filtern} \ \\
Anschließend wird bei der Verarbeitung jedes Filters bestehend aus \texttt{filter\_key} und \texttt{filter\_value} zwischen fünf PostgreSQL Datentypen unterschieden.
\texttt{filter\_key} stellt dabei das Feld dar, auf welches der Filter angewendet werden soll. \texttt{filter\_value} hingegen ist der Wert, nachdem gefiltert wird.


\begin{description}
	\item[uuid] \ \\
		Ist das zu filternde Feld eine uuid, muss der Wert des Feldes in einen Text gecastet werden, bevor es mit dem LIKE Operator verglichen werden kann. \\
		\lstinline|scope.where "#{@model_class.table_name}.#{filter_key}::text LIKE ?", filter_value|
	\item[hstore] \ \\
		Handelt es sich bei dem Feld um einen multilingualen String werden, alle Werte zu den in \texttt{@languages} vorhandenen Schlüsseln mit dem Operator \texttt{hstore -> text[]} extrahiert und mit dem Operator \texttt{ILIKE ANY} geprüft, ob \texttt{filter\_value} zu einem der extrahierten Werte passt~\cite{ilike-any-postgres}.
		Die Funktion \texttt{to\-\_single\-\_quotes\-\_array} parst ein Array in Stringdarstellung mit einfachen Anführungszeichen.\\
		\lstinline|scope.where "'#{filter_value}' ILIKE ANY (#{@model_class.table_name}.#{filter_key} -> ARRAY#{to_single_quotes_array(@languages)})"|
	\item[boolean] \ \\
		Entspricht das Feld einem Boolean, muss mit einem $=$-Zeichen gefiltert werden.
		\lstinline|scope.where "#{@model_class.table_name}.#{filter_key} = ?", filter_value|
	\item[datetime] \ \\
		Bei einem Datetime Feld muss der Filter erweitert werden. In Blattwerkzeug existiert ein Model News (Neuigkeiten). Instanzen des Models besitzen das Attribut \texttt{published\_from}, welches angibt, wann eine Neuigkeit veröffentlicht werden soll. Um eine Liste zu erzeugen, in der nur bereits veröffentlichte News-Instanzen präsentiert werden, dürfen nur die selektiert werden, deren Erscheinungsdatum kleiner (früher) ist als das heutige Datum. Damit die Auswahl flexibel bleibt, wurde der Wert des Filters in zwei Argumente unterteilt. Das erste (\texttt{:date}) gibt das Datum an, nachdem gefiltert werden soll, das zweite Argument (\texttt{:until}) gibt an, ob nach Daten gefiltert werden sollen, die vor oder nach dem zu filternden Datum liegen. Wird kein Wert für das erste Argument angegeben wird das heutige Datum stattdessen genommen. \\
		\lstinline|comparator = filter_value[:until] ? "<=" : ">"| \\
		\lstinline|date = filter_value[:date] ? filter_value[:date] : Date.today| \\
		\lstinline|scope.where "#{@model_class.table_name}.#{filter_key} #{comparator} ?", date|
	\item[default] \ \\
		Alle anderen Datentypen werden mit dem \texttt{LIKE} Operator gefiltert. \\
		\lstinline|scope.where "#{@model_class.table_name}.#{filter_key} LIKE ?", filter_value|
\end{description}

\textbf{Sortieren} \ \\
Als letztes werden Sortierfunktionen in das SQL Statement eingebaut. Wie bei der Sprachauswahl wird erneut von multilingualen Feldern unterschieden.
Da diese einen Hash darstellen, muss angegeben werden, nach welcher der Schlüssel/Wert-Paare sortiert werden soll. Hier kommt die Funktion COALESCE~\cite{coalesce-postgres} ins Spiel. Sie kann eine beliebige Anzahl von Parametern verarbeiten, die der Reihe nach ausgewertet werden. Der erste Ausdruck, der einen Wert ungleich NULL zurückliefert, bestimmt das Ergebnis der Funktion. Sind mehrere Sprachen ausgewählt worden, muss bestimmt werden, nach welcher Sprache vorrangig sortiert werden soll. Da nicht jedes multilinguale Feld Werte für allen Sprachen besitzt, ist COALESCE hierbei die Lösung des Problems (siehe Listing~\ref{lst:graphql:sorting}).

\begin{lstlisting}[language=Ruby,float=h!,caption={Sortieren von Feldern in der Klasse BaseResolver}, label={lst:graphql:sorting}] 
  if is_multilingual_column? order_key
    # Erstellt einen String wie folgt "name->'de',name->'en',name->'it',name->'fr'"
    coalesce = @languages.map{|l| "#{@model_class.table_name}.#{order_key}->'#{l}'"}.join(',')
    scope = scope.order Arel.sql("COALESCE(#{coalesce}) #{order_dir}")
  end
\end{lstlisting}

\section{Paginierung}
\label{impl:pagination}
Die geforderte Paginierung wurde durch einen Connection Typ im GraphQL Schema und durch eine Angular Komponente ermöglicht, die eine einheitliche Tabelle mit Möglichkeit der Paginierung und Sortierung ist.
Der serverseitige Code erfordert nur einen Methodenaufruf (siehe Abschnitt{graphql:connections}), wohingegen im Client eine umfangreiche (165 Zeilen Typescript Code zuzüglich 25 Zeilen HTML Code) Komponente geschrieben wurde~\cite{paginator-table}.

\subsection{Connection Typen}
\label{graphql:connections}
Der Connection Typ ist die Lösung für das Problem der Paginierung~\cite{graphql-connection-concept}.
Es sind generische Objekte, die eine Eins-zu-viele-Beziehung darstellen, Metadaten über die Liste beinhalten und Zugriffsmöglichkeiten auf die Elemente besitzen.
Wird \texttt{.con\-nection\-\_type} an einen Query Typ angehängt, wird eine Connection daraus. 
Das bedeutet, dass wie bei \texttt{ProjectType.connection\_type} in Listing~\ref{lst:graphql:querytype} implizit Argumente zur Cursor-basierten Paginierung \texttt{first}, \texttt{last}, \texttt{after}, \texttt{before} hinzugefügt~\cite{graphql-relay-connection} werden. Zusätzlich wird jeder Query das Feld \texttt{pageInfo} beigefügt, über das die Informationen \texttt{hasNextPage}, \texttt{hasPreviousPage}, \texttt{startCursor} und \texttt{endCursor} erhältlich sind. 

Zusätzlich wurden durch eine benutzerdefinierte Connection Klasse die Connection-Typen um ein Feld erweitert.
Dies geschieht in Listing~\ref{lst:graphql:total-count}.

\begin{lstlisting}[language=JavaScript,float=h!,caption={Benutzerdefinierte Connection Klasse mit hinzugefügtem Feld}, label={lst:graphql:total-count}]
class Types::Base::BaseConnection < GraphQL::Types::Relay::BaseConnection

  field :total_count, Integer, null: false

  def total_count
    object.items.size
  end
end
\end{lstlisting}

\subsection{Einheitliche Tabelle}
\label{impl:paginator-component}
Die Tabelle im Client sieht wie in Abbildung~\ref{impl:graphql:paginator-table} aus. Unterhalb der Tabelle kann die Seitengröße eingestellt oder eine Seite weiter bzw. zurück gegangen werden. Die Anzeige \texttt{1-5} steht dabei für die ersten fünf Elemente, die gezeigt werden. Drückt man auf den Pfeil nach rechts werden die Argumente der GraphQL Query erneut gesetzt \texttt{{first: pageSize, after: endCursor}} und dadurch ein neuer Request abgeschickt.
Der Wert von \texttt{endCursor} geht aus der letzten Antwort der "AdminListProjects" Query aus Listing~\ref{lst:graphql:query} hervor. Der Wert \texttt{pageSize} wird innerhalb der Angular Komponente gehalten. 

Des Weiteren wird ein neuer Request durch Setzen des Input-Typen der Query gesendet, wenn auf die Spalten Bezeichner "name" oder "slug" gedrückt wird. Es sind nur die Spalten sortierbar die in Listing~\ref{lst:graphql:inputtype} im \texttt{OrderFieldEnum} enthalten sind.

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{snippets/paginator-table.png}
	\caption{Einheitliche Material Angular Tabelle zum Paginieren und Sortieren}
	\label{impl:graphql:paginator-table}
\end{figure}

\section{Validieren}
\label{graphql:validation}
Wie bereits in \fullref{req:validation:json} erwähnt, müssen Felder, die nicht implizit vom GraphQL Typschema validiert werden, gegen die bestehenden JSON Schema Definitionen validiert werden. Im Folgenden wird gezeigt, wie multilinguale Strings und Typen gegen JSON Schema Definitionen validiert werden.

\subsection{Multilinguale Strings}
\label{graphql:validation:multi}
Multilinguale Strings werden im GraphQL Schema als ein eigens definierter Scalar Typ behandelt.
Dieser heißt \texttt{LangJson} und besitzt wie für Scalar Typen üblich die beiden Funktionen \texttt{self.coerce\_input} und \texttt{self.coerce\_result}. In beiden dieser Methoden wird der eingehende bzw. ausgehende Datensatz mithilfe des Validators \texttt{Languages} aus Listing~\ref{lst:multilang-validation} geprüft. 
Bei der Prüfung wird die Schnittmenge zwischen den Schlüsseln des zu validierenden Objekts als Array und den im Enum aufgelisteten verfügbaren Ländercodes als Array gebildet. Wenn die Schnittmenge leer ist beinhaltet das übergebene Objekt keine valide Sprache und ist damit ungültig. Sollte die Schnittmenge nicht leer sein, wird geprüft, ob die Differenzmenge von den Schlüsseln des Objektes ohne die verfügbaren Ländercodes nicht leer ist. Ist das der Fall, wurden Schlüssel angegeben, die nicht kompatibel zu den vorhandenen Ländercodes sind (siehe Abbildung~\ref{req:typesafe:example}). 

\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{snippets/multilang-validation.pdf}
	\caption{Beispiel für die Validierung von Multilingualen Strings}
	\label{req:typesafe:example}
\end{figure}

\begin{lstlisting}[language=Ruby,float=h!,caption={Validator Klasse zum Prüfen, ob der übergebene Parameter die Beschaffenheit eines multilingualen Strings aufweist. \lstinline|/graphql/validators/languages.rb|}, label={lst:multilang-validation}]
class Languages
  def self.validate!(args)
    if (Types::Base::BaseEnum::LanguageEnum.values.keys & args.keys).empty?
      raise GraphQL::ExecutionError, "Language Keys are missing for #{args}"
    elsif not (args.keys - Types::Base::BaseEnum::LanguageEnum.values.keys).empty?
      raise GraphQL::ExecutionError, "Unknown Language Keys provided in #{args}"
    end
  end
end
\end{lstlisting}

\subsection{JSON Schema}
\label{sec:impl:json-schema-validation}
Die Validation von im Schema nicht abbildbaren Typen gegen vorhandene JSON Schema funktioniert genau wie bei multilingualen Strings. Der einzige Unterschied ist der verwendete Validator (siehe Listing~\ref{lst:jsonschema-validation}). Beim Aufruf der \texttt{validate!} Funktion werden der Name des JSON Schemas und das zu validierende Objekt  als Parameter übergeben. Beim Laden der JSON Schema Definitionen und beim Validieren wurde sich das bereits bestehende System zu Nutze gemacht, indem der \texttt{JsonSchemaHelper} eingebunden wurde und dessen Funktion \texttt{json\_schema\_validate} verwendet. 

\begin{lstlisting}[language=Ruby,float=h!,caption={Validator Klasse zum Prüfen, ob der übergebene Parameter die Beschaffenheit des JSON Schema aufweist. \lstinline|/graphql/validators/graphql_validator.rb|}, label={lst:jsonschema-validation}]
class GraphqlValidator
  extend JsonSchemaHelper
  def self.validate!(schema_name:, document:)
    result = json_schema_validate(schema_name, document)
    if result.length > 0
      raise GraphQL::ExecutionError.new("Given document of type #{schema_name} does not match the schema[...]", extensions: { code: 'VALIDATION' })
    end
  end
end
\end{lstlisting}

\section{Unerwartete Hindernisse}
Im Laufe der Migration traten einige unerwartete Hindernisse bei der Nutzung von Codegeneratoren auf. Manche der Hindernisse ließen sich durch Nachfragen beim Entwickler und Erstellen eines Github Issues auflösen.

\subsection{Fehlerhafte Codegenerierung der Angular Services}
Beim Testen von Angular Komponenten, die generierte Angular Services injiziert bekamen, war der Zugriff auf \texttt{this.apollo} undefiniert~\cite{github-apollo-undefined}. Dies resultierte daraus, dass in der Testumgebung die Apollo Abhängigkeiten beim Injizieren eines Services nicht richtig eingebunden wurden. Die Klasse \texttt{Query} aus dem Apollo Framework bekam im Konstruktor nicht den Zugriff auf die Apollo Instanz übergeben. Somit schlugen alle Tests fehl, die einen aus GraphQL generierten Angular Service nutzten.

Die Lösung dieses Problems war das manuelle Übergeben der Apollo Instanz an die Query Klasse durch Injizieren von Apollo in die generierten Services und Übergeben der Instanz im Aufruf des Konstruktors der Oberklasse (siehe Listing~\ref{lst:super-call}).

\begin{lstlisting}[language=JavaScript,float=h!,caption={Injizieren von Apollo in generierten Angular Service und Übergeben der Apollo Instanz an den Konstruktors der Oberklasse}, label={lst:super-call}]
export class AdminListProjectsGQL extends Apollo.Query<
  AdminListProjectsQuery,
  AdminListProjectsQueryVariables
> {
	document = AdminListProjectsDocument;
	constructor(apollo: Apollo.Apollo) {
		super(apollo);
	}
}
\end{lstlisting}

\subsection{Unmöglichkeit der Modellierung mancher Typen}
\label{sec:impl:scalar-any-types}
In Unterabschnitt~\ref{sec:impl:json-schema-validation} und Abschnitt~\ref{graphql:scalartypes} wurde bereits aufgegriffen, dass manche Typen wie \texttt{LangJson} unmöglich im GraphQL Schema modelliert werden können und stattdessen Scalar Typen verwendet wurden.
Die Verwendung der skalaren Typen für nicht abbildbare Typen hat allerdings den Nachteil, dass die Codegeneratoren an dieser Stelle lediglich den Typ \texttt{any} zuweisen können, da sie keine Kenntnis über die zugrunde liegenden JSON Schema Definitionen besitzen (siehe Listing~\ref{lst:skalar:codegeneration}).


\begin{lstlisting}[float=h!,caption={Auflistung aller skalaren Typen nach der Codegerierung zu Typescript Typen}, label={lst:skalar:codegeneration}]
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  LangJson: any;
  [...]
};
\end{lstlisting}

\chapter{Fazit}
Dieses Fazit soll einen Überblick darüber verschaffen, welche Ziele aus der Anforderungsanalyse erreicht wurden und welche Features für die Zukunft noch interessant wären.
Zu Beginn sei vorweggenommen, dass GraphQL bzw. explizit graphql-ruby Lösungen zu allen beschriebenen Problemen und Anforderungen aus Kapitel~\fullref{sec:requirements} ermöglicht. Zudem konnte durch die Migration nach GraphQL die Skalierbarkeit des Entwicklungsprozesses deutlich erhöht werden und zusätzlich der Grundstein für die Implementierung der in Ausblick aufgeführten Features, gelegt werden.

\textbf{Typschema} \ \\
Durch die Definition des Typschemas in Ruby und der Übersetzungsmöglichkeiten in andere Sprachen mithilfe von Codegeneratoren werden applikationsübergreifende und zentrale Typdefinitionen als JSON Schema,
die sogar größtenteils zu den alten JSON Schema Definitionen passen, geschaffen (siehe Abschnitt~\ref{impl:graphql:generation}). Im Gegensatz zum alten System hat sich die Verantwortlichkeit für die Definition von Typen also vom Client auf den Server verlagert. Diese werden jetzt dem Client in Form von JSON Schemata zur Verfügung gestellt. Ausbaufähig an dieser Stelle ist das in Unterabschnitt~\ref{sec:impl:scalar-any-types} gezeigte Defizit in der Codegenerierung.

\textbf{Validierung} \ \\
Des Weiteren wurden für Typescript Interfaces wie \texttt{MultiLangString} (siehe Listing~\ref{lst:example:projectdesc}),  die sich nicht im GraphQL Schema abbilden lassen, Scalar Typen entwickelt, deren Werte bei lesenden und schreibenden Zugriffen gegen das alte JSON Schema validiert werden (siehe Abschnitt~\ref{graphql:validation}). Alle abbildbaren Typen werden automatisch auf Korrektheit geprüft. Die Prüfungen werden beim Lesen eingehender Anfragen und beim Erzeugen der Antworten durchgeführt. Dadurch wird im Vergleich zum alten System ein höherer Grad an Typsicherheit erlangt, da nun zusätzlich die  Antworten zur Laufzeit vor dem Ausliefern an den Client validiert werden. Dies geschah vorher nur in Form von Request Specs während des Deployment Prozesses (siehe Unterabschnitt~\ref{sec:requirements:pros:typesafe-runtime}).

\textbf{Bennennungskonvention} \ \\
graphql-ruby übersetzt automatisch alle Benennungen von der auf dem Server genutzte Snake Case Schreibweise zur im Schema verwendeten Camel Case Schreibweise, nach dem Auflösen eines Feldes. Somit kann auf dem Server weiterhin Snake Case für alle Benennungen genutzt werden und trotzdem wird Code in Camel Case Schreibweise generiert.

\textbf{Sicherheit} \ \\
Ein weiterer Aspekt zur Sicherheit ist, dass alle GraphQL Queries, die im gesamten Projekt genutzt werden, in einzelnen Dateien in einem für den Server zugreifbaren Ordner gehalten werden. 
Stellt der Client eine Anfrage, wird geprüft, ob ein Name (\texttt{operationName}) übermittelt wurde und dieser zu einer der im Ordner existierenden Queries passt. Wenn ja, wird diese geladen und ausgeführt, andernfalls eine Fehlermeldung zurückgegeben. Somit können wie im alten System nur vordefinierte Interaktionen ausgeführt werden.

\textbf{Darstellungsflexibilität} \ \\
In der Implementierung wurde obendrein ein System geschaffen, das alle für variierende Darstellungsformen benötigten Features - wie Felder- und Sprachauswahl sowie Filtern, Sortieren und Paginieren (siehe Unterabschnitt~\ref{sec:requirements:req:view}) - umsetzt. Innerhalb einer serverseitigen Klasse \texttt{BaseResolver}, deren Konstruktor bei Listendarstellungen von allen GraphQL Queries durchlaufen werden (siehe Abbildung~\ref{graphql:sorting}), werden SQL Queries zusammengesetzt. Diesem Prozess können Werte zum Paginieren, Filtern, Sortieren und für die Sprachauswahl übergeben werden. Zudem kann aus dem Kontext einer Query ausgelesen werden, welche Felder ausgewählt wurden.

\textbf{Performance und Skalierbarkeit} \ \\
Durch Auswählen der benötigten Felder ist das Overfetching Problem beseitigt worden.
Darüber hinaus kann in den Prozess des Zusammensetzens der SQL Query im \texttt{BaseResolver} eingegriffen werden. Bei Anfragen, die ein N+1 Query Problem aufweisen, können zur Beseitigung manuell Beziehungen in die Ergebnismenge einer Query inkludiert werden. Somit lässt sich jedes Underfetching Problem - wie in Abbildung~\ref{impl:graphql:paginator-table} mit der Anzahl der Code Ressourcen - manuell lösen.
Vergleicht man zusätzlich die Tabellen \ref{impl:tbl:newview} und \ref{tbl:newview}, in denen die Schritte zu Erstellung einer neuen Sicht beschrieben werden, wird erkenntlich, dass durch die Migration nach GraphQL der Entwicklungsaufwand deutlich reduziert werden konnte. 


\section{Ausblick}
Die Migration nach GraphQL ermöglicht eine Menge Features, die es sich lohnt, zukünftig zu integrieren.
Nachfolgend werden die wichtigsten Features aufgelistet und kurz erläutert.

\textbf{Batching} \ \\
Wie bereits erwähnt, ist Batching ein Verfahren um mehrere Anfragen gebündelt zu verschicken. Es könnte beispielsweise bei Anforderung einer Anfrage ein Zeitlimit (50ms) gesetzt werden, welches abgewartet wird, bevor die Anfrage verschickt wird. Fordert der Client innerhalb dieses Zeitlimits eine neue Anfrage an, wird diese mit der ersten zusammengefasst. Nach Ablauf der 50ms werden dann alle zusammen als eine an den Server geschickt. 

\textbf{Client Cache} \ \\
Apollo bietet die Möglichkeit an einen Cache zu nutzen. In der gezeigten Implementierung wird bei Anfragen aktuell die Option \texttt{fetchPolicy} auf \texttt{network\--only} gestellt um bei jeder Anfrage die neusten Daten zu erhalten (siehe Unterabschnitt~\ref{impl:graphql:component}). Diese Option könnte zum Beispiel nur nach Ausführung einer Mutation gesetzt werden, sodass nur neue Daten geladen werden, wenn sich auf dem Server etwas verändert hat.
	
\textbf{Autorisierung} \ \\
Der einzige Grad an Sicherheit, der implementiert wurde, ist, dass nur im Schema Ordner definierte GraphQL Queries ausgeführt werden können. Die Nutzung einer Library für rollenbasierte Autorisierung wie Pundit~\cite{pundit} ist zu empfehlen.

\textbf{Sorbet und Typesafe-Ruby} \ \\
Sorbet~\cite{sorbet} und Typesafe-Ruby~\cite{typesafe-ruby} sind Rubygems, die es unter anderem ermöglichen, bei Funktionen typisierte Rückgabewerte zu definieren oder einem übergebenen Parameter einen Typ aufzuzwingen. Dadurch würde - analog zum Client - die Typsicherheit in der Serverapplikation garantiert werden.

\textbf{Überschreiben von generierten Typdefinitionen} \ \\
Das erwähnte Problem der löchrigen Codegenerierung (siehe Unterabschnitt~\ref{sec:impl:scalar-any-types}) kann durch Überschreiben der \texttt{any}-Typen mit den ursprünglich in Typescript definierten Interfaces, aus denen JSON Schemata generiert wurden, gelöst werden. Andernfalls kann durch zum Beispiel die Ausführung eines Scripts die generierte Typescript Datei manuell angepasst werden.

