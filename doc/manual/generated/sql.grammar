grammar "sql" {
  typedef "expression" ::= columnName | binaryExpression | constant | parameter | functionCall
  node "columnName" {
    prop "refTableName" { string }
    terminal "."
    prop "columnName" { string }
  }
  node "constant" {
    prop "value" { string }
  }
  node "parameter" {
    prop "name" { string }
  }
  node "functionCall" {
    prop "name" { string }
    terminal "("
    children sequence, "arguments"  ::= expression*
    terminal ")"
  }
  node "starOperator" {
    terminal "*"
  }
  node "relationalOperator" {
    prop "operator" { string { enum "<" "<=" "=" ">=" ">" "LIKE" "NOT LIKE" } }
  }
  node "binaryExpression" {
    children sequence, "lhs"  ::= expression
    children sequence, "operator"  ::= relationalOperator
    children sequence, "rhs"  ::= expression
  }
  node "select" {
    terminal "SELECT"
    prop? "distinct" { boolean }
    children allowed, "columns", sep: "," ::= expression* & starOperator?
  }
  node "delete" {
    terminal "DELETE"
  }
  node "tableIntroduction" {
    prop "name" { string }
    prop? "alias" { string }
  }
  node "crossJoin" {
    children sequence, "table"  ::= tableIntroduction
  }
  node "innerJoinOn" {
    terminal "INNER JOIN"
    children sequence, "table"  ::= tableIntroduction
    terminal "ON"
    children sequence, "on"  ::= expression
  }
  node "innerJoinUsing" {
    terminal "INNER JOIN"
    children sequence, "table"  ::= tableIntroduction
    terminal "USING"
    children sequence, "using"  ::= expression
  }
  typedef "join" ::= crossJoin | innerJoinUsing | innerJoinOn
  node "from" {
    terminal "FROM"
    children sequence, "tables", sep: "," ::= tableIntroduction+
    children sequence, "joins"  ::= join*
  }
  node "whereAdditional" {
    prop "operator" { string { enum "and" "or" } }
    children sequence, "expression"  ::= expression
  }
  node "where" {
    terminal "WHERE"
    children sequence, "expressions"  ::= sql.expression sql.whereAdditional*
  }
  node "groupBy" {
    terminal "GROUP BY"
    children allowed, "expressions", sep: "," ::= sql.expression*
  }
  node "orderBy" {
    terminal "ORDER BY"
    children allowed, "expressions", sep: "," ::= sql.expression*
  }
  node "querySelect" {
    children sequence, "select"  ::= select
    children sequence, "from"  ::= from
    children sequence, "where"  ::= where?
    children sequence, "groupBy"  ::= groupBy?
    children sequence, "orderBy"  ::= orderBy?
  }
  node "queryDelete" {
    children sequence, "delete"  ::= delete
    children sequence, "from"  ::= from
    children sequence, "where"  ::= where?
  }
  typedef "query" ::= querySelect | queryDelete
}
