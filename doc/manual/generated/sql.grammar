grammar "sql" {
  node "expression" {
    children "expression" ::= columnName | binaryExpression | constant | parameter | functionCall
  }
  node "columnName" {
    prop "columnName" { string }
    prop "refTableName" { string }
  }
  node "constant" {
    prop "value" { string }
  }
  node "parameter" {
    prop "name" { string }
  }
  node "functionCall" {
    prop "name" { string }
    children "arguments" ::= expression*
  }
  node "starOperator" {
  }
  node "relationalOperator" {
    prop "operator" { string { enum "<" "<=" "=" ">=" ">" } }
  }
  node "binaryExpression" {
    children "operands" ::= expression relationalOperator expression
  }
  node "select" {
    prop? "distinct" { boolean }
    children "columns" ::= columnName* & starOperator?
  }
  node "delete" {
  }
  node "tableIntroduction" {
    prop "name" { string }
    prop? "alias" { string }
  }
  node "crossJoin" {
    children "table" ::= tableIntroduction
  }
  node "innerJoinOn" {
    children "table" ::= tableIntroduction
    children "on" ::= expression
  }
  node "innerJoinUsing" {
    children "table" ::= tableIntroduction
    children "using" ::= columnName
  }
  typedef "join" {
    "crossJoin"
    "innerJoinUsing"
    "innerJoinOn"
  }
  node "from" {
    children "tables" ::= tableIntroduction join*
  }
  node "whereAdditional" {
    prop "operator" { string }
    children "expression" ::= expression
  }
  node "where" {
    children "expressions" ::= expression whereAdditional*
  }
  node "groupBy" {
    children "expressions" ::= expression* & columnName*
  }
  node "querySelect" {
    children "select" ::= select
    children "from" ::= from
    children "where" ::= where?
    children "groupBy" ::= groupBy?
  }
  node "queryDelete" {
    children "delete" ::= delete
    children "from" ::= from
    children "where" ::= where?
    children "groupBy" ::= groupBy?
  }
  typedef "query" {
    "querySelect"
    "queryDelete"
  }
}
