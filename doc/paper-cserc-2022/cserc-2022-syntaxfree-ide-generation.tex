\documentclass[sigconf,review=true]{acmart}

\usepackage{minted}    % Source code formatting
\usepackage{csquotes}  % Eases working with quotes
\usepackage[author={Marcus}]{pdfcomment}

% "Constant" to set the scaling of all ASTs at once
\newcommand\astScale{0.75}

\begin{document}
\title[]{Generating syntaxfree development environments for real world programming languages}

\author{Marcus Riemer}
\affiliation{%
  \institution{Christian-Albrechts-Universität}
  \city{Kiel}
  \country{Germany}
}
\email{post@marcusriemer.de}

\begin{abstract}
  Computer science introduction often uses syntaxfree drag-and-drop programming languages to ease the first steps in the field. This approach has the benefit of eliminating the whole possibility to confront learners with syntax errors. But the actual languages that are not relevant in the actual programming industry.

  We present a grammar driven approach to augment traditional programming and markup languages like SQL, JavaScript and HTML in way that allows them to be used in a drag-and-drop manner using either Google Blockly or a custom editor that closely resembles the textual structure. Augmenting traditional languages in such a way allow users to become familiar with the syntax language and concentrate on learning the semantics of the language.
\end{abstract}

\maketitle

\section{Introduction}

\section{Architecture Overview}

Blatt\-Werkzeug defines the common set of core data structures: Syntax\-trees, grammars \& validators. The main reason for this re-invention the wheel is the differing focus of existing software: The syntaxtrees of conventional compilers (like \texttt{gcc}, \texttt{llvm}, \texttt{javac}, …) are focused on speed and correctness, and not a friendly representation for drag \& drop mutations.

BlattWerkzeug instead focuses exclusively on working with a syntaxtree that lends itself well to be directly presented to the end user. Most importantly, there must not be any node that has no visual or textual representation. Typical compiler tasks that have to do with lexical analysis or parsing are not relevant for Blatt\-Werkzeug.

\section{Abstract Syntax Tree}

The syntax tree itself is purely a \texttt{JSON} data structure that follows the TypeScript definition in listing~\ref{lst:typescript-ast} and has no concept of being \textit{valid} or \textit{invalid} on its own (this is the task of validators). It also has no idea how to it should be represented in its block form (this is the task of block languages) or textual representation (this is the task of code generators).

\begin{listing}[H]
\begin{minted}{typescript}
export interface NodeDescription {
  name: string
  language: string
  children?: {
    [childrenCategory: string]: NodeDescription[];
  }
  properties?: {
    [propertyName: string]: string;
  }
}
\end{minted}
\caption{TypeScript definition of AST}
\label{lst:typescript-ast}
\end{listing}

A single node in the syntaxtree has at least a \textbf{type} that consists of two strings: A local name and a language. This type is the premier way for different tools to decide how the node in question should be treated. The language is essentially a namespace that allows the use of identical names in different contexts. This is useful when describing identical concepts like imperative loops or semantic markup for \enquote{heading} in different languages.

Nodes may define so called \textbf{properties} which hold atomic values in the form of texts or integers, but never in the form of child nodes. Each of these properties needs to have a name that is unique in the scope of the current node.

The children of nodes have to be organized in so called \textbf{child groups}. Each of these groups has a name and contains any number of subtrees in order. Naming the child groups enables the grammars to specify complex subtrees without relying on the ordering of sub-trees. The resulting structure has a strong resemblance to an \texttt{XML}-tree, but instead of grouping all children in a single, implicit scope, they are organised into their own-subtrees.

\subsection{Example: Binary Expression}

The tree in listing~\ref{lst:ast-expr-binary} is shown in two equivalent representations: \texttt{JSON} and a rendered tree. It is a possible representation of the expression \texttt{numRattles == null} for any language that allows to compare a \texttt{null} value against a variable. It consists of three nodes: The root node is of type \texttt{lang.expBin}, the dot (\enquote{\texttt{.}}) is used as a separator between the \texttt{language} and \texttt{name} of a node. The childgroup with the name \texttt{lhs} (\enquote{left hand side}) contains a node of type \texttt{lang.expVar} which is meant to refer to an existing variable on the left hand side of the expression. The property \texttt{name} is set to \texttt{numRattles}.

\begin{listing}[H]
\begin{minted}{typescript}
{
  "language": "lang",
  "name": "expBin",
  "properties": { "op": "eq" },
  "children": {
    "lhs": [
      {
        "language": "lang",
        "name": "expVar",
        "properties": { "name": "numRattles" }
      }
    ],
    "rhs": [
      { "language": "lang", "name": "null" }
    ]
  }
}
\end{minted}
\includegraphics[scale=\astScale]{../manual/generated/ast-example-expr-binary}
\caption{AST for expression \texttt{null}}
\label{lst:ast-expr-binary}
\end{listing}

\subsection{Example: \texttt{if}-Statement}

The following example further motivates the reasoning for named child groups and shows how the non-existant parsing-step can be used for more precise error messages.

An \texttt{if} statement can be described in terms of its structure and the underlying semantics: It uses a predicate to distinguish whether execution should continue on a positive branch or a negative branch. Details about the name of the keyword itself (probably if \texttt{if}, maybe a \texttt{then}, maybe with parentheses around the predicate?) or the syntax of blocks (\texttt{\{\}}, \texttt{begin} ... \texttt{end}, indentation, ..?) are irrelevant for the semantics.

Listing~\ref{lst:if-stmt-pred} shows two sample programs: One with a correct \texttt{if}-Statement that uses a \texttt{then} is shown on the left. And one program with an incorrect \texttt{if}-Statement that accidentaly omits the \texttt{then} and the correspdonding expression is shown on the right. The correspdonding syntaxtree for the correct variation is shown in figure~\ref{fig:if-stmt-pred}. The expression \texttt{a > b} is in the \texttt{pred} child group, the call to \texttt{writeln} is in the \texttt{positive} child group and the call to \texttt{err} is in the \texttt{negative} child group. From the perspective of the syntaxtree, each of these child groups has a distinct meaning that is also conveyed as part of the name. Even without hand-crafted error messages an error like \texttt{\enquote{lang.if} has empty childgroup \enquote{predicate}} would quite nicely convey the problem with a missing expression for the predicate. Without named childgroups, e.g. in a \texttt{XML} like tree structure, the semantics of the sub-trees would be defined by the order they appear in and there would be no easily available name.

But the actual benefit of only working with syntax trees and not requiring a parsing step goes deeper than having nicer error messages for free. The incorrect \texttt{if}-statement that omits the expression and the \texttt{then} in listing~\ref{lst:if-stmt-pred} uses indentation to convey the intent of the author: The \texttt{writeln} statement is offset in the same way as the \texttt{err} statement. But a parser that stumbles over this code would, at least without extra logic, be mislead by the \texttt{writeln} statement reading exactly like an expression. The most probable error message would read something along the lines of \enquote{\texttt{Invalid predicate: expression writeln('foo') is not of type boolean}} and \enquote{\texttt{Missing keyword then}}. In contrast the syntax tree can't make such a miss-attribution by accident because it relies on named child groups, not on the order of the sub-trees.

\begin{listing}[H]
\begin{minipage}{.20\textwidth}
\begin{minted}{pascal}
if (a > b) then
  writeln('foo')
else
  err(2, 'bar')
\end{minted}
\end{minipage}
\begin{minipage}{.20\textwidth}
\begin{minted}{pascal}
if
  writeln('foo')
else
  err(2, 'bar')
\end{minted}
\end{minipage}
\caption{\texttt{if}-Statement with and without predicate}
\label{lst:if-stmt-pred}
\end{listing}

\begin{figure*}
  \includegraphics[scale=\astScale]{../manual/generated/ast-example-if}
  \caption{\texttt{if}-Statement with predicate}
  \label{fig:if-stmt-pred}
\end{figure*}

\section{Grammars \& Structure Validation}

As syntaxtrees may define arbitrary tree structures, but for practical reasons only trees conforming to a certain set of known properties and children are of relevance. The example in listing~\ref{lst:ast-expr-binary} implicitly relied on a few limitations:

\begin{enumerate}
\item \texttt{lang.null} never has children or properties.

\item \texttt{lang.expVar} never has children, but it must have a property called \texttt{name} which denotes the name of the variable the expression refers to.

\item \texttt{lang.expBin} has two child groups named \texttt{lhs} and \texttt{rhs} which stand for the two sides of the equation. These child groups may themselves contain a single \texttt{null}, \texttt{expVar} or \texttt{expBin}. The property \texttt{op} will treat the value \texttt{eq} with the meaning \enquote{equality} and possibly allows other values such as \texttt{leq} or \texttt{gt}.
\end{enumerate}

Imposing such structural requirements by restricting the allowed or required properties and child groups is done with a grammar. The underlying validation concept is losely based on XML Schema and RelaxNG, the syntax of the latter is also used as the inspiration to describe the grammars in a user friendly textual representation.

In contrast to grammars in general compiler construction, the grammar described here is not meant to create a syntax tree from some stream of tokens but rather begins with an empty syntax tree. This frees it from many of the problems that have been mentioned above:

\begin{enumerate}
\item There is no whitespace and seperation characters are never required. What matters is only the structure of the tree: The type of the node in question determines which properties and child groups exist and what values are permitted.
\item Syntax errors equate to missing nodes and can be communicated very clearly. Semantic analysis does not need to rely on heuristics on how the tree could change if the \enquote{blanks} were filled in.
\end{enumerate}

In comparision to traditional grammars, this shifts the way one has to reason about the validation rules inside of BlattWerkzeug: There is no need to worry about the syntactic aspects of a certain language, the grammar that is required doesn’t need to know anything about keywords or separating characters. Its sole job is to describe the structure and the semantics of trees that are valid in that specific language. If keywords are included in the grammar, this is solemly for the purpose of blocks that resemble the underlying programming language or for code generation. The actual grammar validation does not use these keywords at all.

\subsection{Example: Expression Semantics}

In this example we will construct a grammar to validate structures like the expression in listing~\ref{lst:ast-expr-binary}.

This grammar in listing~\ref{lst:grammar-expr-null} defines a language named \texttt{lang} which allows a single node with the name \texttt{null} to be present in the syntax tree. This node may not have any children or properties, so the only valid syntaxtree would consist of a single node.

\begin{listing}[H]
\begin{minted}{typescript}
grammar "lang" {
  node "null" {
  }
}
\end{minted}
\caption{Grammar for expression \texttt{null}}
\label{lst:grammar-expr-null}
\end{listing}

In order to also allow references to variables, we add a second valid type of node called \texttt{expVar} (listing~\ref{lst:grammar-expr-expVar}. Nodes of this type must have the property \texttt{name} being present, but at the given state we do not make any practical restriction on how this name could look like.

\begin{listing}[H]
\begin{minted}[]{typescript}
grammar "lang" {
  // node null as before

  node "expVar" {
    prop "name" { string }
  }
}
\end{minted}
\caption{Grammar for expression \texttt{expVar}}
\label{lst:grammar-expr-expVar}
\end{listing}

With the types \texttt{lang.null} and \texttt{lang.expVar} defined, we now have two leaf nodes for our expression language. In order for a type to act as a parent, as \texttt{lang.expBin} must, we need to define the names and the valid types for the child groups. Listing~\ref{lst:grammar-expr-expBin-verbose} declares such a type that defines the child groups \texttt{lhs} and \texttt{rhs} to either take a \texttt{expNull} or an \texttt{expVar}. With this grammar we may now generate checks for comparisions like \texttt{a + 1}, \texttt{a >= a} or \texttt{null == null}.

\begin{listing}[H]
\begin{minted}[]{typescript}
grammar "lang" {
  // node null and expVar as before

  node "expBin" {
    children "lhs" ::= expNull | expVar
    prop     "op"  { string }
    children "rhs" ::= expNull | expVar
  }
}
\end{minted}
\caption{Grammar for expression \texttt{expBin}}
\label{lst:grammar-expr-expBin-verbose}
\end{listing}

Unfortunately there is already some duplication in the definitions of the child groups \texttt{lhs} and \texttt{rhs}: Both should always allow the exact same types. And on top of that it is not possible to nest expressions, because \texttt{lang.expBin} is not an allowed child for either of the sides.

In a typical grammar we would introduce a new node type like \texttt{lang.expAny} which would consist of a single child group that lists all permitted values. Listing~\ref{lst:grammar-expr-expBin-choiceNode} shows the relevant excerpt of the grammar and figure~\ref{fig:ast-choice-node} demonstrates how a valid tree for this grammar could look like: The immediate children of \texttt{lang.expBin} are no longer the actual nodes with semantic meaning, but the artifical choice nodes of type \texttt{lang.expAny}.

\begin{listing}[H]
\begin{minted}[]{typescript}
grammar "lang" {
  // node null and expVar as before

  node "expAny" {
    children "exp" ::= expBin | expNull | expVar
  }

  node "expBin" {
    children "lhs" ::= expAny
    prop     "op"  { string }
    children "rhs" ::= expAny
  }
}
\end{minted}
\caption{Grammar for expression \texttt{expBin} with choice node}
\label{lst:grammar-expr-expBin-choiceNode}
\end{listing}

\begin{figure}
  \includegraphics[scale=\astScale]{../manual/generated/ast-example-expr-binary-artificial}
  \caption{Expression tree with artificial choice nodes}
  \label{fig:ast-choice-node}
\end{figure}

The tree for such a grammar would however contain nodes of type \texttt{expAny} that do not have any kind of possible representation for the end user: As there is no possible textual representation for such a node, it would appear as a completely empty block that can only host another block. The examples syntax trees in  figure~\ref{fig:ast-choice-node} and listing~\ref{lst:ast-expr-binary} would both be compiled to the exact same textual representation \texttt{numRattles == null}.

To avoid these nodes without visual or textual representation any kind of recurring choice between multiple node types is treated differently from the conventional approach in these grammars: By introducing a pure virtual node type that is referrable by name in the grammar, but may never appear in an actual syntax tree. The textual grammar representation uses the keyword \texttt{typedef} to introduce such a type, the following listing~\ref{lst:grammar-expr-expBin-typedef} changes the definition of \texttt{nodeAny} to be such a virtual node and shows the final grammar for the semantics of simple expressions in entirety. The previous definition of \texttt{expBin} (as in listing~\ref{lst:grammar-expr-expBin-choiceNode} is unaffected by this change, altough the trees that are validated by the grammars are different. This updated grammar that uses the \texttt{typedef} approach will successfully validate the example binary expression from listing~\ref{lst:ast-expr-binary}.

\begin{listing}[H]
\begin{minted}[]{typescript}
grammar "lang" {
  node "null" {
  }

  node "expVar" {
    prop "name" { string }
  }

  typedef "expAny" ::= expBin | expNull | expVar

  node "expBin" {
    children "lhs" ::= expAny
    prop     "op"  { string }
    children "rhs" ::= expAny
  }
}
\end{minted}
\caption{Final semantic grammar for expression \texttt{expBin}}
\label{lst:grammar-expr-expBin-typedef}
\end{listing}

\subsection{Example: Expression Syntax}

Although the syntax trees that are validated by the final semantic grammar for the expression language (listing~\ref{lst:grammar-expr-expBin-typedef}) are unambiguous in tree form, their default textual representation is possibly not. Figure~\ref{fig:ast-nested-ambiguous} shows a tree that in a depth first evaluation would effectively calculate $\alpha+\pi$ first and then multiply the result with $2$. Or in textual form: The intended order of operation is $2 * (\alpha+\pi)$.

\begin{figure}
  \includegraphics[scale=\astScale]{../manual/generated/ast-example-expr-binary-nested}
  \caption{Expression with addition before multiplication}
  \label{fig:ast-nested-ambiguous}
\end{figure}

\section{Block Language}

Brief explanation about the nature of block languages.

\subsection{Builtin Editor}

Backend #1: Some screenshots.

\subsection{Blockly Editor}

Backend #2: Some screenshots.

\subsection{Sidebar}

Available in both.

\section{Runtime}

\subsection{PrettyPrinting}

Backend #3: Some Listings

\section{Example: HTML}

\subsection{Order Of Children}

\section{Example: SQL}

\subsection{Validation}

\section{Design Principles}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-command-extra-options: "-shell-escape"
%%% TeX-engine: xetex
%%% TeX-master: t
%%% End: