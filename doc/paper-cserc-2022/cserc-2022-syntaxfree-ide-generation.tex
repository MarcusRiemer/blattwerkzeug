\documentclass[sigconf,natbib=false,review=true]{acmart}

\usepackage[
datamodel=acmdatamodel,
backend=biber,
style=acmnumeric, % use style=acmauthoryear for publications that require it
]{biblatex}

\addbibresource{CSERC22.bib}

%\usepackage[style=ACM-Reference-Format,backend=bibtex,sorting=none]{biblatex}
%\addbibresource{CSERC22.bib}

\usepackage{minted}    % Source code formatting
\usepackage{csquotes}  % Eases working with quotes
\usepackage[author={Marcus}]{pdfcomment}

% "Constant" to set the scaling of all ASTs at once
\newcommand\astScale{0.75}

\begin{document}

\title[]{Generating syntaxfree development environments for real world programming languages}

\author{Marcus Riemer}
\affiliation{%
  \institution{Christian-Albrechts-Universität}
  \city{Kiel}
  \country{Germany}
}
\email{post@marcusriemer.de}

\author{Frank Huch}
\affiliation{%
  \institution{Christian-Albrechts-Universität}
  \city{Kiel}
  \country{Germany}
}
\email{fhu@informatik.uni-kiel.de}

\begin{abstract}
  We present a grammar driven approach to augment traditional programming and markup languages like SQL, JavaScript and HTML in way that allows them to be used in a drag-and-drop manner using either Google Blockly or a custom editor that closely resembles the textual structure.
\end{abstract}

\begin{teaserfigure}
  \includegraphics[width=\textwidth]{screens/banner.png}
  \caption{Builtin block editor that resembles the syntax of the augmented SQL}
  \label{fig:banner}
\end{teaserfigure}

\maketitle

\section{Introduction}

Computer science introduction often uses syntaxfree drag-and-drop programming languages to ease the first steps when learning how to program. This approach has the benefit of eliminating the whole possibility to confront learners with syntax errors. But the actual languages that are being thaugt this way are not relevant in the programming industry. For educators, this is a inconvenient situation: Block languages are proven to be great tools to spark interest in programming. But making the step from block languages to conventional programming languages is still difficult. Additionally, some students view these environments as overly restrictive and \enquote{not real programming}\cite{braune_learning_2020}.

One important aspect is to explicitly plan the transition from block based languages to text based languages. In \cite{fraser_ten_2015} this is called the \enquote{exit strategy} and \cite{alrubaye_comparison_2019} shows promising results when confronting students with block and textual programming simultaneously. This paper therefore follows these ideas and presents an approach to rapidly generate block language variations of conventional programming languages. Instead of hiding syntax details like parentheses, semicolons, commas, ... these are organically made part of the blocks. Therefore learners are continously confronted with the syntax details of their language of choice without having to actually type it. Additionally the resulting program is not meant to be run only in some learning environment. On a technical level the program can be compiled to proper source code in the target language and be run.

\section{Architecture Overview}

Blatt\-Werkzeug defines the common set of core data structures: Syntax\-trees, grammars \& validators. The main reason for this re-invention the wheel is the differing focus of existing software: The syntaxtrees of conventional compilers (like \texttt{gcc}, \texttt{llvm}, \texttt{javac}, …) are focused on speed and correctness, and not a friendly representation for drag \& drop mutations.

BlattWerkzeug instead focuses exclusively on working with a syntaxtree that lends itself well to be directly presented to the end user. Most importantly, there must not be any node that has no visual or textual representation. Typical compiler tasks that have to do with lexical analysis or parsing are not relevant for Blatt\-Werkzeug.

At the core Blatt\-Werkzeug is about representing the same syntax tree in two different ways: Either as a block editor that can be used to edit the syntax tree. Or as a valid textual representation in the augmented programming language. For both of these representations and for general validation the desired structure is defined as a grammar.

On a technical level Blatt\-Werkzeug is split into a frontend and a backend, communication between these layers works via GraphQL. The backend is a Ruby on Rails application that uses PostgreSQL as a database, the frontend is written in TypeScript and uses Angular.

\section{Abstract Syntax Tree}

The syntax tree itself is purely a \texttt{JSON} data structure that follows the TypeScript definition in listing~\ref{lst:typescript-ast} and has no concept of being \textit{valid} or \textit{invalid} on its own (this is the task of validators). It also has no idea how to it should be represented in its block form (this is the task of block languages) or textual representation (this is the task of code generators).

\begin{listing}[H]
\begin{minted}{typescript}
export interface NodeDescription {
  name: string
  language: string
  children?: {
    [childrenCategory: string]: NodeDescription[];
  }
  properties?: {
    [propertyName: string]: string;
  }
}
\end{minted}
\caption{TypeScript definition of AST}
\label{lst:typescript-ast}
\end{listing}

A single node in the syntaxtree has at least a \textbf{type} that consists of two strings: A local name and a language. This type is the premier way for different tools to decide how the node in question should be treated. The language is essentially a namespace that allows the use of identical names in different contexts. This is useful when describing identical concepts like imperative loops or semantic markup for \enquote{heading} in different languages.

Nodes may define so called \textbf{properties} which hold atomic values in the form of texts or integers, but never in the form of child nodes. Each of these properties needs to have a name that is unique in the scope of the current node.

The children of nodes have to be organized in so called \textbf{child groups}. Each of these groups has a name and contains any number of subtrees in order. Naming the child groups enables the grammars to specify complex subtrees without relying on the ordering of sub-trees. The resulting structure has a strong resemblance to an \texttt{XML}-tree, but instead of grouping all children in a single, implicit scope, they are organised into their own-subtrees.

\subsection{Example: Binary Expression}

The tree in listing~\ref{lst:ast-expr-binary} is shown in two equivalent representations: \texttt{JSON} and a rendered tree. It is a possible representation of the expression \texttt{numRattles == null} for any language that allows to compare a \texttt{null} value against a variable. It consists of three nodes: The root node is of type \texttt{lang.expBin}, the dot (\enquote{\texttt{.}}) is used as a separator between the \texttt{language} and \texttt{name} of a node. The childgroup with the name \texttt{lhs} (\enquote{left hand side}) contains a node of type \texttt{lang.expVar} which is meant to refer to an existing variable on the left hand side of the expression. The property \texttt{name} is set to \texttt{numRattles}.

\begin{listing}[H]
\begin{minted}{typescript}
{
  "language": "lang",
  "name": "expBin",
  "properties": { "op": "eq" },
  "children": {
    "lhs": [
      {
        "language": "lang",
        "name": "expVar",
        "properties": { "name": "numRattles" }
      }
    ],
    "rhs": [
      { "language": "lang", "name": "null" }
    ]
  }
}
\end{minted}
\includegraphics[scale=\astScale]{../manual/generated/ast-example-expr-binary}
\caption{AST for expression \texttt{null}}
\label{lst:ast-expr-binary}
\end{listing}

\subsection{Example: \texttt{if}-Statement}

The following example further motivates the reasoning for named child groups and shows how the non-existant parsing-step can be used for more precise error messages.

An \texttt{if} statement can be described in terms of its structure and the underlying semantics: It uses a predicate to distinguish whether execution should continue on a positive branch or a negative branch. Details about the name of the keyword itself (probably if \texttt{if}, maybe a \texttt{then}, maybe with parentheses around the predicate?) or the syntax of blocks (\texttt{\{\}}, \texttt{begin} ... \texttt{end}, indentation, ..?) are irrelevant for the semantics.

Listing~\ref{lst:if-stmt-pred} shows two sample programs: One with a correct \texttt{if}-Statement that uses a \texttt{then} is shown on the left. And one program with an incorrect \texttt{if}-Statement that accidentaly omits the \texttt{then} and the correspdonding expression is shown on the right. The correspdonding syntaxtree for the correct variation is shown in figure~\ref{fig:if-stmt-pred}. The expression \texttt{a > b} is in the \texttt{pred} child group, the call to \texttt{writeln} is in the \texttt{positive} child group and the call to \texttt{err} is in the \texttt{negative} child group. From the perspective of the syntaxtree, each of these child groups has a distinct meaning that is also conveyed as part of the name. Even without hand-crafted error messages an error like \texttt{\enquote{lang.if} has empty childgroup \enquote{predicate}} would quite nicely convey the problem with a missing expression for the predicate. Without named childgroups, e.g. in a \texttt{XML} like tree structure, the semantics of the sub-trees would be defined by the order they appear in and there would be no easily available name.

But the actual benefit of only working with syntax trees and not requiring a parsing step goes deeper than having nicer error messages for free. The incorrect \texttt{if}-statement that omits the expression and the \texttt{then} in listing~\ref{lst:if-stmt-pred} uses indentation to convey the intent of the author: The \texttt{writeln} statement is offset in the same way as the \texttt{err} statement. But a parser that stumbles over this code would, at least without extra logic, be mislead by the \texttt{writeln} statement reading exactly like an expression. The most probable error message would read something along the lines of \enquote{\texttt{Invalid predicate: expression writeln('foo') is not of type boolean}} and \enquote{\texttt{Missing keyword then}}. In contrast the syntax tree can't make such a miss-attribution by accident because it relies on named child groups, not on the order of the sub-trees.

\begin{listing}[H]
\begin{minipage}{.20\textwidth}
\begin{minted}{pascal}
if (a > b) then
  writeln('foo')
else
  err(2, 'bar')
\end{minted}
\end{minipage}
\begin{minipage}{.20\textwidth}
\begin{minted}{pascal}
if
  writeln('foo')
else
  err(2, 'bar')
\end{minted}
\end{minipage}
\caption{\texttt{if}-Statement with and without predicate}
\label{lst:if-stmt-pred}
\end{listing}

\begin{figure*}
  \includegraphics[scale=\astScale]{../manual/generated/ast-example-if}
  \caption{\texttt{if}-Statement with predicate}
  \label{fig:if-stmt-pred}
\end{figure*}

\section{Expression Grammar}

As syntaxtrees may define arbitrary tree structures, but for practical reasons only trees conforming to a certain set of known properties and children are of relevance. The example in listing~\ref{lst:ast-expr-binary} implicitly relied on a few limitations:

\begin{enumerate}
\item \texttt{lang.null} never has children or properties.

\item \texttt{lang.expVar} never has children, but it must have a property called \texttt{name} which denotes the name of the variable the expression refers to.

\item \texttt{lang.expBin} has two child groups named \texttt{lhs} and \texttt{rhs} which stand for the two sides of the equation. These child groups may themselves contain a single \texttt{null}, \texttt{expVar} or \texttt{expBin}. The property \texttt{op} will treat the value \texttt{eq} with the meaning \enquote{equality} and possibly allows other values such as \texttt{leq} or \texttt{gt}.
\end{enumerate}

Imposing such structural requirements by restricting the allowed or required properties and child groups is done with a grammar. The underlying validation concept is losely based on \texttt{XML} Schema and RelaxNG, the syntax of the latter is also used as the inspiration to describe the grammars in a user friendly textual representation.

In contrast to grammars in general compiler construction, the grammar described here is not meant to create a syntax tree from some stream of tokens but rather begins with an empty syntax tree. This frees it from many of the problems that have been mentioned above:

\begin{enumerate}
\item There is no whitespace and seperation characters are never required. What matters is only the structure of the tree: The type of the node in question determines which properties and child groups exist and what values are permitted.
\item Syntax errors equate to missing nodes and can be communicated very clearly. Semantic analysis does not need to rely on heuristics on how the tree could change if the \enquote{blanks} were filled in.
\end{enumerate}

In comparision to traditional grammars, this shifts the way one has to reason about the validation rules inside of BlattWerkzeug: There is no need to worry about the syntactic aspects of a certain language, the grammar that is required doesn’t need to know anything about keywords or separating characters. Its sole job is to describe the structure and the semantics of trees that are valid in that specific language. If keywords are included in the grammar, this is solemly for the purpose of blocks that resemble the underlying programming language or for code generation. The actual grammar validation does not use these keywords at all.

\subsection{Expression Semantics}

In this example we will construct a grammar to validate structures like the expression in listing~\ref{lst:ast-expr-binary}.

This grammar in listing~\ref{lst:grammar-expr-null} defines a language named \texttt{lang} which allows a single node with the name \texttt{null} to be present in the syntax tree. This node may not have any children or properties, so the only valid syntaxtree would consist of a single node.

\begin{listing}[H]
\begin{minted}{typescript}
grammar "lang" {
  node "null" {
  }
}
\end{minted}
\caption{Grammar for expression \texttt{null}}
\label{lst:grammar-expr-null}
\end{listing}

In order to also allow references to variables, we add a second valid type of node called \texttt{expVar} (listing~\ref{lst:grammar-expr-expVar}. Nodes of this type must have the property \texttt{name} being present, but at the given state we do not make any practical restriction on how this name could look like.

\begin{listing}[H]
\begin{minted}[]{typescript}
grammar "lang" {
  // node null as before

  node "expVar" {
    prop "name" string
  }
}
\end{minted}
\caption{Grammar for expression \texttt{expVar}}
\label{lst:grammar-expr-expVar}
\end{listing}

With the types \texttt{lang.null} and \texttt{lang.expVar} defined, we now have two leaf nodes for our expression language. In order for a type to act as a parent, as \texttt{lang.expBin} must, we need to define the names and the valid types for the child groups. Listing~\ref{lst:grammar-expr-expBin-verbose} declares such a type that defines the child groups \texttt{lhs} and \texttt{rhs} to either take a \texttt{expNull} or an \texttt{expVar}. With this grammar we may now generate checks for comparisions like \texttt{a + 1}, \texttt{a >= a} or \texttt{null == null}.

\begin{listing}[H]
\begin{minted}[]{typescript}
grammar "lang" {
  // node null and expVar as before

  node "expBin" {
    children "lhs" ::= expNull | expVar
    prop     "op"  string
    children "rhs" ::= expNull | expVar
  }
}
\end{minted}
\caption{Grammar for expression \texttt{expBin}}
\label{lst:grammar-expr-expBin-verbose}
\end{listing}

Unfortunately there is already some duplication in the definitions of the child groups \texttt{lhs} and \texttt{rhs}: Both should always allow the exact same types. And on top of that it is not possible to nest expressions, because \texttt{lang.expBin} is not an allowed child for either of the sides.

In a typical grammar we would introduce a new node type like \texttt{lang.expAny} which would consist of a single child group that lists all permitted values. Listing~\ref{lst:grammar-expr-expBin-choiceNode} shows the relevant excerpt of the grammar and figure~\ref{fig:ast-choice-node} demonstrates how a valid tree for this grammar could look like: The immediate children of \texttt{lang.expBin} are no longer the actual nodes with semantic meaning, but the artifical choice nodes of type \texttt{lang.expAny}.

\begin{listing}[H]
\begin{minted}[]{typescript}
grammar "lang" {
  // node null and expVar as before

  node "expAny" {
    children "exp" ::= expBin | expNull | expVar
  }

  node "expBin" {
    children "lhs" ::= expAny
    prop     "op"  string
    children "rhs" ::= expAny
  }
}
\end{minted}
\caption{Grammar for expression \texttt{expBin} with choice node}
\label{lst:grammar-expr-expBin-choiceNode}
\end{listing}

\begin{figure}
  \includegraphics[scale=\astScale]{../manual/generated/ast-example-expr-binary-artificial}
  \caption{Expression tree with artificial choice nodes}
  \label{fig:ast-choice-node}
\end{figure}

The tree for such a grammar would however contain nodes of type \texttt{expAny} that do not have any kind of possible representation for the end user: As there is no possible textual representation for such a node, it would appear as a completely empty block that can only host another block. The examples syntax trees in  figure~\ref{fig:ast-choice-node} and listing~\ref{lst:ast-expr-binary} would both be compiled to the exact same textual representation \texttt{numRattles == null}.

To avoid these nodes without visual or textual representation any kind of recurring choice between multiple node types is treated differently from the conventional approach in these grammars: By introducing a pure virtual node type that is referrable by name in the grammar, but may never appear in an actual syntax tree. The textual grammar representation uses the keyword \texttt{typedef} to introduce such a type, the following listing~\ref{lst:grammar-expr-expBin-typedef} changes the definition of \texttt{nodeAny} to be such a virtual node and shows the final grammar for the semantics of simple expressions in entirety. The previous definition of \texttt{expBin} (as in listing~\ref{lst:grammar-expr-expBin-choiceNode} is unaffected by this change, altough the trees that are validated by the grammars are different. This updated grammar that uses the \texttt{typedef} approach will successfully validate the example binary expression from listing~\ref{lst:ast-expr-binary}.

In addition to the use of \texttt{typedef} the final structural grammar in listing~\ref{lst:grammar-expr-expBin-typedef} now contains a type \texttt{lang.expConst} to express constant, numeric values. And the previously unrestricted \texttt{string} for the \texttt{op} property to the values \texttt{==}, \texttt{+} and \texttt{*} by using an enumeration.

\begin{listing}[H]
\begin{minted}[]{typescript}
grammar "lang" {
  node "null" {
  }

  node "expVar" {
    prop "name" { string }
  }

  node "expConst" {
    prop "value" { number }
  }

  typedef "expAny" ::= expBin | expNull
                         | expVar | expConst

  node "expBin" {
    children "lhs" ::= expAny
    prop     "op"  string enum { == + * }
    children "rhs" ::= expAny
  }
}
\end{minted}

\caption{Final semantic grammar for expressions}
\label{lst:grammar-expr-expBin-typedef}
\end{listing}

\subsection{Example: Expression Syntax}

Although the syntax trees that are validated by the final semantic grammar for the expression language (listing~\ref{lst:grammar-expr-expBin-typedef}) are unambiguous in tree form, their default textual representation is possibly not. Figure~\ref{fig:ast-nested-ambiguous} shows a tree that in a depth first evaluation would effectively calculate $A+B$ first and then multiply the result with $2$. Or in textual form: The intended order of operation is $2 * (A+B)$. The textual form however would evaluate to $2 * A + B$.

\begin{figure}
  \includegraphics[scale=\astScale]{../manual/generated/ast-example-expr-binary-nested}
  \caption{Expression with addition before multiplication}
  \label{fig:ast-nested-ambiguous}
\end{figure}

This demonstrates, that even for the simple expression language we require some basic form of extra terminal symbols, namely the parenthesis in the textual representation. Without such additional syntax the structural information that is part of the tree can't be represented in the textual representation. For this basic example we can mix the semantic structural definition with the syntactic information about terminal symbols in the same grammar by simply adding the parentheses in double quotation marks (listing \ref{lst:grammar-expr-expBin-syntax}). On top of that the \texttt{lang.expNull} node had absolutly no textual representation so far.

These terminal symbols are absolutly irrelevant for the validation process: As the syntax tree never contains any terminal symbols, they can't be validated. But the generated block language and the pretty printer will incorporate these tokens when generating the output. Therefore the grammar that includes the terminal symbol will compile the tree in figure~\ref{fig:ast-nested-ambiguous} to $(2 * (A + B))$.

For conventional programming languages, these terminal symbols are not only used for parentheses but also for keywords (\texttt{if}, \texttt{for}, \texttt{while}, \texttt{SELECT}, \texttt{FROM} ...) and other syntactic information like semicolons, commas, ...

\begin{listing}[H]
\begin{minted}[]{typescript}
grammar "lang" {
  // expAny, expConst and expVar as before

  node "expNull" {
    "null"
  }

  node "expBin" {
    "("
    children "lhs" ::= expAny
    prop     "op"  { string }
    children "rhs" ::= expAny
    ")"
  }
}
\end{minted}
\caption{Final syntactic grammar for expression \texttt{expBin}}
\label{lst:grammar-expr-expBin-syntax}
\end{listing}

\section{Expression Block Language}

Block languages are a data structure that contain the relevant information on how to represent a syntax tree visually. Technically they are a \texttt{JSON}-document that contains instructions like \enquote{render a terminal symbol} or \enquote{render all sub-trees of a certain child group}.

Every block editor requires a source of block that is commonly called the sidebar. Whenever the user wants to add to the program at hand, he will search the sidebar for the block he desires and drag it to the central canvas.

\subsection{Builtin Editor}

The builtin editor draws a black border around each block and renders the terminal symbols and the properties of the tree as closely as possible to the textual representation, see figure~\ref{fig:screen-editor-expr-internal} for the rendered representation of the syntax tree in figure~\ref{fig:ast-nested-ambiguous}. The underlined operators \texttt{*} and \texttt{+} can be clicked to open a drop down to select possible operators from the enum.

\begin{figure}
  \includegraphics[width=0.45\textwidth]{screens/expr-blocks-internal}
  \caption{Builtin editor for expressions}
  \label{fig:screen-editor-expr-internal}
\end{figure}

\subsection{Blockly Editor}

Without any further hints, the blockly representation is readable, but not quite a friendly representation, see figure~\ref{fig:screen-editor-expr-blockly}. This is due to a conceptual mismatch: The proposed grammar defines number of elements in child group on parent. In Blockly each block defines whether follow-up is allowed or not. So without any further information, the blockly representation assumes each child group to host a possibly infinite amount of sub-trees. This is rather unfortunate in the two strictly single node children of \texttt{lang.expBin}.

\begin{figure}
  \includegraphics[width=0.45\textwidth]{screens/expr-blocks-blockly}
  \caption{Blockly editor for expressions}
  \label{fig:screen-editor-expr-blockly}
\end{figure}

\subsection{Textual Representation}

In the intended usage scenario, the textual representation of a syntax tree can be immediately be derived from the syntactic information in the grammar.

Backend \#3: Some Listings

\subsection{Self Hosting (Meta Grammar)}

The syntax that has been used so far to describe the grammars is a textual representation of the grammar editor that is available within Blatt\-Werkzeug. Every one of these grammars could have also been shown in the form of a screenshot of the block editor to edit that grammar. Technically grammars and block languages are, like the syntax tree, described as \texttt{JSON}-documents. In order to create grammars for new programming languages from inside the tool itself, it is therefore only required to transform some syntax tree to a valid \texttt{JSON} grammar document. The grammar and block language to describe the actual block language and grammar are called \enquote{Meta Grammar} and \enquote{Meta Block Language}. Figure~\ref{fig:screen-editor-expr-grammar} shows how the grammar for the expression language looks like in the builtin editor. As the \texttt{JSON} grammar has almost no syntactic overlap with the textual representation, the compilation step for the meta grammar involves custom code generators.

\begin{figure}
  \includegraphics[width=0.45\textwidth]{screens/expr-blocks-grammar}
  \caption{Rendered grammar for expressions}
  \label{fig:screen-editor-expr-grammar}
\end{figure}



\subsection{Fallback Representation}

When confronted with defect block language definitions, the block editor can resort to a fallback that is generated on the fly based on the grammar. This representation is a mixture of \texttt{JSON} and grammar notation which should be immediatly obvious to people that are familiar with the syntax tree representation. It uses the terms \enquote{node}, \enquote{prop} and \enquote{children} to visualize the data in the tree. Figure~\ref{fig:screen-editor-expr-fallback} shows the fallback representation of the four nodes of the example syntax tree that has been visualized in the two previous screenshots of the editor.

As this representation is technically a normal blockl language, it is also fully editable. Everything that is underlined may be clicked and changed. The blocks also may be dragged and new blocks can be added from the sidebar.

\begin{figure}
  \includegraphics[width=0.3\textwidth]{screens/expr-blocks-fallback}
  \caption{Internal fallback representation for expressions}
  \label{fig:screen-editor-expr-fallback}
\end{figure}

\subsection{CSS Styling}

\section{Programming Language Runtimes}

So far we have discussed how grammars can be used to validate the structure of a syntax tree, to derive a visual editor that can change the structure of the syntax tree and how to derive a textual representation of the syntax tree. But to have an actually complete example for a real world programming language the actual possibility to run the code is still missing. Providing this kind of runtime for the textual representation of the syntax trees is however always a manual task. In the current state of Blatt\-Werkzeug the following runtimes are provided:

\begin{itemize}
\item \texttt{SQL} as understood by SQLite. The required database is stored on the server, the frontend sends the desired syntax tree to be executed.

\item \texttt{JavaScript} executed in a WebWorker, so without any access to the \texttt{DOM} and without blocking the browsers only \texttt{JavaScript} context. Basic output via \texttt{console.log} is redirect to a section under the programs block editor.

\item \texttt{Trucklino} is a domain specific language implemented as a bachelors thesis \cite{popp_konzeption_2019} which can be seen as a variation of the Kara approach\cite{hartmann_kara_2001} about a ladybug (or in Trucklino: a truck) that needs to solve programming puzzles.

\item \texttt{JSON} and \texttt{XML} purely as data structures without any immediate application or accompanied schema.

\item Mathematical equations and transformations backed by the symbolic math library Nerdamer\footnote{\url{https://nerdamer.com/}}.

\item A subset of the GraphViz language to render graphs\footnote{\url{https://graphviz.org/}}.
\end{itemize}

Each of these runtimes operate on the assumption that there is a grammar (or in the case of Trucklino: a code generator) to compile a textual representation from any valid syntax tree. The textual representation is then used as the input for the runtime. As shown by the very diverse modes of operations on these few examples (tabular output, console output, graphical output, client side calculation, server side calculation), there is no really unified strategy available to provide a generic approach to such runtimes. Therefore all of these runtimes are custom built with TypeScript, Angular and possibly Ruby.

\section{Example: \texttt{XML} and whitespace handling}

Representing a \texttt{XML} structure consisting of any elements, attributes and child elements is very straightforward with the presented syntax trees and grammars. \enquote{Any} in this case refers to the absence of a schema, that the \texttt{XML} document must conform to. On a fundamental level it only requires a type \texttt{xml.element} which may host any number of \texttt{xml.attribute} (key-value pairs) and any number of \texttt{xml.element} as children (see listing~\ref{lst:grammar-xml-structure}). Allowing free-form text as children of \texttt{XML} elements can be done through another node type \texttt{xml.text} which only requires a single property.

In contrast to the grammar for the expression language, the child groups \texttt{elements} and \texttt{attributes} on \texttt{xml.element} make use of the \texttt{*} operator with the usual meaning of \enquote{any number of items, including none}. This example also shows, that it is possible to have more than one type reference in a child group definition. The \texttt{\&}-operator is borrowed from RELAX NG where it is called the \enquote{interleaving}-operator. It allows children to occur independent of their order, but still respects their cardinality. Without the use of this operator, the resulting grammar would require that any \texttt{xml.element} must occur strictly before any \texttt{xml.text}. For these block grammars the use of such interleaving child groups is the norm: sequences are technically possible but typically replaced by multiple named child groups.

\begin{listing}[H]
\begin{minted}[]{typescript}
grammar "xml" {
  node "element" {
    prop "name"           string
    children "elements"   ::= element* & text*
    children "attributes" ::= attribute*
  }
  node "attribute" {
    prop "name"  string
    prop "value" string
  }
  node "text" {
    prop "value" string
  }
}
\end{minted}
\caption{Semantic structure of \texttt{XML}}
\label{lst:grammar-xml-structure}
\end{listing}

To properly visually represent \texttt{XML} however, this structural information is not enough. To have a syntactically valid \texttt{XML}-document at least the syntactic pairs of brackets (\texttt{<element>}) and the attributes equality sign and the quoted value (\texttt{key="value"}) need to be specified. The result of this minimal amount of terminal symbols would however be one very long line of \texttt{XML}. This is syntactically valid, but unpleasant to work with in a block editor. In order to follow the more typical formatting of having indented child elements and the opening and closing \texttt{XML}-elements on distinct lines, we need to specify a formatting structure that includes linebreaks in the grammar.

Listing~\ref{lst:grammar-xml-syntax} shows a visualization grammar for the previously presented structural grammar. The keyword \texttt{visualize} is used here to indicate that the information for the specified type are not changing the structural semantics of a grammar: Inside a \texttt{visualize} block no \texttt{children} or \texttt{property} statements may be used. Instead it is possible to implicitly define line breaks using the \texttt{container} block. If the orientation is set to \texttt{horizontal}, the block editors and textual representation will not allow any implicit line breaks between these elements. The \texttt{vertical} orientation introduces a line break between all immediate children of the \texttt{container}. The \texttt{\{\{ property \}\}} syntax (borrowed from frameworks like Angular or Jinja) is used for interpolation: The value of the property on the node in the syntax tree will be used as the value when rendered. The same listing also demonstrates how certain common visualization aspects are expressed using special annotations. Everything that is denoted inside a pair of parentheses is treated as a special instruction to the block- and the code-generator.

\begin{listing}[H]
\begin{minted}[]{typescript}
grammar "xml" {
  visualize "attribute" {
    container horizontal {
      {{name}} ("space-before" "keyword")
      "="
      {{value}} ("double-quote")
    }
  }

  visualize "element" {
    container vertical {
      container horizontal {
        "<"
        {{name}} ("keyword")
        {{#each attributes}}
        ">"
      }
      container vertical (indent) {
        {{#each elements}}
      }
      container horizontal {
        "</"
        {{name}} ("keyword")
        ">"
      }
    }
  }
}
\end{minted}
\caption{Syntactic structure of \texttt{XML}}
\label{lst:grammar-xml-syntax}
\end{listing}

\begin{itemize}
\item The \texttt{space-before} instruction for \texttt{xml.attribute.name} ensures that there is a space between the \texttt{xml.element.name} and multiple attributes. In this particular instance it could also have been encoded as a literal space terminal symbol \texttt{'~'}, but the generators are able to e.g. combine multiple superflous spaces so expressing this via the \texttt{space-before} instruction is preferred for composeability.
\item The \texttt{keyword} instruction is used for very basic syntax highlighting in the block editor and disregarded when generating the textual representation.
\item The \texttt{double-quote} instruction places double quote terminal symbols around the terminal symbol or property it is defined on. Technically this could also be represented through a pair of literal terminal symbols. But having a single instruction that can not be torn apart when things are moved around can be very convenient.
\end{itemize}

With this additional syntactic information about terminal symbols, linebreaks and quotation marks can't be represented in the block editor or the textual representation. The resulting \texttt{XML} block editor now renders a \texttt{HTML}-like structure as shown in figure~\ref{fig:screen-editor-xml-no-border}. To demonstrate how close the resemblance can be, the tree has been rendered twice. Without block outlines the result almost looks like a \enquote{normal} textual representation. Only the activated property editor on the text \enquote{Really great!} gives a hint that some kind of structural editing is available.

\begin{figure}
  \includegraphics[width=0.2\textwidth]{screens/xml-blocks-html-with-border}
  \includegraphics[width=0.2\textwidth]{screens/xml-blocks-html-no-border}
  \caption{A \texttt{HTML} like structure in the \texttt{XML}-block editor, rendered with and without block outlines.}
  \label{fig:screen-editor-xml-no-border}
\end{figure}

\section{Example: \texttt{HTML} and child ordering}

When going from the representation of any schema-free \texttt{XML}-document to \texttt{HTML} the syntax stays almost the same, but the structural requirements change drastically.

Reduction of possible DOM values without sacrificing the semenatic structure.

\subsection{Order Of Children}

Most \texttt{HTML} elements can appear in any order.

\section{Example: SQL}

\subsection{Validation}

Only columns mentioned in the \texttt{FROM} clause may be used in the other clauses.

\section{Example: JavaScript}

\subsection{Problem: Virtual Root}

\subsection{Runtime}

\section{Conclusion}

\printbibliography

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-command-extra-options: "-shell-escape"
%%% TeX-engine: xetex
%%% TeX-master: t
%%% End: