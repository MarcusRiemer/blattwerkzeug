\documentclass[sigconf,natbib=false,review=true,anonymous]{acmart}

\usepackage[
datamodel=acmdatamodel,
backend=biber,
natbib=false,
sorting=none,
style=acmnumeric, % use style=acmauthoryear for publications that require it
]{biblatex}

\addbibresource{CSERC22.bib}

%\usepackage[style=ACM-Reference-Format,backend=bibtex,sorting=none]{biblatex}
%\addbibresource{CSERC22.bib}

\usepackage{minted}    % Source code formatting
\usepackage{csquotes}  % Eases working with quotes
\usepackage[author={Marcus}]{pdfcomment}

% Hack to avoid red boxes around characters in listings
% https://tex.stackexchange.com/questions/343494/
\makeatletter
\AtBeginEnvironment{minted}{\dontdofcolorbox}
\def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
\makeatother

% Create a new environment for breaking code listings across pages.
% https://tex.stackexchange.com/questions/368864/
\newenvironment{longlisting}{\captionsetup{type=listing} \vspace{1.5em}}{\vspace{1.5em}}

% "Constant" to set the scaling of all ASTs at once
\newcommand\astScale{0.7}
\newcommand\todo[1]{{\bfseries ToDo: #1}}
\begin{document}

\title[]{Generating syntaxfree development environments for real world programming languages}

\author{Marcus Riemer}
\affiliation{%
  \institution{Christian-Albrechts-Universität}
  \city{Kiel}
  \country{Germany}
}
\email{post@marcusriemer.de}

\author{Frank Huch}
\affiliation{%
  \institution{Christian-Albrechts-Universität}
  \city{Kiel}
  \country{Germany}
}
\email{fhu@informatik.uni-kiel.de}

\keywords{computer science education, language specification, block editor}

\begin{abstract}
  The prevailing concept when teaching computer science to beginners in school is visual programming, typically in the form of block based languages. Most approaches in this area involve special teaching languages like Scratch. Our approach seamlessly connects the block based language concept to conventional programming languages used in computer science, but for didactical purpose often to a core subset of such a language.

  Generating a block editor for a language is large effort and often done for every language individually. To tackle this, we developed a generalized framework which supports the development of visual editors for arbitrary formal languages. It is based on a grammar describing the formal language and compiles it to a block based editor interface which uses either our own visual representation or Blockly.

  Beside presenting the approach through a series of examples, we also sketch applications of the approach for the languages XML, HTML, SQL and JavaScript. Apart from getting a visual editor, our implementation also allows the connection to a backend in the full conventional language, which completes the editor with the common semantics of the language, so that the language can also be executed in the context for which it was developed.
\end{abstract}

\begin{teaserfigure}
  \centering\includegraphics[width=\textwidth]{screens/js-runtime-trucklino.png}
  \caption{Builtin block editor with puzzle solving runtime that resembles the syntax of the augmented JavaScript}
  \label{fig:js-runtime-trucklino}
\end{teaserfigure}

\maketitle

\section{Introduction}

Computer science introduction often uses syntaxfree drag-and-drop programming languages to ease the first steps when learning how to program. This approach has the benefit of entirely eliminating the possibility of confronting learners with syntax errors. But the actual languages that are being taught this way are not relevant in the programming industry. For educators, this is an inconvenient situation: Block languages are proven to be great tools to spark interest in programming. But making the step from block languages to conventional programming languages is still difficult. Additionally, some students view these environments as overly restrictive and \enquote{not real programming}\cite{braune_learning_2020}.

One important aspect is to explicitly plan the transition from block based languages to text based languages. In \cite{fraser_ten_2015} this is called the \enquote{exit strategy} and \cite{alrubaye_comparison_2019} shows promising results when confronting students with block and textual programming simultaneously. The approach of \enquote{frame based editing} proposed by \cite{kolling_frame-based_2015} is another proposal to overcome this gap: Certain structural parts of the source code are draggable, some are read only and certain parts within this structure are textually editable.

This paper follows these ideas and presents an approach to rapidly generate block language variations of conventional programming languages based on a grammar representation. Instead of hiding syntax details like parentheses, semicolons, commas, ... these are organically made part of the grammar and the resulting blocks. Therefore learners are continously confronted with the syntax details of their language of choice without having to actually type it. Additionally the resulting program is not meant to be run only in some learning environment. On a technical level the program can be compiled to proper source code in the target language and could be run in a \enquote{real} environment outside of the learning context.

As a block language grammar augments an existing programming language, there is no need for a block language designer to define the semantics of the language he is describing in the grammar. If an educator requires a special variation of e.g. \texttt{SQL} that is limited to \texttt{SELECT}, \texttt{FROM} and \texttt{GROUP BY} or a subset of \texttt{JavaScript} that doesn't allow mutable variables, we want to put him into the position of being able to create his or her variation.

To show that the general grammar based approach as well as our specific implementation is not overly specifically tied to our own block editor, we also generate Blockly documents and editors\footnote{\url{https://developers.google.com/blockly}} as well as pretty printable syntax trees for the industry standard \texttt{prettier} program\footnote{\url{https://prettier.io/}}. Apart from the benefit of having multiple backends to avoid overly specific details in what should be a general solution, Blockly and prettier are established tools that work reliable under almost any circumstances and by contrasting their results to our own we found quite a few flaws in our implementation during development.

% \todo{Hier kommt in der Regel noch ein "The paper is organized as follows: in Section~2 we give an overview of the architecture of our system.... Kannst du aber ggf. auch weglassen, wenn andere Papiere der Konferenz das auch nicht haben.}
\section{Architecture Overview}

%At the core our approach is about representing the same syntax tree in two different ways:
At the core our approach represents one syntax description in two different ways: Either as a block editor that can be used to edit the syntax tree. Or as a valid textual representation in the augmented programming language. Both of these representations and the validation are derived from a single source: a grammar. Apart from checking whether a certain syntax tree has the correct structure, the grammar provides syntactic details like keywords, brackets and indentation.

Our approach re-defines and re-implements the common set of core data structures for compilers: syntax\-trees, grammars \& validators. The main reason for this re-invention of the wheel is the differing focus of existing software: the syntaxtrees of conventional compilers (like \texttt{gcc}, \texttt{llvm}, \texttt{javac}, …) are focused on speed and correctness, and not a friendly representation for drag \& drop mutations. Our approach instead focuses exclusively on working with a syntaxtree that lends itself well to being directly presented to the end user. Most importantly, for a proper block editor there must not be any node that has no visual or textual representation. As these kind of intermediate nodes are not an issue for traditional compiler construction, there is a fundamental mismatch in the structure of these representations. On top of that typical compiler tasks that have to do with lexical analysis or parsing (\texttt{yacc}, \texttt{bison}, \texttt{ANTLR}, \texttt{boost::spirit}) are not relevant for our approach. The other self-evident candidate to build upon, namely Google Blockly, uses a syntax tree representation that includes many positional details that are not of relevance for our approach and mixes the block definitions (the \enquote{grammar}) with JavaScript and details of code generation.

On a fundamental technical level our implementation is split into a browser-frontend and a \texttt{HTTP}-backend, communication between these layers works via GraphQL. The backend is a Ruby on Rails application that uses PostgreSQL as a database, the frontend is written in TypeScript and uses Angular.

\section{Abstract Syntax Tree}
\label{sec:abstract-syntax-tree}

The abstract syntax tree (AST) itself is purely a \texttt{JSON} data structure that follows the TypeScript definition in Listing~\ref{lst:typescript-ast} and has no concept of being \textit{valid} or \textit{invalid} on its own. Validations are based on grammars which are described from Section~\ref{sec:expression-grammar} onwards. The tree also has no concept on how it should be represented in either its block form, this is the task of block languages, or textual representation, this is the task of code generators which are usually generated from the grammar.

\begin{listing}[H]
\begin{minted}{typescript}
export interface NodeDescription {
  name: string
  language: string
  children?: {
    [childrenCategory: string]: NodeDescription[];
  }
  properties?: {
    [propertyName: string]: string;
  }
}
\end{minted}
\caption{TypeScript definition of AST}
\label{lst:typescript-ast}
\end{listing}

A single node in the syntaxtree always has at least a \texttt{type} that consists of two strings: A local \texttt{name} and a \texttt{language}. This type is the premier way for different tools to decide how the node in question should be treated. The language is essentially a namespace that allows the use of identical names in different contexts. This is useful when describing identical concepts like imperative loops or semantic markup for \enquote{heading} in different languages.

Nodes may define so called \texttt{properties} which hold atomic values in the form of texts or integers, but never in the form of child nodes. Each of these properties needs to have a name that is unique in the scope of the current node.

The \texttt{children} of nodes have to be organized in so called \enquote{child groups}. Each of these groups has a name and contains any number of sub-trees in order. Naming the child groups enables the grammars to specify complex sub-trees without relying on the ordering of these nodes. The resulting structure has a strong resemblance to an \texttt{XML} tree, but instead of grouping all children in one of exactly two named scopes (elements and attributes), they are organised into any number of named sub-trees.

The examples presented in the sections~\ref{sec:ast-example-if} and \ref{sec:ast-example-expr} demonstrate how common programming language concepts like expressions and an \texttt{if} statement could be represented using this specific syntax tree structure with named child groups. The corresponding grammars to validate syntax trees and to generate the corresponding block editors will be introduced from section~\ref{sec:expression-grammar} onward.

\subsection{AST Example: Binary Expression}
\label{sec:ast-example-expr}
The tree in Listing~\ref{lst:ast-expr-binary} is shown in two equivalent representations: the \texttt{JSON} data structure conforming to Listing~\ref{lst:typescript-ast} and as graphical tree in Figure~\ref{fig:ast-expr-binary}. It is a possible representation of the expression \texttt{numRattles == null} as it is commonly found in many languages. It consists of three nodes: The root node is of type \texttt{lang.expBin}, the dot (\enquote{\texttt{.}}) is used as a separator between the \texttt{language} and the \texttt{name} of a node. The childgroup with the name \texttt{lhs} (\enquote{left hand side}) contains a node of type \texttt{lang.expVar} which is meant to refer to an existing variable on the left hand side of the expression. The property \texttt{name} is set to \texttt{numRattles}.

\begin{listing}[H]
\begin{minted}{typescript}
{
  "language": "lang",
  "name": "expBin",
  "properties": { "op": "eq" },
  "children": {
    "lhs": [
      {
        "language": "lang",
        "name": "expVar",
        "properties": { "name": "numRattles" }
      }
    ],
    "rhs": [
      { "language": "lang", "name": "null" }
    ]
  }
}
\end{minted}
\caption{AST for expression \texttt{numRattles == null}}
\label{lst:ast-expr-binary}
\end{listing}

\begin{figure}
  \includegraphics[scale=\astScale]{../manual/generated/ast-example-expr-binary}
  \caption{Graphical representation of tree in Listing~\ref{lst:ast-expr-binary}}
  \label{fig:ast-expr-binary}
\end{figure}


\subsection{AST Example: \texttt{if}-Statement}
\label{sec:ast-example-if}

\begin{figure*}
  \includegraphics[scale=\astScale]{../manual/generated/ast-example-if}
  \caption{\texttt{if}-Statement with predicate}
  \label{fig:if-stmt-pred}
\end{figure*}

The following example provides further reasons for named child groups and shows how the non-existant parsing-step can be used for more precise error messages.

An \texttt{if} statement can be described in terms of its structure and the underlying semantics: It uses a predicate to distinguish whether execution should continue on a positive branch or a negative branch. Details about the name of the keyword itself (probably \texttt{if}, maybe a \texttt{then}, maybe with parentheses around the predicate?) or the syntax of blocks (\texttt{\{\}}, \texttt{begin} ... \texttt{end}, indentation, ..?) are irrelevant for the semantics.


Listing~\ref{lst:if-stmt-pred} shows two sample programs: One with a correct \texttt{if}-Statement that uses a \texttt{then} is shown on the left. And one program with an incorrect \texttt{if}-Statement that accidentaly omits the \texttt{then} and the correspdonding expression is shown on the right. The correspdonding syntaxtree for the correct variation is shown in Figure~\ref{fig:if-stmt-pred}. The expression \texttt{a > b} is in the \texttt{pred} child group, the call to \texttt{writeln} is in the \texttt{positive} child group and the call to \texttt{err} is in the \texttt{negative} child group. From the perspective of the syntaxtree, each of these child groups has a distinct meaning that is also conveyed as part of the name. Even without hand-crafted error messages an error like \enquote{\enquote{lang.if} has empty childgroup \enquote{predicate}} would quite nicely convey the problem with a missing expression for the predicate. Without named childgroups, e.g. in an \texttt{XML} like tree structure, the semantics of the sub trees would be defined by the order they appear and a name would not by available.

\begin{listing}[H]
\begin{minipage}{.20\textwidth}
\begin{minted}{pascal}
if (a > b) then
  writeln('foo')
else
  err(2, 'bar')
\end{minted}
\end{minipage}
\begin{minipage}{.20\textwidth}
\begin{minted}{pascal}
if
  writeln('foo')
else
  err(2, 'bar')
\end{minted}
\end{minipage}
\caption{\texttt{if}-Statement with and without predicate}
\label{lst:if-stmt-pred}
\end{listing}

But the actual benefit of only working with syntax trees and not requiring a parsing step goes deeper than having nicer error messages for free. The incorrect \texttt{if}-statement that omits the expression and the \texttt{then} in Listing~\ref{lst:if-stmt-pred} uses indentation to convey the intent of the author: The \texttt{writeln} statement is offset in the same way as the \texttt{err} statement. But a parser that stumbles over this code would, at least without extra logic, be mislead by the \texttt{writeln} statement reading exactly like an expression. The most probable error message would read something along the lines of \enquote{Invalid predicate: expression writeln('foo') is not of type boolean} and \enquote{Missing keyword then}. In contrast the syntax tree can't make such a miss-attribution by accident because it relies on named child groups, not on the order of the sub-trees.

\section{Expression Grammar}
\label{sec:expression-grammar}

Syntaxtrees can have arbitrary tree structures, but for practical reasons only trees conforming to a certain set of known properties and children are of relevance. We therefore say that a certain tree may be \enquote{valid} in the context of a certain grammar. The example in Listing~\ref{lst:ast-expr-binary} implicitly relied on a few limitations:

\begin{enumerate}
\item \label{itm:lang-exp-null} \texttt{lang.null} never has children or properties.

\item \label{itm:lang-exp-var} \texttt{lang.expVar} never has children, but it must have a property called \texttt{name} which denotes the name of the variable the expression refers to.

\item \label{itm:lang-exp-bin} \texttt{lang.expBin} has two child groups named \texttt{lhs} and \texttt{rhs} which stand for the two sides of the equation. These child groups may themselves contain a single \texttt{null}, \texttt{expVar} or \texttt{expBin}. The property \texttt{op} will treat the value \texttt{eq} as meaning \enquote{equality} and possibly allows other values such as \texttt{leq} or \texttt{gt}.
\end{enumerate}

Imposing such structural requirements by restricting the allowed or required properties and child groups is done with a grammar. The underlying validation concept is losely based on \texttt{XML} Schema and RelaxNG, the syntax of the latter is also used as the inspiration to describe the grammars in a user friendly textual representation.

In contrast to grammars in general compiler construction, the grammar described here is not meant to create a syntax tree from some stream of tokens but rather begins with an empty syntax tree. This frees it from many of the problems that have been mentioned above:

\begin{enumerate}
\item There is no whitespace and seperation characters are never required. What matters is only the structure of the tree: the type of the node in question determines which properties and child groups exist and what values are permitted.
\item Most errors equate to missing nodes and can be communicated very clearly. Semantic analysis does not need to rely on heuristics on how the tree could change if the \enquote{blanks} were filled in.
\end{enumerate}

In comparision to traditional grammars, this shifts the way one has to reason about the validation when following our approach: There is no need to worry about the syntactic aspects of a certain language, the grammar that is required doesn’t need to know anything about keywords or separating characters. Its sole job is to describe the structure and the semantics of trees that are valid in that specific language. If keywords are included in the grammar, this is solemly for the purpose of blocks that resemble the underlying programming language or for code generation. The actual grammar validation does not use these keywords at all.

\subsection{Expression Structure}
% \todo{Das gefällt mir irgendwie viel besser, als die vorherigen Kapitel. Hier ist klar, was du machen willst. Schöner wäre es aus meiner Sicht, wenn man das von oben in dieses Kapitel integriert und dann hier diese Aspekte anspricht. Dein Naming beim if-then-else und die Fehlersahce würde hier doch auch gut eingebaut werden können.}

In this example we will step by step construct a grammar to validate structures like the expression in Listing~\ref{lst:ast-expr-binary}. The grammar in Listing~\ref{lst:grammar-expr-null} defines a language named \texttt{lang} which allows a single node with the name \texttt{null} to be present in the syntax tree. This node may not have any children or properties, so the only valid syntaxtree would consist of a single node.

\begin{listing}[H]
\begin{minted}{typescript}
grammar "lang" {
  node "null" { }
}
\end{minted}
\caption{Grammar for expression \texttt{null}}
\label{lst:grammar-expr-null}
\end{listing}

In order to also allow references to variables, we add a second valid type of node called \texttt{expVar} (Listing~\ref{lst:grammar-expr-expVar}). For this type of node the property \texttt{name} must be present, but at this moment we do not make any restriction on what this name could look like. To avoid syntax errors in practical usage, names may not contain any syntax elements. In this context this means mathematical operators or brackets shouldn't be allowed. For actual usage the valid value therefore should be restricted using enumerations or regular expressions, but for the sake of brevity we will not deal with this in every example.

\begin{listing}[H]
\begin{minted}[]{typescript}
// node null as before
grammar "lang" {
  node "expVar" { prop "name" string }
}
\end{minted}
\caption{Grammar for expression \texttt{expVar}}
\label{lst:grammar-expr-expVar}
\end{listing}

With the types \texttt{lang.null} and \texttt{lang.expVar} defined, we now have two leaf nodes for our expression language. In order for a type to act as a parent, as \texttt{lang.expBin} must, we need to define the names and the valid types for the child groups. Listing~\ref{lst:grammar-expr-expBin-verbose} declares such a type that defines the child groups \texttt{lhs} and \texttt{rhs} to either take a \texttt{expNull} or an \texttt{expVar}. With this grammar we may now generate checks for expressions like \texttt{a + 1}, \texttt{a >= PI} or \texttt{a == null}.

\begin{listing}[H]
\begin{minted}[]{typescript}
// node null and expVar as before
grammar "lang" {
  node "expBin" {
    children "lhs" ::= expNull | expVar
    prop     "op"  string
    children "rhs" ::= expNull | expVar
  }
}
\end{minted}
\caption{Grammar for expression \texttt{expBin}}
\label{lst:grammar-expr-expBin-verbose}
\end{listing}

Unfortunately there is already some duplication in the definitions of the child groups \texttt{lhs} and \texttt{rhs}: Both should always allow the exact same types. And on top of that it is not possible to nest expressions, because \texttt{lang.expBin} is not an allowed child for either of the sides.

In a typical grammar we would introduce a new node type like \texttt{lang.expAny} which would consist of a single child group that lists all permitted values. Listing~\ref{lst:grammar-expr-expBin-choiceNode} shows the relevant excerpt of the grammar and Figure~\ref{fig:ast-choice-node} demonstrates how a valid tree for this grammar could look like: The immediate children of \texttt{lang.expBin} are no longer the actual nodes with semantic meaning, but the artifical choice nodes of type \texttt{lang.expAny}.

\begin{listing}[H]
\begin{minted}[highlightlines={3-5,7,9}]{typescript}
// node null and expVar as before
grammar "lang" {
  node "expAny" {
    children "exp" ::= expBin | expNull | expVar
  }
  node "expBin" {
    children "lhs" ::= expAny
    prop     "op"  string
    children "rhs" ::= expAny
  }
}
\end{minted}
\caption{Grammar for expression \texttt{expBin} with choice node}
\label{lst:grammar-expr-expBin-choiceNode}
\end{listing}

\begin{figure}
  \includegraphics[scale=\astScale]{../manual/generated/ast-example-expr-binary-artificial}
  \caption{Expression tree with artificial choice nodes}
  \label{fig:ast-choice-node}
\end{figure}

The tree for such a grammar would however contain nodes of type \texttt{expAny} that do not have any kind of possible representation for the end user: As there is no possible textual representation for such a node, it would appear as a completely empty block that can only host another block. The examples syntax trees in Figure~\ref{fig:ast-choice-node} and Figure~\ref{fig:ast-expr-binary} would both be compiled to the exact same textual representation \texttt{numRattles == null}.

To avoid these nodes without visual or textual representation any kind of recurring choice between multiple node types is treated differently from the conventional approach in these grammars: We introduce a pure virtual node type that is referrable by name in the grammar, but may never appear in an actual syntax tree. The textual grammar representation uses the keyword \texttt{typedef} to introduce such a type and it is effectively only used to allow a set of permitted types for a single type. The following Listing~\ref{lst:grammar-expr-expBin-typedef} changes the definition of \texttt{nodeAny} to be such a virtual node and shows the final grammar for the semantics of simple expressions in entirety. The previous definition of \texttt{expBin} (as in Listing~\ref{lst:grammar-expr-expBin-choiceNode}) is unaffected by this change, altough the trees that are validated by the grammars are different. This updated grammar that uses the \texttt{typedef} approach will successfully validate the example binary expression from Listing~\ref{lst:ast-expr-binary}.

In addition to the use of \texttt{typedef} the final structural grammar in Listing~\ref{lst:grammar-expr-expBin-typedef} now contains a type \texttt{lang.expConst} to express constant, numeric values. And the previously unrestricted \texttt{string} for the \texttt{op} property is now restricted to the values \texttt{==}, \texttt{+} and \texttt{*} by using an enumeration.

\begin{listing}
\begin{minted}[highlightlines={5-8,11}]{typescript}
grammar "lang" {
  node "null"     { }
  node "expVar"   { prop "name"  { string } }
  node "expConst" { prop "value" { number } }
  typedef "expAny" ::= expBin
                       | expNull
                       | expVar
                       | expConst
  node "expBin" {
    children "lhs" ::= expAny
    prop     "op"  string enum { == + * }
    children "rhs" ::= expAny
  }
}
\end{minted}

\caption{Final structural grammar for expressions}
\label{lst:grammar-expr-expBin-typedef}
\end{listing}

\subsection{Example: Expression Syntax}

\begin{figure}
  \includegraphics[scale=\astScale]{../manual/generated/ast-example-expr-binary-nested}
  \caption{Expression with addition before multiplication}
  \label{fig:ast-nested-ambiguous}
\end{figure}

Although the syntax trees that are validated by the final semantic grammar for the expression language (Listing~\ref{lst:grammar-expr-expBin-typedef}) are unambiguous in tree form, their default textual representation is possibly not. Figure~\ref{fig:ast-nested-ambiguous} shows a tree that in a depth first evaluation would effectively calculate $A+B$ first and then multiply the result with $2$. Or in proper textual form: The intended order of operation is $2 * (A+B)$. The actual textual representation however would evaluate to $2 * A + B$.

This demonstrates, that even for the simple expression language we require some basic form of extra terminal symbols, namely the parenthesis in the textual representation. Without such additional syntax the structural information that is part of the tree can't be represented in the textual representation. For this basic example we can mix the semantic structural definition with the syntactic information about terminal symbols in the same grammar by simply adding the parentheses in double quotation marks (listing \ref{lst:grammar-expr-expBin-syntax}). On top of that the \texttt{lang.expNull} node had absolutly no textual representation so far and is now represented by the keyword \texttt{null}.

\begin{listing}[H]
\begin{minted}[highlightlines={3,5,9}]{typescript}
grammar "lang" {
  // expAny, expConst and expVar as before
  node "expNull" { "null" }
  node "expBin" {
    "("
    children "lhs" ::= expAny
    prop     "op"  { string }
    children "rhs" ::= expAny
    ")"
  }
}
\end{minted}
\caption{Final syntactic grammar for expression \texttt{expBin}}
\label{lst:grammar-expr-expBin-syntax}
\end{listing}

These terminal symbols are absolutly irrelevant for the validation process: As the syntax tree never contains any terminal symbols, they can't be validated. But the generated block language and the pretty printer will incorporate these tokens when generating the output. Therefore the grammar that includes the terminal symbol will compile the tree in Figure~\ref{fig:ast-nested-ambiguous} to $(2 * (A + B))$.

For conventional programming languages, these terminal symbols are not only used for parentheses but also for keywords (\texttt{if}, \texttt{for}, \texttt{while}, \texttt{SELECT}, \texttt{FROM} ...) and other syntactic information like semicolons, commas, ...

\section{Syntax Tree Representation}

The representation for both block editors (builtin and Blockly) is based on an intermediate description that contains the relevant information on how to represent a syntax tree visually. Technically they are a grammar derived description that contains instructions like \enquote{render a terminal symbol} or \enquote{render all sub-trees of a certain child group}.

Every block editor requires a source of blocks that is commonly called the \enquote{sidebar}. Whenever the user wants to add to the program at hand, he will search the sidebar for the block he requires and drag it to the central canvas. In the following examples the sidebar is automatically populated to provide one block for each type in the grammar, but it is possible to define custom block sidebars as e.g. seen in Figure~\ref{fig:js-runtime-trucklino}.

\subsection{Builtin Editor}

The builtin editor draws a border to visualize each type as a block and renders the terminal symbols and the properties of the tree as closely as possible to the textual representation, see Figure~\ref{fig:screen-editor-expr-internal} for the rendered representation of the syntax tree in Figure~\ref{fig:ast-nested-ambiguous}. The underlined operators \texttt{*} and \texttt{+} can be clicked to open a drop down to select possible operators from the enum.

\begin{figure}[H]
  \includegraphics[width=0.45\textwidth]{screens/expr-blocks-internal}
  \caption{Builtin editor for expressions}
  \label{fig:screen-editor-expr-internal}
\end{figure}

\subsection{Blockly Editor}

Without any further hints, the blockly representation is readable, but not quite a friendly representation, see Figure~\ref{fig:screen-editor-expr-blockly}. This is due to a conceptual mismatch: The proposed grammar defines number of elements in child group on parent. In Blockly each block defines whether follow-up is allowed or not. So without any further information, the blockly representation assumes each child group to host a possibly infinite amount of sub-trees. This is rather unfortunate in the two strictly single node children of \texttt{lang.expBin}, which require manual intervention.

\begin{figure}[H]
  \includegraphics[width=0.45\textwidth]{screens/expr-blocks-blockly}
  \caption{Blockly editor for expressions}
  \label{fig:screen-editor-expr-blockly}
\end{figure}

\subsection{Self Hosting (Meta Grammar)}

The syntax that has been used so far to describe the grammars is a textual representation of the grammar editor that is available within our implementation as a block editor. Every one of these grammars could have also been shown in the form of a screenshot of the block editor to edit that grammar. Technically grammars and block languages are, like the syntax tree, described as \texttt{JSON} documents. In order to create grammars for new programming languages from inside the tool itself, it is therefore only required to transform some syntax tree to a valid \texttt{JSON} grammar document. The grammar and block language to describe the actual block language and grammar are called \enquote{Meta Grammar} and \enquote{Meta Block Language}. Figure~\ref{fig:screen-editor-expr-grammar} shows how the grammar for the expression language looks like in the builtin editor. As the \texttt{JSON} grammar has almost no syntactic overlap with the textual representation, the compilation step for the meta grammar involves custom code generators.

\begin{figure}
  \includegraphics[width=0.45\textwidth]{screens/expr-blocks-grammar}
  \caption{Rendered grammar for expressions}
  \label{fig:screen-editor-expr-grammar}
\end{figure}

\subsection{Fallback Representation}

When confronted with defect block language definitions, the block editor can resort to a fallback that is generated on the fly based on the grammar. This representation is a mixture of \texttt{JSON} and grammar notation which should be immediatly obvious to people that are familiar with the syntax tree representation. It uses the terms \enquote{node}, \enquote{prop} and \enquote{children} to visualize the data in the tree. Figure~\ref{fig:screen-editor-expr-fallback} shows the fallback representation for a subset of the nodes of the example syntax tree that has been visualized in the two previous screenshots of the editor.

As this representation is technically a normal block language, it is also fully editable. Everything that is underlined may be clicked and changed. The blocks also may be dragged and new blocks can be added from the sidebar.

\begin{figure}
  \includegraphics[width=0.30\textwidth]{screens/expr-blocks-fallback}
  \caption{Internal fallback representation for expressions, the tree shown a is subset of Figure~\ref{fig:screen-editor-expr-internal}}
  \label{fig:screen-editor-expr-fallback}
\end{figure}

\subsection{Textual Representation}

With the syntactic information provided by the grammar, the textual representation of a syntax tree can immediately be derived. The grammar contains the structure of the textual representation and the syntax tree essentially fills the blanks that are left in the form of property values and children. Effectively the syntax tree dictates which type in the grammar should be looked up and provides the data requested by the lookup. The grammar information on how to represent a node (line breaks, terminal symbols, property values, children, ...) is filled with information from the syntaxtree, transformed into the primitives outlined in \cite{wadler_prettier_printer} and then fed to prettier to create a properly indented string representation.

\section{Language Runtime Environments}
So far we have discussed how grammars can be used to validate the structure of a syntax tree, to derive a visual editor that can change the structure of the syntax tree and how to derive a textual representation of the syntax tree. But to have an actually complete example for a real world programming language the actual possibility to run the code is still missing. Providing this kind of runtime for the textual representation of the syntax trees is however always a manual task. In the current state of our implementation the following runtimes are provided:

\begin{itemize}
\item \texttt{SQL} as understood by SQLite. The required database is stored on the server, the frontend sends the desired syntax tree to be executed.

\item \texttt{JavaScript} executed in a WebWorker, so without any access to the \texttt{DOM} and without blocking the browsers only \texttt{JavaScript} context. Basic output via \texttt{console.log} is redirect to a section under the programs block editor.

\item Regular expressions as understood by JavaScript.

\item \texttt{Trucklino} is a domain specific language based on \texttt{Java\-Script} and implemented as a bachelors thesis \cite{popp_konzeption_2019} which can be seen as a variation of the Kara approach\cite{hartmann_kara_2001} about a ladybug (here: a truck) that solves programming puzzles.

\item \texttt{JSON} and \texttt{XML} purely as data structures without any immediate application or accompanied schema.

\item Mathematical equations and transformations backed by the symbolic math library Nerdamer\footnote{\url{https://nerdamer.com/}}.

\item A subset of the GraphViz\footnote{\url{https://graphviz.org/}} language to render graphs.
\end{itemize}

Each of these runtimes operate on the assumption that there is a grammar (or in the case of Trucklino: a code generator) to compile a textual representation from any valid syntax tree. The textual representation is then used as the input for the runtime. As shown by the very diverse modes of operations on these few examples (tabular output, console output, graphical output, client side calculation, server side calculation), there is no really unified strategy available to provide a generic approach to such runtimes. Therefore all of these runtimes are custom built with TypeScript, Angular and possibly Ruby.

\section{Example: \texttt{XML} and whitespace handling}

Representing an \texttt{XML} structure consisting of any elements, attributes and child elements is very straightforward with the presented syntax trees and grammars. \enquote{Any} in this case refers to the absence of a schema, that the \texttt{XML} document must conform to. On a fundamental level it only requires a type \texttt{xml.element} which may host any number of \texttt{xml.attribute} (key-value pairs) and any number of \texttt{xml.element} as children (see Listing~\ref{lst:grammar-xml-structure}). Allowing free-form text as children of \texttt{XML} elements can be done through another node type \texttt{xml.text} which only requires a single property.

In contrast to the grammar for the expression language, the child groups \texttt{elements} and \texttt{attributes} on \texttt{xml.element} make use of the \texttt{*} operator with the usual meaning of \enquote{any number of items, including none}. This example also shows, that it is possible to have more than one type reference in a child group definition. The \texttt{\&}-operator is borrowed from RELAX NG where it is called the \enquote{interleaving}-operator. It allows children to occur independent of their order, but still respects their cardinality. Without the use of this operator, the resulting grammar would require that any \texttt{xml.element} must occur strictly before any \texttt{xml.text}. For these block grammars the use of such interleaving child groups is the norm: sequences are technically possible but typically replaced by multiple named child groups.

\begin{listing}[H]
\begin{minted}[highlightlines={4}]{typescript}
grammar "xml" {
  node "element" {
    prop "name"           string
    children "elements"   ::= element* & text*
    children "attributes" ::= attribute*
  }
  node "attribute" {
    prop "name"  string
    prop "value" string
  }
  node "text" {
    prop "value" string
  }
}
\end{minted}
\caption{Semantic structure of \texttt{XML}}
\label{lst:grammar-xml-structure}
\end{listing}

To properly visually represent \texttt{XML} however, this structural information is not enough. To have a syntactically valid \texttt{XML} document at least the syntactic pairs of brackets (\texttt{<element>}) and the attributes equality sign and the quoted value (\texttt{key="value"}) need to be specified. The result of this minimal amount of terminal symbols would however be one very long line of \texttt{XML}. This is syntactically valid, but unpleasant to work with in a block editor. In order to follow the more typical formatting of having indented child elements and the opening and closing \texttt{XML}-elements on distinct lines, we need to specify a formatting structure that includes linebreaks in the grammar.

Listing~\ref{lst:grammar-xml-syntax} shows a visualization grammar for the previously presented structural grammar. The keyword \texttt{visualize} is used here to indicate that the information for the specified type are not changing the structural semantics of a grammar: Inside a \texttt{visualize} block no \texttt{children} or \texttt{property} statements may be used. Instead it is possible to implicitly define line breaks using the \texttt{container} block. If the orientation is set to \texttt{horizontal}, the block editors and textual representation will not allow any implicit line breaks between these elements. The \texttt{vertical} orientation introduces a line break between all immediate children of the \texttt{container}. The \texttt{\{\{ property \}\}} syntax (borrowed from frameworks like Angular or Jinja) is used for interpolation: The value of the property on the node in the syntax tree will be used as the value when rendered.

The same listing also demonstrates how certain common visualization aspects are expressed using special annotations. Everything that is denoted inside a pair of parentheses is treated as a special instruction to the block- and the code-generator:
\begin{itemize}
\item The \texttt{space-before} instruction for \texttt{xml.attribute.name} ensures that there is a space between the \texttt{xml.element.name} and multiple attributes. In this particular instance it could also have been encoded as a literal space terminal symbol \texttt{'~'}, but the generators are able to e.g. combine multiple superflous spaces so expressing this via the \texttt{space-before} instruction is preferred for composeability.
\item The \texttt{keyword} instruction is used for very basic syntax highlighting in the block editor and disregarded when generating the textual representation.
\item The \texttt{double-quote} instruction places double quote terminal symbols around the terminal symbol or property it is defined on. Technically this could also be represented through a pair of literal terminal symbols. But having a single instruction that can not be torn apart when things are moved around can be very convenient.
\end{itemize}

\begin{longlisting}
\begin{minted}[]{typescript}
grammar "xml" {
  visualize "attribute" {
    container horizontal {
      {{name}} ("space-before" "keyword")
      "="
      {{value}} ("double-quote")
    }
  }
  visualize "element" {
    container vertical {
      container horizontal {
        "<"
        {{name}} ("keyword")
        {{#each attributes}}
        ">"
      }
      container vertical (indent) {
        {{#each elements}}
      }
      container horizontal {
        "</"
        {{name}} ("keyword")
        ">"
      }
    }
  }
}
\end{minted}
\caption{Syntactic structure of \texttt{XML}}
\label{lst:grammar-xml-syntax}
\end{longlisting}


With this additional syntactic information about terminal symbols, linebreaks and quotation marks \texttt{XML} can be represented in the block editor or the textual representation. The resulting \texttt{XML} block editor now renders a \texttt{HTML}-like structure as shown in Figure~\ref{fig:screen-editor-xml-no-border}. To demonstrate how close the resemblance can be, the tree has been rendered twice. Without block outlines the result almost looks like a \enquote{normal} textual representation. Only the activated property editor on the text \enquote{Really great!} gives a hint that some kind of structural editing is available.

\begin{figure}
  \includegraphics[width=0.2\textwidth]{screens/xml-blocks-html-with-border}
  \includegraphics[width=0.2\textwidth]{screens/xml-blocks-html-no-border}
  \caption{A \texttt{HTML} like structure in the \texttt{XML}-block editor, rendered with and without block outlines.}
  \label{fig:screen-editor-xml-no-border}
\end{figure}

\section{Example: \texttt{HTML}}

When going from the representation of any \texttt{XML}-document to \texttt{HTML5} the syntax stays almost the same. But for a better block editing experience proper support for \texttt{HTML5} \enquote{microsyntaxes} is desirable and fairly straightforward. The commonly used boolean attributes can technically be emulated with the \texttt{xml.attribute} presented earlier, e.g. by using \texttt{<input type="check" checked="checked">} for a pre-selected checkbox. But a specific representation via a node type without a \texttt{value} property would provide the more commonly used syntax in these cases, the previous example would be shortened to \texttt{<input type="check" checked>}. A similar argument can be made for space or comma separated tokens, commonly occurring with the \texttt{class}-attribute. While simply using a normal text property would be valid (as shown in Figure~\ref{fig:screen-editor-xml-no-border}), the editing experience would be improved with each \texttt{class} value being represented as an individual block.

The structural requirements however change drastically: \texttt{HTML5} mandates a strict hierarchy to which all elements must conform, for example a \texttt{<html>}-element must be at the root, \texttt{<head>} and \texttt{<body>} must be immediate children of \texttt{html}. On the one hand these immediate children relationships can be gracefully expressed using distinct node types, Listing~\ref{lst:grammar-html-subset-structure} shows a possible subset of such a definition. But on the other hand we will see, that this requires an unfortunate amount of redundancy for the structurally identical definitions.

Also note that on the \texttt{html.html} element the order \texttt{head} before \texttt{body} is fixed and that there may only be one \texttt{html.title} as a child of \texttt{html.head}. This way of expressing \texttt{HTML} however has a serious downside for the visualization: Although all elements are structurally identical, they would each require distinct visualization instructions. For this reason the \texttt{visualize} instruction (as introduced in Listing~\ref{lst:grammar-xml-syntax}) could be enhanced to represent more than a single type.

The more tedious mismatch between \texttt{HTML5} and the proposed grammar language is however due to the way that certain common \texttt{HTML} attributes are defined: The attributes \texttt{id} and \texttt{class} for example may appear on anything that is declared an \enquote{HTML element} by the standard. In the context of the example in Listing~\ref{lst:grammar-html-subset-structure} this would mean that all types (including the technically \enquote{invisible} types \texttt{html}, \texttt{head}, \texttt{title}, ...) must repeatedly define something like \texttt{children "classes" ::= class?} (depending on how the actual structural representation is chosen).

\begin{listing}[H]
\begin{minted}[]{typescript}
grammar "html" {
  node "html" {
    children "elements" ::= head? body?
  }
  node "head" {
    children "elements" ::= title? & link* & rel*
  }
  node "body" {
    children "elements" ::= h1* & h2* & p* & div*
  }
}
\end{minted}
\caption{Semantic structure for \texttt{HTML} subset}
\label{lst:grammar-html-subset-structure}
\end{listing}

Although it is therefore possible to accurately represent an educationally meaningful subset of \texttt{HTML5} with our grammar approach, it requires repetition and is therefore tedious for the language designer to work with. This is partially due to the lack of a way to share structures over multiple node types in the grammar language. An inheritance, mixin or macro like feature could solve this, but as the following examples for \texttt{SQL} and \texttt{JavaScript} will show: This problem is quite unique to markup languages and maybe does not warrant a complication of the currently quite simple grammar core language.

\section{Example: SQL}

Listing~\ref{lst:grammar-sql} shows a grammar that describes the structure of quite simple \texttt{SELECT ... FROM ... GROUP BY} queries that allow function calls and the star operator. The example grammar further mixes semantic and structural information to demonstrate that it is not strictly required to work with two distinct grammar documents as demonstrated previously for \texttt{XML} in listings \ref{lst:grammar-xml-structure} and \ref{lst:grammar-xml-syntax}.

\begin{longlisting}
\begin{minted}[]{typescript}
grammar "SQL" {
  node "sql"."select" {
    container vertical {
      container horizontal {
        "SELECT"
        children "columns" ::= starOperator? & expr*
      }
      children "from"    ::= from
      children "groupBy" ::= groupBy?
    }
  }
  node "sql"."starOperator" {
    "*"
  }
  typedef "sql"."expr" ::= columnName | functionCall
  node "sql"."columnName" {
    prop "refTableName" string
    "."
    prop "columnName"   string
  }
  node "sql"."functionCall" {
    prop "name" string
    "("
    children "arguments" (between: ",") ::= expr*
    ")"
  }
  node "sql"."from" {
    container horizontal {
      "FROM"
      children "tables" (between: ",") ::= tableIntro+
    }
  }
  node "sql"."tableIntro" {
    prop "name" string
  }
  node "sql"."groupBy" {
    container horizontal {
      "GROUP BY"
      children "expr" (between: ",") ::= expr+
    }
  }
}
\end{minted}
\caption{Structure and syntax details for an \texttt{SQL} subset}
\label{lst:grammar-sql}
\end{longlisting}

The root node \texttt{sql.select} defines the basic visual structure: Each component (\texttt{sql.select}, \texttt{sql.from}, \texttt{sql.groupBy}) shall be displayed on it's own line. Additionally all of these components contain the correspdonding \texttt{SQL} keyword as terminal symbols. The types \texttt{sql.functionCall}, \texttt{sql.from} and \texttt{sql.groupBy} also demonstrate, that the \texttt{children} instruction allows to specify a terminal symbol to be used between child elements.

But to actually validate the correctness of an \texttt{SQL} query the information in this grammar is not sufficient: It does not restrict the names of tables or columns. This information about the \texttt{SQL} schema could in theory be encoded into grammar as well, but practically it is not feasible to define a new dialect of \texttt{SQL} for every database. To analyze an \texttt{SQL} syntax tree in the context of a schema a custom Typescript validation function can be provided. Under the hood the structural validation based on the grammar uses the exact same validation mechanisms as those available for the custom per language validation. For \texttt{SQL} the currently implemented validator can ensure that every column reference exists in the schema, that every column reference somehow appears in the \texttt{FROM} component, that no column or table name is duplicated, that every function name is valid and that every function is called with the correct number of arguments.

An example for the validation of column names can be seen in Listing~\ref{lst:validate-valid-column}. If it turns out that the \texttt{ast} contains a reference to a column that is not defined in the \texttt{schema}, an \texttt{UNKNOWN\_COLUMN} error is added to the given validation context. The type \texttt{NodeDescription} for the variable \texttt{c} in \texttt{allColumns.forEach} is the same as shown in the definition of the syntax tree data structure in Listing~\ref{lst:typescript-ast}. The property names \texttt{refTableName} and \texttt{columnName} are the same as defined in the grammar in Listing~\ref{lst:grammar-sql}.

\begin{listing}[H]
\begin{minted}[]{typescript}
function validateColumNames(ast, schema, context) {
  const allColumns = ast.getNodesOfType({
    languageName: "sql",
    typeName: "columnName",
  });
  allColumns.forEach((c: NodeDescription) => {
    const refTable = c.properties["refTableName"];
    const columnName = c.properties["columnName"];
    if (!schema.hasColumn(refTable, columnName)) {
      context.addError("UNKNOWN_COLUMN", c);
    }
  });
}
\end{minted}
\caption{Validating column names against a \texttt{SQL} schema}
\label{lst:validate-valid-column}
\end{listing}

\begin{figure}
  \includegraphics[width=0.45\textwidth]{screens/sql-runtime-param.png}
  \caption{Builtin \texttt{SQL} block editor and runtime environment that allows to parametrize the query and shows the result}
  \label{fig:sql-runtime}
\end{figure}

To actually execute the \texttt{SQL} queries, a custom runtime based on \texttt{SQLite} can take any syntax tree that can textually be represented as \texttt{SQL}. The client sends the tree to the server where it is compiled to the textual representation and executed against a \texttt{SQLite} database. Various size and and execution time limits ensure, that hopefully the server is not overwhelmed by humongous cross products. The result is then sent back to the client for display. Figure~\ref{fig:sql-runtime} gives an impression how a slightly more complicated query than permitted by the example grammar in Listing~\ref{lst:grammar-sql} is shown to the user.

\section{Example: JavaScript}

Listing~\ref{lst:grammar-javascript} shows a grammar that allows expressing very simple JavaScript programs with \texttt{for}-loops and variable declarations. Most of the node types referenced by the \texttt{typedefs} for \texttt{expression} and \texttt{statement} are omitted, previous examples have shown how to do expressions and function calls. The definition of \texttt{js.forLoop} however demonstrates that even the more complicated structures that span multiple lines and require indentation can be expressed in a concise way.

\begin{longlisting}
\begin{minted}[]{javascript}
grammar "js" {
  node "program" {
    container vertical {
      children sequence "body" ("hole") ::= Statement*
    }
  }
  typedef "expression" ::= exprVariable
                           | constValue
                           | binaryExpression

  typedef "statement" ::= declare
                          | call
                          | forLoop
                          | increment
  node "forLoop" {
    container vertical {
      container horizontal {
        "for" ("keyword")
        "("
        children "declare" ::= declare*
        ";"
        children "check" ::= expression
        ";"
        children "step" ::= statement*
        ")"
        "{"
      }
      container vertical ("indent") {
        children "statements" ::= statement*
      }
      "}"
    }
  }
}
\end{minted}
\caption{Semantic \& syntactic structure for a \texttt{JavaScript} subset}
\label{lst:grammar-javascript}
\end{longlisting}

There is however one annoyance with the presented grammar: The root node \texttt{js.program} has no visual representation when empty. This is somewhat expected as a 0 byte file is technically also a valid JavaScript program, but as a result of this inherited design the empty program would collapse to a 1x1 pixel in the internal block editor. The same issue is present in \texttt{js.forLoop}: Technically it is perfectly valid to write a JavaScript \texttt{for}-loop that contains no \texttt{declaration} or \texttt{step} statements. A language designer can therefore decide to make his subset of JavaScript more strict and require \texttt{js.program} to have at least one \texttt{js.statement} or the \texttt{for}-loop to always incorporate the variable declaration and step statement.

When viewed at a distance, the underlying problem of \enquote{How should the block editor show possibilities to drop something at a certain location?} is actually not unique to JavaScript at all but was present all the time. In Blockly this problem is solved with the explicit connector representations on the block design. For the internal editor with it's text-like appearance this is however not possible. The system instead borrows the concept of \enquote{holes} from languages like Haskell. Every time a child node is missing with certainty, an \enquote{under construction} like question mark is displayed. Language designers can also mark child group as \enquote{soft holes} that should appear even if the the absence of children is not technically an error. Figure~\ref{fig:screen-js-empty-for} shows the representation of holes for a node of type \texttt{js.forLoop} without children. The striped background turns red if the user attempts to drag a block that would not be valid in the correspdonding location and the same approach can be applied to the empty \texttt{js.program}.

\begin{figure}[H]
  \includegraphics[width=0.22\textwidth]{screens/js-empty-for}
  \caption{Empty \texttt{for} loop with holes}
  \label{fig:screen-js-empty-for}
\end{figure}

As JavaScript is supported by every current browser and there is no need to persist any state, the corresponding runtime does not require any server roundtrips. Figure~\ref{fig:screen-js-runtime-loop} shows how a JavaScript program is executed in the current implementation of the runtime. Technically it uses a web worker to ensure that endless loops do not bring the browser to a halt and provides an alternative implementation of \texttt{console.log} in that webworker so that the user sees the actions of his run without opening any developer tools. An alternative runtime called \enquote{Trucklino} was implemented as part of a bachelors thesis\cite{popp_konzeption_2019} and is shown in Figure~\ref{fig:js-runtime-trucklino}: It provides a Kara-like\cite{hartmann_kara_2001} environment to solve puzzles with JavaScript.

\begin{figure}
  \includegraphics[width=0.45\textwidth]{screens/js-runtime-loop}
  \caption{JavaScript runtime executing a trivial program}
  \label{fig:screen-js-runtime-loop}
\end{figure}

\section{Conclusion}

The presented syntaxtree with the named child groups in conjunction with the presented grammar is versatile enough to augment any textual programming language by providing different types of block editors as well as a textual representation of the edited programming language. Representing a syntax tree through a grammar where each node type is turned into a block has shown to be an approach that fits our custom block editor as well as Google Blockly. The block editor specific grammar features like child groups, interleaving child nodes and virtual nodes may not be relevant for conventional compiler construction, but are important features when designing an editor that requires convenient ways to modify a syntax tree via dragging and dropping blocks.

Our developed environment is self-hosting and allows the definition of block editors via the described grammar specification. As these generated block editors are used to augment real programming languages, the edited programs require a fitting programming language environment to be run in. Currently these runtimes are available for \texttt{SQLite}, \texttt{Java\-Script}, Regular Expressions, \texttt{Graph\-Viz}, symbolic math equations based on Nerdamer and a quite complex (but ultimately artificial) \texttt{Java\-Script}-variation of the Kara-approach called \texttt{Trucklino}\cite{popp_konzeption_2019}, which is shown in Figure~\ref{fig:js-runtime-trucklino}.

The example programming languages that have been sketched in this paper demonstrate, that the general approach of generating a block based development environment from the grammar specification is also fast in terms of development time. Once a runtime for a conventional programming language has been developed, it can be targeted by multiple block language approaches that may put emphasis on different aspects. Therefore changing educational requirements leading to different relevant subsets of languages can be met by creating a new grammar.

To properly plan further development  we need to team up with teachers in initial programming education and figure out whether to refine the presented textual block editor or the quality of the generated Blockly editors. Ultimately the goal of our approach is to provide a tool that learners actually \textbf{want} to leave because they perceive block editors as annoying when compared to text editors.
\printbibliography

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-command-extra-options: "-shell-escape"
%%% TeX-engine: xetex
%%% TeX-master: t
%%% End:
