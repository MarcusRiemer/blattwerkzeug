\documentclass[sigconf,review=true]{acmart}

\usepackage{minted}    % Source code formatting
\usepackage{csquotes}  % Eases working with quotes
\usepackage[author={Marcus}]{pdfcomment}

% "Constant" to set the scaling of all ASTs at once
\newcommand\astScale{0.75}

\begin{document}
\title[]{Generating syntaxfree development environments for real world programming languages}

\author{Marcus Riemer}
\affiliation{%
  \institution{Christian-Albrechts-Universität}
  \city{Kiel}
  \country{Germany}
}
\email{post@marcusriemer.de}

\author{Frank Huch}
\affiliation{%
  \institution{Christian-Albrechts-Universität}
  \city{Kiel}
  \country{Germany}
}
\email{fhu@informatik.uni-kiel.de}

\begin{abstract}
  We present a grammar driven approach to augment traditional programming and markup languages like SQL, JavaScript and HTML in way that allows them to be used in a drag-and-drop manner using either Google Blockly or a custom editor that closely resembles the textual structure. Augmenting traditional languages in such a way allow users to become familiar with the syntax language and concentrate on learning the semantics of the language.
\end{abstract}

\maketitle

\section{Introduction}

Computer science introduction often uses syntaxfree drag-and-drop programming languages to ease the first steps when learning how to program. This approach has the benefit of eliminating the whole possibility to confront learners with syntax errors. But the actual languages that are being thaugt this way are not relevant in the programming industry.

This paper therefore proposes an approach to rapidly generate block language variations of conventional programming languages. Instead of hiding syntax details like parentheses, semicolons, commas, ... these are organically made part of the blocks. Therefore learners are continously confronted with the syntax details of their language of choice without having to actually type it.

\section{Architecture Overview}

Blatt\-Werkzeug defines the common set of core data structures: Syntax\-trees, grammars \& validators. The main reason for this re-invention the wheel is the differing focus of existing software: The syntaxtrees of conventional compilers (like \texttt{gcc}, \texttt{llvm}, \texttt{javac}, …) are focused on speed and correctness, and not a friendly representation for drag \& drop mutations.

BlattWerkzeug instead focuses exclusively on working with a syntaxtree that lends itself well to be directly presented to the end user. Most importantly, there must not be any node that has no visual or textual representation. Typical compiler tasks that have to do with lexical analysis or parsing are not relevant for Blatt\-Werkzeug.

At the core Blatt\-Werkzeug is about representing the same syntax tree in two different ways: Either as a block editor that can be used to edit the syntax tree. Or as a valid textual representation in the augmented programming language. For both of these representations and for general validation the desired structure is defined as a grammar.

On a technical level Blatt\-Werkzeug is split into a frontend and a backend, communication between these layers works via GraphQL. The backend is a Ruby on Rails application that uses PostgreSQL as a database, the frontend is written in TypeScript and uses Angular.

\section{Abstract Syntax Tree}

The syntax tree itself is purely a \texttt{JSON} data structure that follows the TypeScript definition in listing~\ref{lst:typescript-ast} and has no concept of being \textit{valid} or \textit{invalid} on its own (this is the task of validators). It also has no idea how to it should be represented in its block form (this is the task of block languages) or textual representation (this is the task of code generators).

\begin{listing}[H]
\begin{minted}{typescript}
export interface NodeDescription {
  name: string
  language: string
  children?: {
    [childrenCategory: string]: NodeDescription[];
  }
  properties?: {
    [propertyName: string]: string;
  }
}
\end{minted}
\caption{TypeScript definition of AST}
\label{lst:typescript-ast}
\end{listing}

A single node in the syntaxtree has at least a \textbf{type} that consists of two strings: A local name and a language. This type is the premier way for different tools to decide how the node in question should be treated. The language is essentially a namespace that allows the use of identical names in different contexts. This is useful when describing identical concepts like imperative loops or semantic markup for \enquote{heading} in different languages.

Nodes may define so called \textbf{properties} which hold atomic values in the form of texts or integers, but never in the form of child nodes. Each of these properties needs to have a name that is unique in the scope of the current node.

The children of nodes have to be organized in so called \textbf{child groups}. Each of these groups has a name and contains any number of subtrees in order. Naming the child groups enables the grammars to specify complex subtrees without relying on the ordering of sub-trees. The resulting structure has a strong resemblance to an \texttt{XML}-tree, but instead of grouping all children in a single, implicit scope, they are organised into their own-subtrees.

\subsection{Example: Binary Expression}

The tree in listing~\ref{lst:ast-expr-binary} is shown in two equivalent representations: \texttt{JSON} and a rendered tree. It is a possible representation of the expression \texttt{numRattles == null} for any language that allows to compare a \texttt{null} value against a variable. It consists of three nodes: The root node is of type \texttt{lang.expBin}, the dot (\enquote{\texttt{.}}) is used as a separator between the \texttt{language} and \texttt{name} of a node. The childgroup with the name \texttt{lhs} (\enquote{left hand side}) contains a node of type \texttt{lang.expVar} which is meant to refer to an existing variable on the left hand side of the expression. The property \texttt{name} is set to \texttt{numRattles}.

\begin{listing}[H]
\begin{minted}{typescript}
{
  "language": "lang",
  "name": "expBin",
  "properties": { "op": "eq" },
  "children": {
    "lhs": [
      {
        "language": "lang",
        "name": "expVar",
        "properties": { "name": "numRattles" }
      }
    ],
    "rhs": [
      { "language": "lang", "name": "null" }
    ]
  }
}
\end{minted}
\includegraphics[scale=\astScale]{../manual/generated/ast-example-expr-binary}
\caption{AST for expression \texttt{null}}
\label{lst:ast-expr-binary}
\end{listing}

\subsection{Example: \texttt{if}-Statement}

The following example further motivates the reasoning for named child groups and shows how the non-existant parsing-step can be used for more precise error messages.

An \texttt{if} statement can be described in terms of its structure and the underlying semantics: It uses a predicate to distinguish whether execution should continue on a positive branch or a negative branch. Details about the name of the keyword itself (probably if \texttt{if}, maybe a \texttt{then}, maybe with parentheses around the predicate?) or the syntax of blocks (\texttt{\{\}}, \texttt{begin} ... \texttt{end}, indentation, ..?) are irrelevant for the semantics.

Listing~\ref{lst:if-stmt-pred} shows two sample programs: One with a correct \texttt{if}-Statement that uses a \texttt{then} is shown on the left. And one program with an incorrect \texttt{if}-Statement that accidentaly omits the \texttt{then} and the correspdonding expression is shown on the right. The correspdonding syntaxtree for the correct variation is shown in figure~\ref{fig:if-stmt-pred}. The expression \texttt{a > b} is in the \texttt{pred} child group, the call to \texttt{writeln} is in the \texttt{positive} child group and the call to \texttt{err} is in the \texttt{negative} child group. From the perspective of the syntaxtree, each of these child groups has a distinct meaning that is also conveyed as part of the name. Even without hand-crafted error messages an error like \texttt{\enquote{lang.if} has empty childgroup \enquote{predicate}} would quite nicely convey the problem with a missing expression for the predicate. Without named childgroups, e.g. in a \texttt{XML} like tree structure, the semantics of the sub-trees would be defined by the order they appear in and there would be no easily available name.

But the actual benefit of only working with syntax trees and not requiring a parsing step goes deeper than having nicer error messages for free. The incorrect \texttt{if}-statement that omits the expression and the \texttt{then} in listing~\ref{lst:if-stmt-pred} uses indentation to convey the intent of the author: The \texttt{writeln} statement is offset in the same way as the \texttt{err} statement. But a parser that stumbles over this code would, at least without extra logic, be mislead by the \texttt{writeln} statement reading exactly like an expression. The most probable error message would read something along the lines of \enquote{\texttt{Invalid predicate: expression writeln('foo') is not of type boolean}} and \enquote{\texttt{Missing keyword then}}. In contrast the syntax tree can't make such a miss-attribution by accident because it relies on named child groups, not on the order of the sub-trees.

\begin{listing}[H]
\begin{minipage}{.20\textwidth}
\begin{minted}{pascal}
if (a > b) then
  writeln('foo')
else
  err(2, 'bar')
\end{minted}
\end{minipage}
\begin{minipage}{.20\textwidth}
\begin{minted}{pascal}
if
  writeln('foo')
else
  err(2, 'bar')
\end{minted}
\end{minipage}
\caption{\texttt{if}-Statement with and without predicate}
\label{lst:if-stmt-pred}
\end{listing}

\begin{figure*}
  \includegraphics[scale=\astScale]{../manual/generated/ast-example-if}
  \caption{\texttt{if}-Statement with predicate}
  \label{fig:if-stmt-pred}
\end{figure*}

\section{Expression Grammar}

As syntaxtrees may define arbitrary tree structures, but for practical reasons only trees conforming to a certain set of known properties and children are of relevance. The example in listing~\ref{lst:ast-expr-binary} implicitly relied on a few limitations:

\begin{enumerate}
\item \texttt{lang.null} never has children or properties.

\item \texttt{lang.expVar} never has children, but it must have a property called \texttt{name} which denotes the name of the variable the expression refers to.

\item \texttt{lang.expBin} has two child groups named \texttt{lhs} and \texttt{rhs} which stand for the two sides of the equation. These child groups may themselves contain a single \texttt{null}, \texttt{expVar} or \texttt{expBin}. The property \texttt{op} will treat the value \texttt{eq} with the meaning \enquote{equality} and possibly allows other values such as \texttt{leq} or \texttt{gt}.
\end{enumerate}

Imposing such structural requirements by restricting the allowed or required properties and child groups is done with a grammar. The underlying validation concept is losely based on XML Schema and RelaxNG, the syntax of the latter is also used as the inspiration to describe the grammars in a user friendly textual representation.

In contrast to grammars in general compiler construction, the grammar described here is not meant to create a syntax tree from some stream of tokens but rather begins with an empty syntax tree. This frees it from many of the problems that have been mentioned above:

\begin{enumerate}
\item There is no whitespace and seperation characters are never required. What matters is only the structure of the tree: The type of the node in question determines which properties and child groups exist and what values are permitted.
\item Syntax errors equate to missing nodes and can be communicated very clearly. Semantic analysis does not need to rely on heuristics on how the tree could change if the \enquote{blanks} were filled in.
\end{enumerate}

In comparision to traditional grammars, this shifts the way one has to reason about the validation rules inside of BlattWerkzeug: There is no need to worry about the syntactic aspects of a certain language, the grammar that is required doesn’t need to know anything about keywords or separating characters. Its sole job is to describe the structure and the semantics of trees that are valid in that specific language. If keywords are included in the grammar, this is solemly for the purpose of blocks that resemble the underlying programming language or for code generation. The actual grammar validation does not use these keywords at all.

\subsection{Expression Semantics}

In this example we will construct a grammar to validate structures like the expression in listing~\ref{lst:ast-expr-binary}.

This grammar in listing~\ref{lst:grammar-expr-null} defines a language named \texttt{lang} which allows a single node with the name \texttt{null} to be present in the syntax tree. This node may not have any children or properties, so the only valid syntaxtree would consist of a single node.

\begin{listing}[H]
\begin{minted}{typescript}
grammar "lang" {
  node "null" {
  }
}
\end{minted}
\caption{Grammar for expression \texttt{null}}
\label{lst:grammar-expr-null}
\end{listing}

In order to also allow references to variables, we add a second valid type of node called \texttt{expVar} (listing~\ref{lst:grammar-expr-expVar}. Nodes of this type must have the property \texttt{name} being present, but at the given state we do not make any practical restriction on how this name could look like.

\begin{listing}[H]
\begin{minted}[]{typescript}
grammar "lang" {
  // node null as before

  node "expVar" {
    prop "name" { string }
  }
}
\end{minted}
\caption{Grammar for expression \texttt{expVar}}
\label{lst:grammar-expr-expVar}
\end{listing}

With the types \texttt{lang.null} and \texttt{lang.expVar} defined, we now have two leaf nodes for our expression language. In order for a type to act as a parent, as \texttt{lang.expBin} must, we need to define the names and the valid types for the child groups. Listing~\ref{lst:grammar-expr-expBin-verbose} declares such a type that defines the child groups \texttt{lhs} and \texttt{rhs} to either take a \texttt{expNull} or an \texttt{expVar}. With this grammar we may now generate checks for comparisions like \texttt{a + 1}, \texttt{a >= a} or \texttt{null == null}.

\begin{listing}[H]
\begin{minted}[]{typescript}
grammar "lang" {
  // node null and expVar as before

  node "expBin" {
    children "lhs" ::= expNull | expVar
    prop     "op"  { string }
    children "rhs" ::= expNull | expVar
  }
}
\end{minted}
\caption{Grammar for expression \texttt{expBin}}
\label{lst:grammar-expr-expBin-verbose}
\end{listing}

Unfortunately there is already some duplication in the definitions of the child groups \texttt{lhs} and \texttt{rhs}: Both should always allow the exact same types. And on top of that it is not possible to nest expressions, because \texttt{lang.expBin} is not an allowed child for either of the sides.

In a typical grammar we would introduce a new node type like \texttt{lang.expAny} which would consist of a single child group that lists all permitted values. Listing~\ref{lst:grammar-expr-expBin-choiceNode} shows the relevant excerpt of the grammar and figure~\ref{fig:ast-choice-node} demonstrates how a valid tree for this grammar could look like: The immediate children of \texttt{lang.expBin} are no longer the actual nodes with semantic meaning, but the artifical choice nodes of type \texttt{lang.expAny}.

\begin{listing}[H]
\begin{minted}[]{typescript}
grammar "lang" {
  // node null and expVar as before

  node "expAny" {
    children "exp" ::= expBin | expNull | expVar
  }

  node "expBin" {
    children "lhs" ::= expAny
    prop     "op"  { string }
    children "rhs" ::= expAny
  }
}
\end{minted}
\caption{Grammar for expression \texttt{expBin} with choice node}
\label{lst:grammar-expr-expBin-choiceNode}
\end{listing}

\begin{figure}
  \includegraphics[scale=\astScale]{../manual/generated/ast-example-expr-binary-artificial}
  \caption{Expression tree with artificial choice nodes}
  \label{fig:ast-choice-node}
\end{figure}

The tree for such a grammar would however contain nodes of type \texttt{expAny} that do not have any kind of possible representation for the end user: As there is no possible textual representation for such a node, it would appear as a completely empty block that can only host another block. The examples syntax trees in  figure~\ref{fig:ast-choice-node} and listing~\ref{lst:ast-expr-binary} would both be compiled to the exact same textual representation \texttt{numRattles == null}.

To avoid these nodes without visual or textual representation any kind of recurring choice between multiple node types is treated differently from the conventional approach in these grammars: By introducing a pure virtual node type that is referrable by name in the grammar, but may never appear in an actual syntax tree. The textual grammar representation uses the keyword \texttt{typedef} to introduce such a type, the following listing~\ref{lst:grammar-expr-expBin-typedef} changes the definition of \texttt{nodeAny} to be such a virtual node and shows the final grammar for the semantics of simple expressions in entirety. The previous definition of \texttt{expBin} (as in listing~\ref{lst:grammar-expr-expBin-choiceNode} is unaffected by this change, altough the trees that are validated by the grammars are different. This updated grammar that uses the \texttt{typedef} approach will successfully validate the example binary expression from listing~\ref{lst:ast-expr-binary}. Additionally we have added a type \texttt{lang.expConst} to express constant values.

\begin{listing}[H]
\begin{minted}[]{typescript}
grammar "lang" {
  node "null" {
  }

  node "expVar" {
    prop "name" { string }
  }

  node "expConst" {
    prop "value" { number }
  }

  typedef "expAny" ::= expBin | expNull
                         | expVar | expConst

  node "expBin" {
    children "lhs" ::= expAny
    prop     "op"  { string }
    children "rhs" ::= expAny
  }
}
\end{minted}
\caption{Final semantic grammar for expressions}
\label{lst:grammar-expr-expBin-typedef}
\end{listing}

\subsection{Example: Expression Syntax}

Although the syntax trees that are validated by the final semantic grammar for the expression language (listing~\ref{lst:grammar-expr-expBin-typedef}) are unambiguous in tree form, their default textual representation is possibly not. Figure~\ref{fig:ast-nested-ambiguous} shows a tree that in a depth first evaluation would effectively calculate $A+B$ first and then multiply the result with $2$. Or in textual form: The intended order of operation is $2 * (A+B)$. The textual form however would evaluate to $2 * A + B$.

\begin{figure}
  \includegraphics[scale=\astScale]{../manual/generated/ast-example-expr-binary-nested}
  \caption{Expression with addition before multiplication}
  \label{fig:ast-nested-ambiguous}
\end{figure}

This demonstrates, that even for the simple expression language we require some basic form of extra terminal symbols, namely the parenthesis in the textual representation. Without such additional syntax the structural information that is part of the tree can't be represented in the textual representation. For this basic example we can mix the semantic structural definition with the syntactic information about terminal symbols in the same grammar by simply adding the parentheses in double quotation marks (listing \ref{lst:grammar-expr-expBin-syntax}). On top of that the \texttt{lang.expNull} node had absolutly no textual representation so far.

These terminal symbols are absolutly irrelevant for the validation process: As the syntax tree never contains any terminal symbols, they can't be validated. But the generated block language and the pretty printer will incorporate these tokens when generating the output. Therefore the grammar that includes the terminal symbol will compile the tree in figure~\ref{fig:ast-nested-ambiguous} to $(2 * (A + B))$.

For conventional programming languages, these terminal symbols are not only used for parentheses but also for keywords (\texttt{if}, \texttt{for}, \texttt{while}, \texttt{SELECT}, \texttt{FROM} ...) and other syntactic information like semicolons, commas, ...

\begin{listing}[H]
\begin{minted}[]{typescript}
grammar "lang" {
  // expAny, expConst and expVar as before

  node "expNull" {
    "null"
  }

  node "expBin" {
    "("
    children "lhs" ::= expAny
    prop     "op"  { string }
    children "rhs" ::= expAny
    ")"
  }
}
\end{minted}
\caption{Final syntactic grammar for expression \texttt{expBin}}
\label{lst:grammar-expr-expBin-syntax}
\end{listing}

\section{Expression Block Language}

Block languages are a data structure that contain the relevant information on how to represent a syntax tree visually. Technically they are a \texttt{JSON}-document that contains instructions like \enquote{render a terminal symbol} or \enquote{render all sub-trees of a certain child group}.

Every block editor requires a source of block that is commonly called the sidebar. Whenever the user wants to add to the program at hand, he will search the sidebar for the block he desires and drag it to the central canvas.

\subsection{Builtin Editor}

The builtin editor draws a black border around each block and renders the terminal symbols and the properties of the tree as closely as possible to the textual representation, see figure~\ref{fig:screen-editor-expr-internal} for the rendered representation of the syntax tree in figure~\ref{fig:ast-nested-ambiguous}. The underlined operators \texttt{*} and \texttt{+} can be clicked to open a drop down to select possible operators from the enum.

\begin{figure}
  \includegraphics[width=0.45\textwidth]{screens/expr-blocks-internal}
  \caption{Builtin editor for expressions}
  \label{fig:screen-editor-expr-internal}
\end{figure}

\subsection{Blockly Editor}

Without any further hints, the blockly representation is readable, but not quite a friendly representation, see figure~\ref{fig:screen-editor-expr-blockly}. This is due to a conceptual mismatch: The proposed grammar defines number of elements in child group on parent. In Blockly each block defines whether follow-up is allowed or not. So without any further information, the blockly representation assumes each child group to host a possibly infinite amount of sub-trees. This is rather unfortunate in the two strictly single node children of \texttt{lang.expBin}.

\begin{figure}
  \includegraphics[width=0.45\textwidth]{screens/expr-blocks-blockly}
  \caption{Blockly editor for expressions}
  \label{fig:screen-editor-expr-blockly}
\end{figure}

\subsection{Textual Representation}

Backend \#3: Some Listings

\subsection{Fallback Representation}

When confronted with defect block language definitions, the block editor can resort to a fallback that is generated on the fly based on the grammar. This representation is a mixture of \texttt{JSON} and grammar notation which should be immediatly obvious to people that are familiar with the syntax tree representation. It uses the terms \enquote{node}, \enquote{prop} and \enquote{children} to visualize the data in the tree. Figure~\ref{fig:screen-editor-expr-fallback} shows the fallback representation of the four nodes of the example syntax tree that has been visualized in the two previous screenshots of the editor.

As this representation is technically a normal blockl language, it is also fully editable. Everything that is underlined may be clicked and changed. The blocks also may be dragged and new blocks can be added from the sidebar.

\begin{figure}
  \includegraphics[width=0.3\textwidth]{screens/expr-blocks-fallback}
  \caption{Internal fallback representation for expressions}
  \label{fig:screen-editor-expr-fallback}
\end{figure}

\subsection{CSS Styling}

\section{Programming Language Runtimes}

So far we have discussed how grammars can be used to validate the structure of a syntax tree, to derive a visual editor that can change the structure of the syntax tree and how to derive a textual representation of the syntax tree. But to have an actually complete example for a real world programming language the actual possibility to run the code is still missing.

\section{Self Hosting}

The syntax that has been used so far to describe the grammars is a textual representation of the grammar editor that is available within Blatt\-Werkzeug. It is therefore possible to create grammars for new programming languages from inside the tool itself. The grammar to describe .

\begin{figure}
  \includegraphics[width=0.45\textwidth]{screens/expr-blocks-grammar}
  \caption{Rendered grammar for expressions}
  \label{fig:screen-editor-expr-grammar}
\end{figure}

\section{Example: XML}

\subsection{Multiple Children}

\subsection{Order Of Children}

Most \texttt{HTML} elements can appear in any order.

\section{Example: HTML}

Reduction of possible DOM values without sacrificing the semenatic structure.

\section{Example: SQL}

\subsection{Validation}

Only columns mentioned in the \texttt{FROM} clause may be used in the other clauses.

\section{Example: JavaScript}

\subsection{Problem: Virtual Root}

\subsection{Runtime}

\section{Conclusion}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-command-extra-options: "-shell-escape"
%%% TeX-engine: xetex
%%% TeX-master: t
%%% End: