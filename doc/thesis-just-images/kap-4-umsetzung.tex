\section{Implementierung}
\label{sec:implementation-analysis}

\subsection{Kontext}

Die bereits existierende Anwendung besteht aus einem Serverseitigen Backend in
Ruby on Rails, der auch die erstellten Webseiten aus Liquid Templates rendert,
und dem in Angular geschriebenen Editor, mit dem die Webseiten erstellt werden.

\subsubsection{Kommunikation via Description Interface}

Server und Client übertragen Daten in der Form von JSON Objekten, die je Zweck
einem Description Interface entsprechen müssen. Ein Description Interface legt
die Felder und Typen der JSON Objekte fest, die diesem Interface unterliegen.
Das Basis Description Interface schreibt folgende Felder vor:

\begin{minted}{json}
{
  "id": "<UUID as string>",
  "name": "<string>",
  "apiVersion": "<unsigned integer>"
}
\end{minted}

\subsubsection{Server: Ruby on Rails}

Rails ist ein in Ruby geschriebenes serverseitiges Framework für
Webanwendungen. Rails mach bestimmte Annahmen darüber was der ``richtige'' Weg
ist, bestimmte Dinge zu tun und was Webanwendungen benötigen und stellt hierfür
Werkzeuge bereit. Rails verfolgt das Model-View-Controller Konzept, aber da die
Anwendung vor Rails Sinatra verwendet hat ist die Logik nicht in Models sondern
in durch den Controller verwendeten Librabies untergebracht. Die Views werden
ebenfalls nicht verwendet. Für den Editor stellen die Controller die vom Angular
Client genutzten API Endpunkte bereit und das eigentliche Frontend wird in durch
die Templating Engine Liquid gerendert.

\subsubsection{Client: Angular 4}

Angular ist eine Platform für Web- und Desktopanwendungen, wobei mit Angular
erstellte Desktopanwendungen Frameworks wie Electron benötigen, die einen
Server, einen kompatiblen Browser und die Daten ``zusammenkleben'' und als
Anwendung ausliefern, im Fall von Electron handelt es sich um Node.js und
Chromium, deren Sicherheitsrelevante Updates eines Updates der Anwendung durch
den Entwickler bedürfen. Im Fall von Webanwendungen liegt es am Nutzer einen
kompatiblen Browser zu verwenden allerdings ist der Nutzer nicht für das
Einspielen von Sicherheitsupdates des Browsers vom Entwickler der Webapp
abhängig und auf den Servern eingespielte Sicherheitsupdates sind sofort für
alle Nutzer gültig.

Angular verwendet Typscript, was zu JavaScript kompiliert wird. Bei
abgeschaltetem JavaScript oder Browsern ohne JavaScript, wie sie unter anderem
von Screenreadern für blinde Nutzer verwendet werden, ist ohne zutun des
Entwicklers nicht mehr als eine leere Seite zu sehen, da alle in Angular
entworfenen Inhalte erst nach dem Laden der Seite durch das Framework in
JavaScript nachgeladen werden.

Angular Anwendungen sind aufgeteilt in Module. In den Modulen befinden sich
Components und Templates. Templates stellen ein Element in der Anwendung dar,
während Components dem Template die dargestellten Daten liefert und auf im
Kontext des Templates auftretende Ereignisse verarbeitet. Dabei kann in einem
Template direkt der Wert einer Eigenschaft der Component referenziert werden,
der dann dort dargestellt und bei Änderung aktualisiert wird und ein Ergeignis
wie onClick direkt mit einer Funktion der Component verbunden werden. Angular
kennt weiterhin Services, die dazu gedacht sind bestimmte Aufgaben auszuführen,
wie Kommunikation mit dem Server oder Verwaltung von Konfigurationen.

\subsection{TODO: find name}

\todo{describe this subsection}

\subsubsection{Caching}

Die Bildverwaltung erlaubt es, jederzeit ein Bild zu verändern, ohne dass sich
die URL ändert. Dadurch geht de Client davon aus, dass das in seinem Cache
liegende Bild noch aktuell ist und die neue Version des Bildes nicht geladen
wird, bis das Bild aus dem Cache des Clients gelöscht wurde.

Dieses Verhalten kann umgangen werden, indem die URL für jeden Request um den
aktuellen Zeitstempel als Parameter erweitert wird, führt jedoch dazu, dass der
Cache komplett ausser Kraft gesetz wird. Eine weitere unwirksame Methode ist das
setzen der maximalen Lebensdauer des Bildes im Cache durch den dafür
vorgesehenen HTTP-Header, da hierfür der Zeitpunkt der nächsten Änderung des
Bildes bekannt sein müsste. Ohne diese Information ist diese Methode lediglich
eine Balance zwischen den beiden zuvor genannten, aber keine korrekte Lösung des
Problems.

Zur korrekten Lösung des Problems stellt HTTP zwei Header zur Verfügung: ETAG
und Last-Modified. Bei beiden stellt der Client den Request an den Server,
schickt aber den Last-Modified bzw ETAG Header mit dem vom Server zuletzt
übermittelten Wert mit. Der Server prüft ob der vom Client im Header
übermittelte Wert noch aktuell ist und antwortet mit dem aktuellem Inhalt oder
dem Hinweis, dass der vom Client gecachete Inhalt sich auf Serverseite nicht
verändert hat.

ETAG verwendet hierbei eine Checksumme über den Inhalt, Last-Modified einen
Zeitstempel. Im Kontext der Bildverwaltung sind beide gleich Wirkungsvoll, da
jedes Bild im Dateisystem gespeichert wird und somit der Zeitstempel vom
Dateisystem verwaltet und bei Änderungen an der Datei aktualisiert wird. Die
Verwendung der Checksumme setzt voraus, dass für jeden Request zum Abrufen eines
Bildes die Checksumme des Bildes neu berechnet werden muss. Im Gegensatz zu
Last-Modified kann ETAG durch Bitflip entstandene Bildänderungen feststellen und
sie dem Projektautoren schneller anzeigen und ist resistent gegenüber
Manipulation des Zeitstempel im Dateisystem oder Unregelmäßigkeiteiten in der
Systemzeit, allerdings kann ersteres durch Verwendung hostingtauglicher
Festplatten- und Dateisystemkonfigurationen vermieden werden und letzteres
deutet auf einen Hardwaredefekt hin dessen Mitigation nicht in den Anforderungen
an die Bildverwaltung enthalten ist, während die Manipulation der Zeitstempel
externen Eingriff auf durch den Systemadministrator oder einen Angreifer auf das
System bedeutet ersteres widerspricht der Aufgabe des Systemadministrators und
das Verhindern von letzterem ist sowohl Aufgabe aller am erstellen oder
betreiben der Software beteiligter. ETAG und Last-Modified können auch zusammen
verwendet werden, sodass im Fall einer Veränderung des Bildes das berechnen der
Checksumme entfallen kann, da sich der Zeitstempel bereits unterscheidet. Im
wesentlich häufiger auftretenden Fall des aktuellen Client Caches muss die
Checksumme jedoch weiter berechnet werden.

Die Bildverwaltung verwendet den Last-Modified Header mit dem Zeitzonenfreien
Zeitstempel aus dem Dateisystem, da der zusätzliche Overhead durch das Berechnen
der Checksumme jedes ausgliefertem Bildes keinen ausreichenden Mehrwert
gegenüber der Verwendung des Zeitstempels bietet. Beim Skalieren der Anwendung
auf mehrere nicht unhabhängige Instanzen kann der Last-Modified Header aus dem
Filesystem nicht mehr zuverlässig verwendet werden ohne dass beim
Synchronisieren der Daten die Zeitstempel mit synchronisiert werden, hier kann
die Verwendung des ETAG Headers besser sein, allerdings ist der Wechsel von
Last-Modified zu ETAG trivial und die Software derzeit nicht in der Lage in
dieser Form betrieben zu werden.

\subsubsection{API}

Die API stellt verschiedene Routen bereit, die sich in das existierende
Strukturen einfügen, daher sind alle Routen unterhalb von
\mint{ruby}|/api/project/:project_id/image| angesiedelt

\begin{minted}{ruby}
/api/project/:project_id/image
  GET     #gibt die Liste aller Bildmetadaten aus
  POST    #legt ein neues Bild an
/api/project/:project_id/image/:image_id
  GET     #gibt ein Bild aus
  POST    #ersetzt die Bilddatei
  DELETE  #löscht ein Bild inklusive Metadaten
/api/project/:project_id/image/:image_id/metadata
  GET     #gibt die Metadaten eines Bildes aus
  POST    #ersetzt die Metadaten eines Bildes
\end{minted}

Es folgen Ausführungen zu den einzelnen Routen:

\begin{minted}{ruby}
GET /api/project/:project_id/image
\end{minted}

Diese Route liefert eine Liste der Metadaten aller Bilder, die dem Projekt zur
Verfügung stehen. Zur Zeit sind das alle Bilder, die via Bildverwaltung im
Projekt hochgeladen wurden. Geplant ist weiterhin eine Globale Bildverwaltung
deren Bilder in allen Projekten verfügbar sind, sowie nach Implementierung der
Projektvererbung die Bilder aller Projekte in der Vererbungskette. Aus Sicht der
Bildverwaltung macht es daher Sinn alle Projekte die nicht explizit ein anderes
Projekt beerben von einem Speziellen Urprojekt erben zu lassen, in deren
Bildverwaltung die globale Bildersammlung hinterlegt werden, so kann eine
sonderbehandlung in der Bildverwaltung vermieden werden.

\begin{minted}{ruby}
POST /api/project/:project_id/image
\end{minted}

Diese Route wird verwendet um neue Bilder in der Bildverwaltung anzulegen. Es
wird ein Multipart Formular erwartet, bestehend aus dem Bild und den Metadaten.
Da nur der Projektautor in der Lage sein soll das Projekt zu editieren, ist
diese Route, wie der Rest der modifizierenden Editorfunktionen, durch HTTP Basic
Auth abgesichert.

\begin{minted}{ruby}
GET /api/project/:project_id/image/:image_id
\end{minted}

Diese Route liefert das Bild aus, damit es von einem Webbrowser angezeigt werden kann.

\begin{minted}{ruby}
POST /api/project/:project_id/image/:image_id
\end{minted}

Diese Route akzeptiert ein Bild, welches die gespeicherte Bilddatei ersetzt.
Sie ist ebenfalls via Basic Auth abgesichtert.

\begin{minted}{ruby}
DELETE /api/project/:project_id/image/:image_id
\end{minted}

Diese Route wird verwendet um ein Bild inklusive seiner Metadaten zu löschen und
verwendet selbstverständlich Basic Auth.

\begin{minted}{ruby}
GET /api/project/:project_id/image/:image_id/metadata
\end{minted}

Diese Route liefert die Metadaten eines bestimmen Bildes aus.

\begin{minted}{ruby}
POST /api/project/:project_id/image/:image_id/metadata
\end{minted}

Diese abgesichterte Route aktzeptiert einen Satz Metadaten, um den zu dem Bild
gehöhrigen zu ersetzen.

Die versendeten Metadaten entsprechen dem Format des Description Interfaces:

\begin{minted}{json}
{
  "id": "<UUID as string>",
  "name": "<string>",
  "apiVersion": "<unsigned integer>",
  "author-name": "<string>",
  "author-url": "<string>",
  "licence-name": "<string>",
  "licence-url": "<string>"
}
\end{minted}

\subsubsection{Library}

Ein Hauptaspekt der Bildverwaltung ist eine Übersicht aller dem Projekt
verfügbaren Bilder und der Möglichkeit die Bilder nach Bildname, Urhebername und
Lizenzname zu filtern. Die Daten stammen aus der API Route, der alle
Bildmetadaten liefert und können sowohl zur besseren Betrachtbarkeit als
Gallerie oder zur besseren Übersicht über die Metadaten als Liste angezeigt
werden. \todo{Screenshot von der Gallerie} \todo{Screenshot von der Liste}

Der Upload geschieht über ein der Bildverwaltung untergeordneten Dialog
bestehend aus einem Formular mit Feldern für Name des Bildes, Name des Urhebers, Url zur
Webseite des Urhebers, Name der Lizenz unter der das Bild verwendet wird, der
Url zum Text der Lizenz, sowie dem Dateiupload.

Aus der Übersicht kann jedes Bild einzelnd gelöscht oder bearbeitet werden. Beim
bearbeiten wird ein Dialog ähnlich dem Upload Dialog angezeigt, mit dem
Unterschied, dass uberhalb des Formulars das Bild angezeigt wird und das
Formular aufgeteilt ist in einen Teil für die Metadaten, die mit den aktuellen
Werten vorausgefüllt werden, und einen weiteren Teil um die Bilddatei zu
ersetzen. Jeder Formularteil kann einzelnd abgesendet werden. So kann ein Fehler
in den Metadaten korrigiert werden, ohne dass die Datei erneut hochgeladen
werden muss bzw. die Bilddatei in einem anderen Dateiformat oder anderer
Bildgröße hochzuladen ohne die Metadaten zu verändern.

Die Verwendung von Namen und Url zu einer Lizenz ist auf den ersten Blick eher
unelegant und eine Liste von Lizenzen von der Art Propriätär, Gemeinfrei, CC0,
CC-BY, CC-BY-SA, CC-BY-ND, CC-BY-NC, CC-BY-NC-SA und CC-BY-NC-ND mit bereits
hinterlegten Verweisen auf die Lizenzen und im Falle der CC Lizenzen den Badges
zum Rendern bei der Quellenangabe. Allerdings ist allein die Auflistung der CC
Lizenzen ein Problem. Die aktuelle Fassung der CC Lizenzen ist 4.0, es
existieren aber noch ältere Versionen die immer noch in Verwendung sind. Bei
Lizenzen zählt die Version, unter der das Bild vom Urheber veröffentlicht wurde.
Wenn der Urheber das Bild nicht unter der aktuelleren Version der jeweiligen CC
Lizenz neu veröffentlicht hat, gilt weiterhin die ursprüngliche Version. Die
Angabe der falschen Version der Lizenz bedeutet, dass die Lizenzbedingungen
nicht erfüllt sind. Weiterhin existieren beispielsweise von den 3.0 Versionen
auf verschiedene Juristiktionen portierte Versionen, die wiederum korrekt
auseinandergehalten werden müssen. Weiterhin kann jede der Lizenzen adaptiert
werden um zusätzliche Bedingunen hinzuzufügen. Die Verwaltung der Lizenzliste
bedeutet einen großen Wartungsaufwand, da ständig neue Lizenzen auftauchen
können. Außerdem macht die nötige Anzahl der Lizenzen in der Liste die Auswahl
zu umständlich und verwirrend wenn man die Zielgruppe bedenkt. Da die Zielgruppe
außerdem für den Umgang mit Lizenzen sensibilisiert werden soll ist der Kontakt
mit dem Text der Lizenzen bzw. im Falle der CC Lizenzen wenigstens der
Verständliche Zusammenfassung durchaus zielführend und kann außerdem die
Wahrscheinlichkeit erhöhen dass CC Lizenzen für eigene Werke verwendet werden,
da dafür die Existenz dieser bekannt sein muss.

\subsubsection{Frontendintegration}

Für das Frontend wird die Templating Engine Liquid verwendet. Der Seiteneditor
erzeugt ein Template, in dem Zwei verschiedene Bild Tags enthalten sein können:
einer für grafische Elemente, die in der Quellliste am Ende der Seite aufgeführt
werden, und einer für Abbildungen, denen die Quelle direkt angehängt ist.
Letztres verwendet einen dafür erzeugten Tag displayImageFigure, der den Tag in
eine HTML Figure Umgebung mit dem Bild und der Quellenangabe rendert.

Für die grafischen Elemente wird ebenfalls ein spezieller Tag verwendet,
allerdings muss dieser nicht nur die HTML Darstellung des Bildes rendern,
sondern auch dafür sorgen, dass das Bild in der Quellenliste aufgeführt wird.
Der Tag muss also einen Seiteneffect auslösen, der das Bild der Quellenliste
hinzufügt, weshalb er addToSourceList heißt. Die Quellenliste wird durch den Tag
displaySourceList gerendert, der am Ende jeder Seite eingefügt wird.

Es ist im Konzept von Liquid nicht vorgesehen, dass das Rendern eines Tags
einfluss auf darauf folgende Tags hat, weshalb die Quellenliste in einer
globalen Variable gespeichert werden muss. Da mehrere Rendervorgänge
geleichzeitig stattfinden können, die sich allerdings nicht gegenseitig
beeinflussen dürfen, wird für jeden Rendervorgang eine UUID erzeugt, unter der
die Quelliste des Rendervorgangs abgelegt wird bis der Rendervorgang
abgeschlossen ist.

Jedes rendern eines addToSourceList Tags fügt die Metadaten des Bildes in
die Quellliste unter der UUID des Rendervorgangs ein. Dabei wird gezählt wie oft
dieses Bild bereits dargestellt wurde und diese Nummer an die UUID der Bildes
angehängt als Id des HTML img Elements verwendet, damit die Quellliste auf das
Bild verlinken kann.

Wird die Quellliste gerendert, so werden alle In die Quellliste der UUID des
Rendervorgangs eingetragenen Bildmetadaten nach Urheber und Bild UUID gruppiert,
sodass die Quellliste einen Eintrag je Urheber mit all seinen Bildern und einen
Eintrag je Bild mit allen vorkommen und Link auf diese enthält. Zum Gruppieren
der Urheber wird die Kombination aus Name und URL des Urhebers verwendet um
Urheber gleichen Namens oder Urheber mit gemeinsamer Webseite auseinanderhalten
zu können. Für jedes Bild wird unter dem Eintrag des Autoren ein Eintrag mit
namen und Lizenz des Bildes angelegt, wobei dem Namen nummerierte Links
angehängt sind, die auf die Vorkommen der Bilder oben auf der Seite verlinken.

\subsubsection{Seiteneditorintegration}

Der Seiteneditor verfügte bereits über ein Image Element, für das ``src'' und
``alt'' wie in HTML üblich befüllt werden konnten. Dieses Element wurde ersetzt
durch eines, bei dem ein Bild aus der Bildverwaltung und die Darstellungsform
auswählbar sind. Dazu wurde eine Angular Komponente geschaffen, die sowohl an
dieser Stelle als auch bei der auswahl des Projektbildes verwendet wird. Die
erste Fassung dieser Komponente ist eine einfache Dropdownliste, in der die
Namen der Bilder aus der Bildverwaltung aufgeführt sind, da derzeit keine
modalen Dialoge zur Verfügung stehen. Sobald sich das ändert, kann stattdessen
ein Auswahldialog wie die Bildübersicht mit den selben Filteroptionen verwendet
werden.

\subsubsection{Datenbankintegration}

\todo{insert image}

Mit einer Datenbank, die die Bilddateien in Datenbank in den Tabellen speichern
kann ist der erste Ansatz davon gebrauch zu machen. Daraus resultiert das Schema
bestehend aus der Tabellengruppe ``image'', ``author'' und ``licence'' wie in
der Abbildung dargestellt. Dies bedarf jedoch einem Datenbankzugriff für jedes
darzustellende Bild, so dass das Schema statt dem Blob den Pfad zum Bild im
Dateisystem beinhalten sollte, wie in ``image\_O1'', ``author\_O1'' und
``licence\_O1'' dargestellt. Da die Bilder durch ihre UUID bereits eindeutig
identifiziert werden ist die Verwendung einer datenbankeigenen Id reduntant,
außerdem kann die UUID verwendet werden um den Pfad der Bilddatei im Dateisystem
zu berechnen, solange dieser systematisch in Abhängigkeit von der UUID erzeugt
wird, sodass das Speichern des Dateipfads ebenfalls reduntant ist. Das Ergebnis
ist in der Tabellengruppe ``image\_O2'', ``author\_O2'' und ``licence\_O2'' zu
sehen. Da das Abrufen aller Metadaten die häufigste Operation ist, lohnt es sich
die Tabellengruppe zu denormalisieren um diese Operation ohne das zusammenführen
mehrer Tabellen auszuführen zu können. Das Schema der resultierenden Tabelle ist
in der Abbildung unter ``image\_O3'' zu sehen. Da das Projekt zum aktuellen
Zeitpunkt noch Sqlite verwendet, ist diese Tabelle ausgelagert in eine JSON
Datei im Bilderordner ausgelagert um die Last auf der Datenbank zu verringern.

\subsubsection{Schemaeditorintegration}



\subsubsection{Queryeditorintegration}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% End:
