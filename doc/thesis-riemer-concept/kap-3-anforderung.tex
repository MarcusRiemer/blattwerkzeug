\section{Anforderungsanalyse}
\label{sec:requirements}

Dieses Kapitel beschreibt die generellen Anforderungen an die Entwicklungsumgebung. Dabei werden auch einige theoretische Hintergründe betrachtet, speziell mögliche Reduktionen des \texttt{SQL}-Sprachumfangs für die Vermittlung von Datenbankkenntnissen. Ebenfalls thematisiert werden unterschiedliche Vorgehensweisen, um Schüler bei der Entwicklung von Oberflächen sinnvoll anzuleiten. Den Schwerpunkt bildet die Beschreibung der beiden wichtigsten Komponenten der Entwicklungsumgebung: die spezialisierten Editoren für \texttt{SQL} und Oberflächen.

\warning[Hinweis]{Der Verzicht auf die technischen Hintergründe der Implementierung soll dieses Kapitel auch für Informatik-Interessierte ohne softwaretechnischen Hintergrund verständlich halten, anstatt die konzeptionellen Überlegungen mit den Details der Realisierung zu überlagern. Die Planung konkreter Umsetzungsstrategien und die Diskussion von softwaretechnischen Details, werden in Kapitel \fullref{sec:implementation-analysis} besprochen.}

\idename{} geht im Vergleich zu Scratch und dem App Inventor in Bezug auf die gelehrten Programmiersprachen einen anderen Weg: Es lehrt unmittelbar den Umgang mit \texttt{SQL} und \texttt{HTML} ohne dabei die Syntax zu verstecken, allerdings in gegebenenfalls reduzierten Umfängen (siehe \fullref{sec:sql-subset} und \fullref{sec:design-ui-concept}). Die Entwicklung eigener Programmier- oder Auszeichnungssprachen für die Lehre mag zwar die Einbindung spezieller didaktischer vorteilhafter Konzepte ermöglichen, geht im Rahmen dieser Arbeit aber auch mit zwei gravierenden Nachteilen einher: Zum Einen ist die Entwicklung einer konsistenten Programmiersprache alles andere als trivial (von zweien ganz zu schweigen); Zum Anderen erschwert eine solche Insellösung den Übergang zu "`richtiger"' Programmierung in der "`echten"' Welt außerhalb dieser Lehrumgebung. Abgesehen davon handelt es sich bei \texttt{SQL} und \texttt{HTML} um vergleichsweise einfache Sprachen, die sich darüber hinaus gut im Umfang reduzieren lassen. Aus diesen Gründen setzt \idename{} auf bestehende und etablierte Standards auf, anstatt eine Eigenentwicklung in Betracht zu ziehen.

Das in diesem Kapitel angestrebte Konzept wird aufgrund der Endlichkeit der im Rahmen einer Master-Thesis zur Verfügung stehenden Zeitspanne nicht vollständig umgesetzt werden können. Trotzdem ist eine möglichst vollständige Erfassung von Anforderungen unerlässlich, um bei Fortführung der Entwicklung nicht aufgrund von unberücksichtigten Anforderungen große Umbauarbeiten vornehmen zu müssen. Die Kapitel \fullref{sec:design-sql-editor} \& \fullref{sec:drag-drop-ui-editor} stellen streng genommen schon einen kleinen Vorgriff dar: Statt die Konzepte für die Gestaltung der Oberflächen nur zu beschreiben, zeigen sie vereinzelt Screenshots, die während oder am Ende der Entwicklung des Prototypen entstanden sind.

Da der Zweck dieser Arbeit die Konzeption und Umsetzung einer Software ist, deren Zweck wiederum die Entwicklung anderer Software ist, bedarf es zunächst eines einheitlichen Verständnisses für die Bezeichnungen der beteiligten Personen und Entitäten:

\begin{description}
\item[(Schüler-)Entwicklungsumgebung, \idename{}] \hfill\\
  Bezeichnet die von den Lernenden zu nutzende Software, die im Rahmen dieser Arbeit erstellt wird. Sofern Verwechslungen mit anderen Entwicklungsumgebungen (engl. ``integrated development environment'', IDE) auftreten könnten, wird explizit das Präfix ``Schüler'' genutzt. Diese Unterscheidung wird insbesondere bei Vergleichen mit gängiger Entwicklungssoftware relevant sein.
\item[(Schüler-)Projekt] \hfill\\
  Bezeichnet die von den Lernenden unter Nutzung der Schülerentwicklungsumgebung erstellte Software. Teil eines solchen Projektes sind unter anderem das Datenbankschema, die verschiedenen Abfragen und die gestaltete Benutzeroberfläche.
\item[Entwickler] \hfill\\
  Bezeichnet Personen, die mit der ``entwickelnden'' Benutzeroberfläche eines Schülerprojekts interagieren.
\item[Endanwender] \hfill\\
  Bezeichnet Personen, die mit der von den Entwicklern erstellten ``normalen'' Benutzeroberfläche eines Schülerprojekts interagieren, nicht jedoch mit der Schülerentwicklungsumgebung selbst.
\end{description}

\subsection{Zielgruppe}
\label{sec:target-audience}

Mit \idename{} sollen Schülerinnen ab der Mittelstufe angesprochen werden. Die im folgenden genannten Aspekte bilden ein sehr oberflächliches Profil hilfreicher Vorkenntnisse, an denen man sich als Lehrkraft für die Fragestellung "`Sind meine Schüler bereit für \idename{}?"' orientieren könnte. Dieses Profil ist dabei allerdings nicht als striktes Anforderungsprofil zu verstehen: Grundsätzlich lassen sich diese Kenntnisse auch am Beispiel von \idename{} vermitteln. Erfahrungen mit Datenbanken oder Webentwicklung sind hingegen nicht Bestandteil dieses Profils, schließlich versteht sich \idename{} als eine Lernumgebung für genau diese Technologien.

\begin{description}
\item[Grundlegende PC-Anwenderkenntnisse] \hfill\\
  Die Schüler müssen in der Lage sein, einen Browser zu bedienen und mit Begriffen wie "`Speichern"' und "`Klicken und Ziehen"' vertraut sein. Kenntnisse über Speicherorte im Dateisystem sind jedoch nicht notwendig, \idename{} abstrahiert die konkreten Speicherorte.
\item[Tabellenkalkulation] \hfill\\
  Kenntnisse über den Umgang mit Tabellenkalkulationsprogrammen sind keine zwingende Voraussetzung, aber eine sinnvolle Vorstufe, um die Strukturierungsmöglichkeiten von Datenbeständen zu verstehen. Sofern sich die Schüler innerhalb eines solchen Programms auch schon mit Funktionen wie \texttt{SUMME} beschäftigt haben, kann auf diesem Wissen aufgebaut werden.
\item[Bedienelemente] \hfill\\
  Wenn die Schüler mit \idename{} eigene Oberflächen entwickeln sollen, brauchen sie grundlegende Vorstellungen über die Funktionsweise und Parameter einiger Bedienelemente: Mit Links werden Inhalte verknüpft, Knöpfe lösen Aktionen aus, Textfelder stellen Werte zur Verfügung, eine Combobox erlaubt die Auswahl von einem Wert aus vielen Werten ... Ohne die mit einem Bedienelement durchgeführte Aktion zu verstehen, erschließt sich deren Verwendung in \texttt{HTML} nur sehr umständlich.
\item[Englische Vokabeln] \hfill\\
  In der initialen Version wird \idename{} die Syntax von \texttt{SQL} oder \texttt{HTML} zwar vereinfachen und augmentieren, aber nicht übersetzen. Den Schülern sollte die Bedeutung von Fragmenten wie \texttt{WHERE} oder \texttt{<input>} also geläufig sein.
\end{description}

\subsection{Grundprinzipien}
\label{sec:principles}

Nach der Betrachtung der zu bedienenden Zielgruppe und der Beschäftigung mit bereits existierenden Alternativen ist es zunächst sinnvoll ein paar allgemeine Grundprinzipien zu formulieren. Diese Prinzipien bilden die Philosophie hinter der Schülerentwicklungsumgebung ab und dienen als Leitfaden für Designentscheidungen. Praktisch erlaubt das vor allem eine relativ akkurate Abschätzung, ob sich die Implementierung einer bestimmten Idee lohnt und wie sie gegebenenfalls zu priorisieren ist. Die Sortierung dieser Prinzipien ist entsprechend ihrer Bedeutung absteigend sortiert, das wichtigste Prinzip wird also zuerst genannt.

\begin{description}
\item[Semantik vor Syntax] \label{principle:semantics}\hfill\\
  Den Lernenden sollen kontextsensitiv sinnvolle Operationen angeboten werden, optimalerweise mit einer kurzen Erläuterung, warum gerade nur diese Teilmenge an Operationen möglich ist. Die eigentliche Programmierung erfolgt dann durch die Kombination von Bausteinen, ähnlich wie bei der Lernsoftware "`Scratch"'. Durch kontinuierliches Feedback der Entwicklungsumgebung sollen die Lernenden in die Lage versetzt werden, auch ohne ständige Rückversicherung bei der Lehrkraft eigene Ansätze zu erproben. Syntaxfehler, ein typisches Problem für viele Anfänger, werden durch dieses Vorgehen konstruktiv verhindert.
\item[Motivation durch praktisch vorzeigbare Ergebnisse]\hfill\\
  Der Einstieg in die Programmierung ist oftmals von relativ langweiligen Programmen geprägt, häufig textbasierten Konsolenanwendungen, welche sich nicht gut im Freundes- oder Bekanntenkreis präsentieren lassen. Im Sonderfall der Vermittlung von \texttt{SQL}-Kenntnissen ist das Ergebnis der investierten Arbeit sogar überhaupt nicht sinnvoll zu demonstrieren. Die erstellten Abfragen stehen isoliert für sich und sind häufig auch nur in der Entwicklungsumgebung der jeweiligen Datenbank ausführbar. Mit der im Rahmen dieser Arbeit zu erstellenden Software sollen sich hingegen praktisch relevante, allerdings sehr datenorientierte Programme umsetzen lassen. Diese verfügen über von den Lernenden zusammengestellte Eingabemasken, um Daten einzufügen oder zu manipulieren sowie verschiedene Ausgabesichten, um den Datenbestand sinnvoll zu präsentieren.
\item[Schrittweise komplexere Benutzeroberfläche der Entwicklungsumgebung] \hfill \\
  Konventionelle Entwicklungsumgebungen sind Programme von Profis für Profis und bieten einen dementsprechend ausgerichteten Funktionsumfang. Gerade wenn man aber dabei ist etwas Neues zu lernen, kann es sinnvoll sein, die Menge der möglichen Optionen zu beschränken. In diesem Sinne sollte die Lehrkraft die Möglichkeit haben, den Funktionsumfang der Entwicklungsumgebung für Schüler gezielt zu reduzieren. Es sollten sich also Funktionen der Entwicklungsumgebung ausblenden lassen, wenn dies aus didaktischen Gründen sinnvoll erscheint. Zum Beispiel könnten bestimmte Bedienelemente oder Bestandteile von \texttt{SQL} ausgeblendet werden, wenn diese noch nicht behandelt worden sind. Dieser Ansatz die Oberfläche insgesamt anpassbar zu gestalten, wird auch von anderen Lernprogrammen verfolgt, zum Beispiel der Mathematik-Lernsoftware GeoGebra\footnote{\url{https://www.geogebra.org/manual/en/Tutorial:Custom\_Tools\_and\_Customizing\_the\_Toolbar}}.
\item[Einfache Inbetriebnahme] \hfill \\
  Eine initiale Hürde jeder (Lern-)Software ist deren Installation, insbesondere bei Programmen aus dem Datenbankumfeld. Die Inbetriebnahme der für Server konzipierten Programme auf privaten, "`normalen"' Rechnern führt immer wieder zu Problemen aufgrund von unerfüllten Abhängigkeiten, fehlenden Rechten beim Starten von Systemdiensten oder bei Dateizugriffen. Die zunehmende Heterogenität von Geräteklassen, also die Verbreitung von Smartphones und Tablets statt dem klassischen Desktop oder Laptop, und Betriebssystemen, insbesondere die zunehmende Verwendung von MacOS\footnote{\url{http://de.statista.com/statistik/daten/studie/158102/}}, tut ein Übriges, um die Verteilung von Software zu erschweren. Damit der eigentliche Lernprozess nicht schon vor dem Start der Entwicklungsumgebung behindert wird, ist eine möglichst einfache Inbetriebnahme von entsprechender Bedeutung. Die Informatiklehrkräfte stehen bei dem Betrieb der jeweiligen Programme in der Schule vor ähnlichen Problemen wie ihre Schüler, nur dass sie zusätzlich auf die Konfiguration des Rechnerpools ihrer Schule oftmals nur einen eingeschränkten Einfluss haben. Die im Vergleich zu privaten Rechnern wesentlich restriktiver gehandhabten Rechte eines Schul-PCs verkomplizieren dieses Szenario zusätzlich. Damit der Lernprozess mit \idename{} nicht schon mit einer fehlgeschlagenen Installation endet, soll der initiale Kontakt so wenig Hürden wie möglich aufstellen.
\item[Fortführung der entwickelten Projekte] \hfill \\
  Lernumgebungen wie Scratch oder der AppInventor sind in sich geschlossene Systeme, deren Arbeitsergebnisse nur schwer in anderen Programmen oder Kontexten von Nutzen sind. Sobald der Lernende dann die Grenzen der verwendeten Lernsoftware erreicht hat, steckt er in einem Dilemma: Es wäre notwendig, auf eine andere Software auszuweichen, in diese kann er sein bestehendes Projekt aber nicht einfach mitnehmen. Die Arbeitsergebnisse dieser zu entwickelnden Software sollen daher zumindest einfach einsehbar sein, optimalerweise nach einem Export sogar mit gängigen Entwicklungsumgebungen oder Texteditoren erweiterbar.
\end{description}

\subsection{Künftigen Erweiterungen vorbehalten}
\label{sec:out-of-scope}

Neben der Formulierung von klaren Grundprinzipien als Richtline für relevante Funktionen ist es auch wichtig, den Umfang des zu entwickelnden Programms auf eine im Rahmen der Thesis machbare Teilmenge zu beschränken. Die folgenden Ideen wären naheliegende Ergänzungen, welche aufgrund der zur Verfügung stehenden Zeit aber zunächst nicht implementiert werden sollen\footnote{Die griffigere, englische Bezeichnung dafür wäre "`out of scope"', dazu kennt allerdings auch das Internet keine direkte Übersetzung: \url{http://german.stackexchange.com/questions/31085/}}. Der Zweck dieser Master-Thesis ist "`lediglich"' die Implementierung eines Prototypen. Die Fertigstellung von \idename{} soll im Rahmen weiterer Arbeiten erfolgen und die im Folgenden geäußerten Ideen werden dann erneut evaluiert.

\begin{description}
\item[Datenmodellierung] \label{scope:no-data-modelling} \hfill \\
  Der Schwerpunkt dieser Arbeit liegt zunächst auf der Vermittlung von Kenntnissen zur Abfrage und Manipulation von Daten in einem bestehenden Schema. Änderungen an diesem Schema sind nicht vorgesehen, demzufolge ist auch der Neuentwurf eines Schemas mit externen Mitteln zu bewerkstelligen.
\item[Aufwändiges Design von Benutzerschnittstellen] \label{scope:no-design} \hfill \\
  Auch wenn die Konzeption der Benutzerschnittstelle für die verschiedenen Masken in den eben aufgezählten Prinzipien auftaucht, ist es wichtig, den engen Rahmen dieses Aspektes zu verstehen. Es geht um die Schaffung von einfachen, datenzentrierten Eingabemöglichkeiten, nicht um die Umsetzung besonders kreativer optischer Feuerwerke. Dementsprechend ist z.B. die Erweiterung der zur Verfügung stehenden Eingabeelemente durch die Lernenden außerhalb des Rahmens dieser Arbeit. Technisch gesehen schließt dieses Kriterium die Unterstützung von \texttt{CSS} oder JavaScript innerhalb von \idename{} im Rahmen dieser Arbeit aus.
\item[Serverseitige Programmierung mit typischen Programmiersprachen] \label{scope:no-programming} \hfill \\
  Auch wenn \idename{}-Anwendungen grundsätzlich interaktiv sein sollen, ist diese Interaktivität in einem sehr engen Rahmen zu sehen. Für die Darstellung der Oberfläche könnten zwar Kontrollstrukturen wie Schleifen oder Verzweigungen zum Einsatz kommen, diese operieren aber stets auf einem während des Rendervorgangs unveränderlichen Datenbestand. Die einzige Möglichkeit zur Veränderung von Daten zur Laufzeit ist die Verwendung von mutierenden \texttt{SQL}-Anweisungen, klassische Zuweisungen finden nicht statt.
\end{description}

\subsection{Allgemeines Konzept der Entwicklungsumgebung}
\label{sec:design-general-concept}

Dieses Kapitel beschreibt das Konzept hinter \idename{}, ohne dabei jedoch auf die spezifischen Editoren für \texttt{SQL} oder Webseiten einzugehen.

Die Oberfläche orientiert sich dabei grundsätzlich an der typischen Dreiteilung einer Entwicklungsumgebung (Abbildung~\ref{fig:ui-sketch-general}). Der Dateibaum bietet jederzeit Zugriff auf alle Inhalte des aktuellen Projekts und ist in der Darstellung unabhängig von dem aktuell zu bearbeitenden Element.

\begin{figure}[h]
  \centering \includegraphics[width=\textwidth]{sketches/kap-3-general-editor-ui.png}
  \caption{Dreispaltiges Layout, ähnlich einer normalen Entwicklungsumgebung.}
  \label{fig:ui-sketch-general}
\end{figure}

Der größte Bereich steht den jeweiligen Editoren zur Verfügung. Deren Gestaltung ist dabei Gegenstand eigener Kapitel (\fullref{sec:design-sql-editor} \& \fullref{sec:drag-drop-ui-editor}). Die so genannte "`Toolbox"' bietet zu dem aktuell geladenen Editor kontextuell passende Optionen an. Dabei soll es grundsätzlich möglich sein, die in der Toolbox angebotenen Optionen per Drag \& Drop im Editorbereich zu verwenden.

Darüber hinaus existieren für jeden Editor spezielle Aktionen, welche über einen Knopfdruck oder auch ein Tastaturkürzel ausgelöst werden können. Diese Aktionen werden oberhalb der Editorfläche in einer typischen "`Toolbar"' angezeigt. Einige Aktionen, zum Beispiel "`Speichern"' mit dem Kürzel \texttt{STRG} + \texttt{S}, stehen dabei in allen editierbaren Kontexten zur Verfügung. Eine Sonderrolle nimmt dabei die Löschfunktion ein: Immer wenn in einem beliebigen Editor eine Drag-Operation beginnt, kann diese auf einem in der Toolbar angezeigten Mülleimer beendet werden.

Grundsätzlich unterschieden wird bei der Schülerentwicklungsumgebung, ähnlich wie bei Scratch, zwischen zwei Blickwinkeln auf das jeweilige Projekt: Zunächst wird ein Projekt im Entwicklermodus editiert, in diesem Fall stehen dem Benutzer alle Entwicklungstools zur Verfügung. Wenn es dann später einmal fertig ist und an Endanwender, z.B. Bekannte oder Freunde, weitergegeben wird, erwarten diese natürlich eine normale Benutzeroberfläche.

Der Wechsel zwischen diesen beiden Modi sollte dabei, ebenfalls analog zu Scratch, zu jedem Zeitpunkt möglich sein. Der Weg von der Entwicklungsumgebung zum Programm ist dabei selbsterklärend: Im Rahmen einer Vorschaufunktion müssen sich die erstellten Seiten jederzeit anzeigen lassen. Aber auch der "`Rückweg"' von einer speziellen Seite der Endbenutzeroberfläche zur Entwicklungsumgebung ist inhaltlich sinnvoll. So kann man sich als Lernender die Herangehensweise einer speziellen Seite in einem anderem Projekt anschauen. Das "`Verstecken"' von Quelltexten hingegen ist im Lehrbetrieb nicht sinnvoll und daher auch nicht vorgesehen. Jedes fremde Projekt soll auch als Inspiration für die Umsetzung eigener Ideen dienen können.

\subsubsection{Webanwendung}
\label{sec:req-web-application}

Um die einfachste Verwendung der Software für Lernende zu gewährleisten, wird \idename{} als Webanwendung entwickelt. Für die ersten Schritte der Softwareentwicklung mit SQL reicht auf Seite der Lernenden dann ein beliebiger, aktueller Browser. Wie aus Kapitel \fullref{sec:related-work} ersichtlich, befindet sich \idename{} mit diesem Ansatz in guter Gesellschaft: Das "`große Vorbild"' Scratch ist über den Browser erreichbar, genau so wie auch die anderen explizit als Lernsoftware beschriebenen Anwendungen.

Selbstverständlich muss eine Entscheidung mit einer solchen Tragweite dennoch gut abgewogen werden. Dass vergleichbare Arbeiten sich ebenfalls für diesen Ansatz entschieden haben ist zwar ein starkes Indiz, isoliert betrachtet aber natürlich keine stichhaltige Begründung. Immerhin existiert von Scratch auch eine lokal installierbare Fassung, welche der Entwicklung der Webversion allerdings leicht hinterherhinkt\footnote{\href{https://scratch.mit.edu/scratch2download/}{Scratch Download-Seite: "The backpack is not yet available."}}.

Praktisch bedeutet dieser Ansatz vor allem eine Verschiebung der Probleme mit der Inbetriebnahme auf die Lehrperson. Bei der Konzeption von \idename{} wird davon ausgegangen, dass die Bereitstellung eines Serverdienstes in Zeiten von Virtualisierungs- und Containerumgebungen für Informatik-affine Lehrkräfte keine nennenswerte Hürde mehr darstellt.

Ebenfalls aus Gründen der einfacheren Zugänglichkeit sollte eine einzelne Serverinstanz in der Lage sein, mehrere Projekte simultan zu bedienen. Die Lehrperson kann also mit einem einzigen Serverprozess eine ganze Klasse versorgen. Eine Begleiterscheinung dieses zentralen Angebots ist allerdings die notwendige Implementierung von zumindest rudimentären Zugriffsbeschränkungen: Im Normalfall sollen Schüler die Projekte ihrer Klassenkameraden zwar jederzeit begutachten, aber nicht modifizieren können. Würde die Entwicklungsumgebung von den Schülern lokal betrieben, entfiele die unmittelbare Notwendigkeit einer Zugriffsbeschränkung.

Durch den Betrieb eines zentralen Servers für die Projekte der Schüler entfällt auch eine weitere typische Problemquelle im Unterrichtsalltag: Sofern der Server tatsächlich durchgehend betrieben wird, ist es sehr einfach auch von Zuhause aus an den Projekten weiter zu arbeiten. Die Notwendigkeit, manuell Dateien über \texttt{USB}-Sticks, Netzlaufwerke oder sonstige Dienste zu synchroniseren, entfällt.

Ein weiterer Vorteil eines zentralen Servers ergibt sich in der praktischen Vorzeigbarkeit der eigenen Ergebnisse: Durch einfache Weitergabe der \texttt{URL} für Endbenutzer können die Lernenden ihre entwickelten Applikationen mit Eltern, Freunden und anderen Personen teilen.

Nicht verschwiegen werden sollen allerdings auch die negativen Nebeneffekte dieser grundsätzlichen Entscheidung: Zunächst einmal wird dadurch ein eigenständiger Betrieb der Entwicklungsumgebung durch Schüler deutlich erschwert. Diese müssten auf ihrem eigenen Rechner plötzlich doch eine Server-Instanz betreiben, anstatt einfach ein Programm zu starten. Faktisch wird die Bereitstellung einer dedizierten Umgebung für den Server also zur Pflichtaufgabe der jeweiligen Lehrperson. Vom Betrieb eines dedizierten Servers in der Schule über die Verwendung eines "`privat greifbaren"' Servers der Lehrperson bis hin zur Verwendung einer Cloud-Computing-Instanz im Internet sind unterschiedlichste Szenarien denkbar. Der erfolgreiche Einsatz von \idename{} hängt in der Praxis dann aber auch maßgeblich von der Verfügbarkeit dieses Serverdienstes ab.

Softwaretechnisch nachteilig ist die Tatsache, dass \idename{} im Falle einer Entwicklung als "`traditionelle Desktopawendung"' auf ein großes Ökosystem aus bestehenden Entwicklungsumgebungen zurückgreifen könnte. Jede größere Entwicklungsumgebung (Eclipse, Visual Studio, ...) bietet eine Plugin-Schnittstelle, auf die man mit \idename{} hätte aufsetzen können. Ähnlich gut erprobte Umgebungen für Browser gibt es hingegen leider nicht, es müssen daher relativ viele technische Kleinigkeiten (Toolbars, Projektbrowser, ...) extra für \idename{} entwickelt werden.

\subsubsection{Projektbasiert}

Der Begriff des "`Projekts"' ist schon einige Male ohne exakte Definition verwendet worden, diese wird daher an dieser Stelle nachgeholt. Abstrakt betrachtet handelt es sich bei einem Projekt um eine Datenbasis in Form einer Datenbank. Zu dieser Datenbasis kann man als Entwickler SQL-Abfragen entwickeln (\fullref{sec:design-sql-editor}) und einige dieser Abfragen mit einer Oberfläche für Endbenutzer versehen (\fullref{sec:drag-drop-ui-editor}).

Als unmittelbarer Ausgangspunkt eines Projektes dienen einfache, beliebige SQLite-Datenbanken\footnote{Kapitel \fullref{sec:implementation-database-system} erläutert, warum ausgerechnet SQLite zum Einsatz kommt und nicht ein anderes Datenbanksystem.}. Deren Schemata werden vorher mit externen Programmen erzeugt, was sowohl im Dialog mit den Schülern als auch "`einfach so"' erfolgt sein kann.

Im Sinne einer möglichst niedrigen Einstiegshürde soll es den Anwendern leicht gemacht werden, bestehende Projekte zu übernehmen. Zu Beginn müssen im Informatikunterricht häufig bestimmte Schritte ausgeführt werden, "`weil das nun mal so ist"' (also eine ausführliche Erklärung zu diesem Zeitpunkt zu weit gehen würde). Im Falle des Sprach\-umfangs von SQL ist das zwar im Vergleich zu z.B. Java nicht ganz so drastisch\footnote{"`Herr Lehrer, was macht eigentlich dieses \texttt{public static void}?"'}, aber nach Möglichkeit zu vermeiden. Dementsprechend sollte normalerweise jeder Schritt beim Anlegen eines neuen Projektes für die Schüler nachvollziehbar sein. Wenn dann aber doch einmal eine Serie von mechanisch auszuführenden Anweisungen erforderlich sein sollte, wäre es dennoch praktisch, diesen Vorgang durch eine Kopie eines schon bestehenden Projektes abzukürzen.

Die Lehrkraft würde in diesem Fall ein Projekt für die Schüler vorbereiten, welches diese dann mit einem Klick in ein anders benanntes Projekt kopieren können. Es werden dann im Normafall alle Bestandteile, möglicherweise mit einer einfachen Anpassung der Zugriffsrechte, unter dem neuen Namen verfügbar gemacht. Alternativ sollte eine Lehrkraft den Umfang eines solchen Klons auch einschränken können: Sofern das Beispielprojekt Inhalte enthält, die nur zu Illustrationszwecken angelegt worden sind, können diese ausgeschlossen werden. Eventuell sollen sich die Schüler auch verstärkt eigene Gedanken machen und nicht zu sehr von vorgefertigen Inhalten abgelenkt werden? Letzten Endes existieren zu viele Varianten, um den korrekten Umfang für diese Kopien ohne manuelle Unterstützung festlegen zu können.

\subsubsection{Zugriffskontrollen}
\label{sec:concept-access-control}

Lesende Zugriffe können, zumindest in der Thesis-Version der Software, nicht endgültig eingeschränkt werden. Ursächlich dafür ist jedoch anders als bei vielen anderen nicht implementierten Funktionen nicht vornehmlich der technische Aufwand: Natürlich könnte man theoretisch typische Entwurfsmuster für Zugangsbeschränkungen auch in \idename{} implementieren. Auf einfachster Ebene wäre zum Beispiel denkbar, dass eine Spalte "`geheim"' zu Tabellen mit privaten Daten hinzugefügt wird und auf dieser Basis die Oberfläche für Endanwender solcherart markierte Daten nicht anzeigt.

Da Projekte aber auch einfach kopiert werden können, müsste ein versierter Benutzer nur eine Kopie des Projektes vornehmen und könnte dann über den Editor alle Daten einsehen oder auch den Zugriffschutz der Oberflächen einfach deaktivieren. Um also den lesenden Zugriff effektiv zu verhindern, müsste die Einsicht in die Quellen fremder Projekte eingeschränkt werden.

Prinzipiell wäre es mit entsprechendem Zeitaufwand möglich, ein hinreichend sicheres System für den speziellen Anwendungsfall von \idename{} zu entwerfen. Dieser Aufwand wäre jedoch, im Vergleich zu anderen Features nicht zu rechtfertigen und stünde der Zielstellung "`Jedes Projekt soll als Grundlage für neue Projekte dienen können"' obendrein diametral gegenüber. Abgesehen davon sollte kein Schüler einem \idename{}-Server Daten anvertrauen, deren versehentliche Veröffentlichung er oder sie nicht verkraften würde. Das gilt selbstverständlich auch für den Fall, dass eine hypothetische künftige Version einen solchen Zugriffsschutz vorsehen sollte!

Schon um Vandalismus zu vorzubeugen, sind dennoch einfache Zugriffskontrollen für \textbf{schreibende Zugriffe} auf Projektebene nötig. Um etwaige Missverständnisse von vornherein zu vermeiden: Ziel dieser Kontrollen ist es zu verhindern, dass z.B. die Quellen für die Abfragen oder Benutzeroberfläche eines Projektes entstellt oder gelöscht werden. Dabei muss es sich nicht einmal um bösartigen Vandalismus handeln. Bei ungeschickt programmierten Webseiten kann es durchaus passieren, dass Webcrawler Datenbestände vernichten. Mehr als einen schlecht programmierten "`Diesen Datensatz Löschen"'-Link auf einer Übersichtsseite braucht es dazu nicht. Der Webcrawler folgt unter Umständen auch solchen Verweisen und löscht damit während der Indexierung unbeabsichtigt Datensätze.

\textbf{Nicht geschützt} werden damit einzelne Datensätze, also die Zeilen, in der Datenbank. Sobald in der Benutzeroberfläche für Endanwender Funktionalität zum Löschen oder Editieren von Datensätzen vorgesehen ist, gibt es keine einfache Möglichkeit, legitime Veränderungen von unerwünschtem Vandalismus zu unterscheiden. Daher wird zunächst nur eine sehr einfache, binäre Klassifikation in zwei Benutzergruppen vorgenommen: "`Darf jede mutierende Operation ausführen"' oder "`darf ausschließlich lesen"'. In einer späteren Version wäre es dann denkbar, diese sehr grobe Unterscheidung zu verfeinern.

Sowohl für den lesenden als auch für den schreibenden Zugriff gilt darüber hinaus: Eine komplexe, aber unausgereifte Lösung für eine so kritische Funktionalität würde im Extremfall mehr Schaden anrichten als nützen. Eine unsicher implementierte Sicherheitsfunktion suggeriert möglicherweise ein Schutzniveau, welches praktisch nicht eingehalten wird. Also werden Ansätze wie "`Vergabe von Schreibrechten für einzelne Abfragen an bestimmte Benutzergruppen"' oder sogar ein zeilenweiser Schutz von Daten ("`Jeder Benutzer darf nur seine Daten bearbeiten"') aus Zeitgründen im Rahmen dieser Thesis nicht weiter betrachtet.

Um also zumindest einen grundsätzlichen Schutz zu ermöglichen, sollte für ein Projekt zwischen drei schreibenden Zugriffsarten für angelegte Benutzer gewählt werden können:

\warning{Nur zur Sicherheit sei an dieser Stelle nochmals deutlich erwähnt, dass dieser Schutz nur für schreibende Zugriffe greift. Der lesende Zugriff auf den gesamten Datenbestand ist über die Entwicklungsumgebung auch für Gäste stets uneingeschränkt möglich.}

\begin{description}
  \item[Entwickler] \hfill \\
    Mit diesem Zugangslevel hat ein legitimierter Benutzer das Recht, beliebige Änderungen an dem Projekt vorzunehmen. Dabei ist es egal, ob er mit der Entwicklungsumgebung oder der Oberfläche für Endbenutzer arbeitet.
  \item[Benutzer] \hfill \\
    Diese Personengruppe hat keine Möglichkeit, den Quelltext eines Projektes zu editieren, kann aber uneingeschränkt auf die Funktionalität der Oberfläche für Endbenutzer zugreifen. Sofern z.B. das Löschen von bestimmten Datensätzen über die Oberfläche für Endbenutzer möglich ist, können diese Daten von dieser Personengruppe im Rahmen der bereitgestellten Abfragen auch uneingeschränkt gelöscht werden. Wenn hingegen keine mutierenden Operationen über die Oberfläche für Endbenutzer bereitgestellt werden, können auch keine Daten bearbeitet werden.
  \item[Gast] \hfill \\
    Gäste können keinerlei Schreibzugriffe vornehmen, weder über die Entwicklungsumgebung, noch über die Oberfläche für Endbenutzer.
\end{description}

\subsubsection{Unterschiedliche Versionen eines Editors}
\label{sec:editor-different-versions}

Wenn ein Anwender der Entwicklungsumgebung an die Grenzen des unterstützenden Editors stößt, sollte er die Möglichkeit haben, einmalig für eine konkrete Abfrage oder Seite eine Umwandlung in eine textbasierte Darstellung vornehmen zu können. Der umgekehrte Weg, also zum Beispiel der Import von beliebigen \texttt{SQL}-Abfragen in den grafischen Editor, ist dann jedoch nicht mehr möglich. Die Implementierung eines Parsers für die Umwandlung der textuellen Repräsentation in die interne Darstellung von \idename{} würde im Verhältnis zum marginalen Nutzen einen unverhältnismäßigen Aufwand bedeuten.

Diese unterschiedlich fortgeschrittenen Sichtweisen und Bearbeitungsmöglichkeiten auf jede Ressource, erlauben es \idename{} auch mit weiter fortgeschrittenem Kenntnisstand effektiv zu nutzen. Dieser Umstand wird vor allem durch die Entscheidung zugunsten von Standardtechnologien anstatt eigens entwickelten Sprachen möglich gemacht. Für Scratch existiert zum Beispiel keine rein textuelle Darstellung mit erweitertem Funktionsumfang. Durch den \texttt{SQL}- bzw. \texttt{HTML}-Unterbau von \idename{} stehen fortgeschrittenen Anwendern hingegen sehr mächtige Standardtechnologien zur Verfügung.

\subsection{Konzept für sinnvolle Teilmengen von \texttt{SQL}}
\label{sec:sql-subset}

Die uneingeschränkte Umsetzung des \texttt{SQL}-Standards würden sowohl für den Verfasser dieser Thesis als auch für die Anwender der Entwicklungsumgebung viele unpraktische Probleme aufwerfen. Der \texttt{SQL}-Sprachumfang ist mittlerweile gewaltig und die Anzahl der verschiedenen Dialekte unüberschaubar groß. Varianten wie Transact-\texttt{SQL} bieten die Möglichkeit, zur Laufzeit mit Schleifen, Fallunterscheidungen und Variablen zu arbeiten und erfüllen damit alle Kriterien für \textsc{Turing}-Vollständigkeit. Darüber hinaus werden "`echte"' Entwicklungsumgebungen für \texttt{SQL} von großen Entwicklerteams konzipiert und programmiert, der Autor dieser Arbeit bildet hingegen ein Ein-Mann-Team.

\warning{Nicht alle hier beschriebenen Optionen sind notwendigerweise in dem Prototypen implementiert! Dieses Kapitel ist eine \textit{allgemeine} Betrachtung von didaktisch sinnvollen Teilmengen von \texttt{SQL}. Um zu sehen, welcher Funktionsumfang im Prototypen tatsächlich verfügbar ist, lohnt sich ein Blick in \fullref{sec:conclusion} und den Anhang \fullref{sec:project-examples}.}

Zusätzlich wäre aber auch der Zielgruppe dieser Entwicklungsumgebung mit einer vollständigen Umsetzung des \texttt{SQL}-Standards überhaupt nicht gedient. Im Gegensatz zu anderen vorhandenen Entwicklungsumgebungen soll die Stärke dieser Entwicklungsumgebung in einer sinnvollen Reduktion liegen. Dieses Kapitel beschreibt daher, wie man zum "`normalen"' \texttt{SQL} kompatible Untermengen definieren kann, um einige spezifische Aufgaben zu erfüllen. Oder in Anlehnung an die "`80/20"'-Regel ausgedrückt: Es gilt, jene 20\% des Sprachumfangs abzubilden, mit denen sich 80\% der typischen Aufgaben gut lösen lassen. Vor diesem Hintergrund dient dieses Kapitel also ebenfalls als Grundlage für die Entscheidung bezüglich des Umfangs, mit dem der \texttt{SQL}-Editor im Rahmen dieser Arbeit als "`abgeschlossen"' betrachtet wird (siehe \fullref{sec:sql-subset-ranks}).

Bei einer gängigen Programmiersprache wie z.B. Java bauen die einzelnen Sprachfeatures sehr viel stärker aufeinander auf, es ergeben sich deutlich weniger Reihenfolgen, in denen man diese sinnvoll aktivieren könnte. Die wesentlich größere Standardbibliothek einer solchen Sprache trägt dann ebenfalls dazu bei, die Suche nach voneinander weitestgehend unabhängig funktionierenden Teilsprachen zu erschweren.

Glücklicherweise erlaubt die Struktur von \texttt{SQL} die Verwendung von sehr lokalen Einschränkungen, deren Auswirkungen sich gut abschätzen lassen. Einzig der Umgang mit Ausdrücken überspannt fast alle Bereiche von \texttt{SQL}: Diese können an sehr vielen Stellen auftreten und müssen dementsprechend sorgfältig analysiert werden. Durch diese vergleichsweise überschaubaren Abhängigkeiten ergeben sich viele mögliche Reihenfolgen in denen man Sprachfeatures aktivieren kann. 

Es ist nicht im Sinne von \idename{}, diese unterschiedlichen Reihenfolgen implizit zu bewerten, in dem eine "`beste"' Variante fest eingebaut wird. Viel mehr sollen die Lehrkräfte in die Lage versetzt werden, je nach verwendetem Lehrmaterial zu entscheiden, welcher Umfang zum Umgang mit diesem angemessen ist. Dieses Kapitel klärt daher zunächst, welche Features von \texttt{SQL} überhaupt für die Entwicklungsumgebung von Belang sind und wie diese voneinander abhängen.

\subsubsection{Mögliche Einschränkungen der Komponenten}
\label{sec:sql-subset-local}

Die folgende Beschreibung untersucht zunächst nur die Komponenten einer \texttt{SELECT}-Suchanfrage. Diese sind im Gegensatz zu \texttt{DELETE}, \texttt{UPDATE} und \texttt{INSERT} nicht auf eine Tabelle beschränkt und auch von der schieren Anzahl der verfügbaren Optionen her deutlich mächtiger.

Zunächst definieren wir einige mögliche Einschränkungen anhand der grundlegenden Struktur jeder suchenden \texttt{SQL}-Abfrage. Da die Reihenfolge der Komponenten nicht beliebig ist, ergibt sich eine sehr klare Struktur in der einige Komponenten allerdings auch übersprungen werden können. Abbildung~\ref{fig:sql-steps} wurde aus den Vorlesungsunterlagen von Prof. Hoffmann entnommen und demonstriert den logischen Ablauf bei der Verarbeitung einer \texttt{SQL}-Abfrage inklusive aller Zwischenschritte und optionaler Komponenten. Daraus ist gut ersichtlich, dass alle Komponenten einer Suchanfrage bis auf die logisch Erste (\texttt{FROM}) und Vorletzte (\texttt{SELECT}) optional sind.

\begin{figure}
  \centering \includegraphics{images/sql-steps.png}
  \caption{%
    \texttt{SQL}-Komponenten und sich ergebende Zwischenschritte bei der Verarbeitung einer \texttt{SQL}-Abfrage%
    \\\hspace{\linewidth}%
    \textbf{Quelle:} Vorlesung \href{http://www.fh-wedel.de/fileadmin/mitarbeiter/uh/WS201516/Datenbanken_04.pdf}{\enquote{Einführung in Datenbanken}} von Prof. Ulrich Hoffmann, Folie 19}
  \label{fig:sql-steps}
\end{figure}

Einige der im Folgenden beschriebenen Optionen sind redundant. Das liegt zum Einen an \texttt{SQL} selbst, die Sprache sieht schlichtweg mehrere syntaktische Varianten für semantisch äquivalente Sachverhalte vor. Zum Anderen könnte es aber auch aus didaktischen Gründen sinnvoll sein, die Wissensvermittlung mit einer Reihe von Spezialfällen zu beginnen. Die folgenden Aufzählungen gruppieren die möglichen Optionen für die jeweiligen Komponenten.

\begin{enumerate}
\item \textbf{Projektionen mit \texttt{SELECT}} \\
  Diese Komponente kann für Suchabfragen nicht ausgeschlossen werden. Außerdem muss mindestens \ref{feat:select-all} $\lor$ \ref{feat:select-column} erlaubt sein, sonst können keine gültigen \texttt{SQL}-Abfragen erstellt werden.
  \begin{enumerate}[noitemsep]
  \item \label{feat:select-all} Auswahl aller Spalten ("`Sternchen-Operator"' \texttt{SELECT *})
  \item \label{feat:select-column} Auswahl von Spalten
  \item \label{feat:select-single-function} Ausdrücke aus einfachen Funktionsaufrufen zulassen
  \item \label{feat:select-simple-expression} Einfache Ausdrücke zulassen
  \item \label{feat:select-expression} Beliebige Ausdrücke zulassen
  \item \label{feat:select-distinct} Filterung des Ergebnisses auf unterscheidbare Daten (\texttt{DISTINCT}).
  \item \label{feat:select-limit} Beschränkung der Datenmenge mit \texttt{LIMIT}
  \end{enumerate}
\item \textbf{Angabe von Tabellen mit \texttt{FROM}} \\
  Diese Komponente ist im Normalfall für alle Arten von Abfragen notwendig, obwohl einige \texttt{SQL}-Dialekte die Auslassung erlauben. Im Rahmen von \idename{} wird dies aber nicht unterstützt: Die Schüler sollen \texttt{SQL} Abfragen grundsätzlich auf Tabellen beziehen und keine Daten "`aus der Luft greifen"'\footnote{Für Oberflächen werden manchmal noch globale Konstanten benötigt, zum Beispiel der Name des Projektes selbst. Diese Werten kommen dann aber nicht aus der \texttt{SQL}-Schicht (siehe \fullref{sec:page-data-sources}).}.
  \begin{enumerate}[noitemsep]
  \item \label{feat:from-cross-join} Kreuzprodukt (\texttt{JOIN}) zulassen
  \item \label{feat:from-cross-comma} Kreuzprodukt (komma-separierte Schreibweise) zulassen
  \item \label{feat:from-natural-join} Automatische innere Verknüpfung zulassen (\texttt{NATURAL JOIN})
  \item \label{feat:from-inner-join} Innere Verknüpfung zulassen (\texttt{INNER JOIN}), erfordert \ref{feat:from-using} $\lor$ \ref{feat:from-on-simple}
  \item \label{feat:from-left-join} Linke äußere Verknüpfung zulassen (\texttt{LEFT OUTER JOIN}), erfordert \ref{feat:from-using} $\lor$ \ref{feat:from-on-simple}
  \item \label{feat:from-right-join} Rechte äußere Verknüpfung zulassen (\texttt{RIGHT OUTER JOIN}), erfordert \ref{feat:from-using} $\lor$ \ref{feat:from-on-simple}
  \item \label{feat:from-full-join} Volle äußere Verknüpfung zulassen (\texttt{FULL OUTER JOIN}), erfordert \ref{feat:from-using} $\lor$ \ref{feat:from-on-simple}
  \item \label{feat:from-using} \texttt{USING}-Bedingung zulassen
  \item \label{feat:from-on-simple} \texttt{ON}-Bedingung mit einfachen Ausdrücken zulassen
  \item \label{feat:from-on-expression} \texttt{ON}-Bedingung mit beliebigen Ausdrücken zulassen
  \item \label{feat:from-sub} Unterabfragen zulassen
  \end{enumerate}
\item \textbf{Filterung mit \texttt{WHERE} und \texttt{HAVING}} \\
  Da an dieser Stelle Ausdrücke zum Einsatz kommen, sind prinzipiell zwei unterschiedliche Ansätze denkbar. Zum einen die Verwendung einer vordefinierten Menge an Vergleichen mit einer einfachen Struktur, diese werden in \fullref{sec:sql-subset-expression} beschrieben. Dem gegenüber steht der Ansatz, fast beliebige Ausdrücke zu erlauben. Diese sehr mächtige Variante hat zwar die größte Ausdruckskraft, könnte Lernende aber auch mit einem zu großen Freiheitsgrad überfordern.
  \begin{enumerate}[noitemsep]
  \item \label{feat:where-allow} \texttt{WHERE} zulassen
  \item \label{feat:having-allow} \texttt{HAVING} zulassen
  \item \label{feat:where-and} Verknüpfungen mit \texttt{AND}
  \item \label{feat:where-or} Verknüpfungen mit \texttt{OR}
  \item \label{feat:where-simple-expression} Einfache Ausdrücke zulassen
  \item \label{feat:where-expression} Beliebige Ausdrücke zulassen
  \end{enumerate}
\item \textbf{Bildung von Gruppen mit \texttt{GROUP BY}}
  \begin{enumerate}[noitemsep]
  \item \label{feat:group-allow} \texttt{GROUP BY} zulassen
  \item \label{feat:group-multiple} Gruppierung mehrerer Spalten zulassen
  \end{enumerate}
\item \textbf{Sortierung mit \texttt{ORDER BY}} \\
  Bei dieser Komponente fehlt bewusst die Möglichkeit anhand eines Spaltenindexes aus dem \texttt{SELECT} zu sortieren. Da die gute Lesbarkeit der Abfragen ein erklärtes Ziel der Entwicklungsumgebung ist, wurde auf diese redundante Möglichkeit der Spaltenauswahl verzichtet.
  \begin{enumerate}[noitemsep]
  \item \label{feat:order-allow} \texttt{ORDER BY} zulassen, die Auswahl der Richtung (\texttt{ASC} und \texttt{DESC}) ist dann grundsätzlich möglich
  \item \label{feat:order-select} Sortierung nach im \texttt{SELECT} erwähnten Spalten oder Ausdrücken zulassen
  \item \label{feat:order-any-column} Sortierung nach beliebigen Spalten zulassen
  \item \label{feat:order-expression} Sortierung anhand eines beliebigen Ausdrucks zulassen
  \end{enumerate}
\end{enumerate}

\subsubsection{Mögliche Einschränkungen der Ausdrücke}
\label{sec:sql-subset-expression}

Nach der Betrachtung der mit der unmittelbaren \texttt{SQL}-Struktur zusammenhängenden Funktionalität, widmet sich dieses Kapitel den dort verwendeten Ausdrücken. Um eine graduelle Lernkurve sowie eine sinnvolle Unterstützung durch den Editor zu gewährleisten, werden diese in drei Klassen eingeteilt:

\begin{description}
\item[Einfache Ausdrücke] \hfill\\
  Einfache Ausdrücke unterliegen einer festen Struktur, die nur sehr begrenzt die Schachtelung oder Verkettung von zusammengesetzten Ausdrücken zulässt. Ziel dieser Reduktion ist, dass die Auswertungsreihenfolge dieser Ausdrücke auch ohne die Verwendung von Klammern intuitiv eindeutig ist.

  Die Bearbeitung dieser Ausdrücke ist nicht notwendigerweise völlig frei, sondern könnte auch hinsichtlich der möglichen Operatoren oder der Struktur eingeschränkt werden.
\item[Komplexe Ausdrücke] \hfill\\
  Komplexe Ausdrücke lassen sich schachteln bzw. verketten und können mit einem Scratch-ähnlichen Editor für Ausdrücke frei bearbeitet werden. Die korrekte Beachtung von Auswertungsreihenfolgen ist Aufgabe der Lernenden, weswegen diese ggfs. die Ausdrücke auch selber klammern müssen.

\item[Beliebige Ausdrücke] \hfill\\
  Beliebige Ausdrücke werden textuell notiert und vom \texttt{SQL}-Editor nicht weiter geprüft, sondern ungefiltert in die Abfrage eingesetzt. Sofern diese Art von Ausdrücken zugelassen wird, erfolgt also auch keinerlei inhaltliche Einschränkung der zur Verfügung stehenden Möglichkeiten oder eine Syntaxüberprüfung.

  Diese Option soll fortgeschrittenen Lernenden erlauben, auch in nicht von \idename{} unterstützten Szenarien weiterarbeiten zu können. Damit wird verhindert, dass zu große Fortschritte der Lernenden \idename{} sofort obsolet machen.
\end{description}

Mit dieser Unterscheidung im Hinterkopf, können wir eine Menge an didaktisch sinnvollen Einschränkungen definieren. Ein wesentliches Lernziel ist dabei, dass es sich bei Ausdrücken (nicht nur in \texttt{SQL}) um ein allgemeines Konzept handelt, welches prinzipiell in der \texttt{SELECT}-Komponente genau so angewandt werden kann wie beim \texttt{ORDER BY}. Oder anders ausgedrückt: Wenn sich die Schüler aus didaktischen Gründen zunächst nur mit Ausdrücken im Rahmen der \texttt{SELECT}-Komponente beschäftigen sollen, ist das eine sinnvolle, und daher mögliche Einschränkung. Nicht sinnvoll hingegen wäre es, die Anwendung der \texttt{LENGTH(X)} Funktion nur in einer der beiden Komponenten zuzulassen. Letzteres wird daher auch nicht unterstützt.

\begin{enumerate}[resume]
\item \textbf{Allgemeine Optionen} \\
  Diese Optionen betreffen prinzipiell alle Stellen, an denen die entsprechenden Arten von Ausdrücken zugelassen werden.
  \begin{enumerate}[noitemsep]
  \item \label{feat:expr-allow-any-text} Ausdrücke als beliebigen Text zulassen. Diese Option erlaubt die Umgehung aller Einschränkungen für einfache Ausdrücke!
  \item \label{feat:expr-allow-placeholder} An Stelle von Konstanten auch die Verwendung von Platzhaltern zur Bindung von Daten aus der Oberfläche zulassen.
  \end{enumerate}

\item \label{feat:expr-compute}  \textbf{Einfache berechnende Ausdrücke} \\
  Diese Ausdrücke tauchen normalerweise in \texttt{SELECT}- oder \texttt{ORDER BY}-Komponenten auf, möglicherweise aber auch als Bestandteil eines einfachen Vergleichs.
  \begin{enumerate}[noitemsep]
      \item \label{feat:expr-compute-simple-func} Einfacher Funktionsaufruf mit Spalten oder Konstanten als Argument
      \item \label{feat:expr-compute-simple-arithmetic} Einfache Rechenausdrücke mit einer mathematischen Operation ($alter + 1$, $anzahl * preis$)
      \item \label{feat:expr-compute-simple-concat} Konkatenation von Strings\footnote{Sofern auch eine Oberfläche entwickelt werden soll, ist eine Konkatenation im Regelfall lieber dort vorzunehmen.}
  \end{enumerate}

\item \textbf{Einfache Vergleichende Ausdrücke} \\
  Diese "`typischen"' Vergleichsausdrücke sollten ausreichen, um einen Großteil der nötigen Vergleiche in \texttt{WHERE}, \texttt{HAVING} und \texttt{ON} Komponenten abzudecken. Die linke Seite dieser Ausdrücke ist stets eine zur Verfügung stehende Spalte, der Vergleichsoperator und die rechte Seite eine der hier aufgezählten Möglichkeiten.

  Mit Vergleich ist dabei nicht nur der $=$-Operator gemeint, sondern auch die relationen Operatoren $\ne, <,\ge,\le$ und $>$. Die komplexeren Operatoren \texttt{LIKE} und \texttt{IN} sowie der ternäre Operator \texttt{BETWEEN} werden aber gesondert aufgeführt.

  \begin{enumerate}[noitemsep]
  \item \label{feat:expr-compare-const} Vergleich einer Spalte mit einem konstanten Wert
  \item \label{feat:expr-compare-null} Vergleich einer Spalte gegen \texttt{NULL}
  \item \label{feat:expr-compare-other-col} Vergleich einer Spalte mit einer anderen Spalte
  \item \label{feat:expr-compare-simple-func} Vergleich einer Spalte mit einem einfachen berechnenden Ausdruck (siehe~\ref{feat:expr-compute})
  \item \label{feat:expr-compare-between} Test einer Spalte mit dem \texttt{BETWEEN}-Operator und zwei Konstanten
  \item \label{feat:expr-compare-like} Nutzung des \texttt{LIKE}-Operators mit einer Konstanten
  \item \label{feat:expr-compare-in} Nutzung des \texttt{IN}-Operators mit einer Liste von Konstanten
  \item \label{feat:expr-compare-negate} Negation aller einfachen Ausdrücke
  \end{enumerate}

\item \textbf{Allgemeine Funktionen (in alphabetischer Reihenfolge)} \\
  In einem Umfeld für Anfänger ist zu erwarten, dass fast jede Funktion (bzw. jede logische Gruppe an Funktionen) einer eigenen Einführung bedarf. Die Lehrkräfte sollen diese daher isoliert zur Verfügung stellen können, ohne Ablenkung durch nicht benötigte Funktionen.

  Bei unterschiedlich überladenen Varianten der gleichen Funktion wird in \idename{} immer nur die vollständigste Variante implementiert. Die Schüler müssen daher nicht die implizit bekannten Werte der jeweiligen Funktion auswendig kennen.
  \begin{enumerate}[noitemsep]
  \item \label{feat:fun-abs} \texttt{ABS(X)}, um den Betrag eines Wertes zu erhalten
  \item \label{feat:fun-coalesce} \texttt{COALESCE(X,Y,...)}, um den ersten gültigen Wert der Parameterliste zu erhalten
  \item \label{feat:fun-instr} \texttt{INSTR(X,Y,Z)}, um das Vorkommen eines Suchwortes in einer Zeichenkette zu erhalten
  \item \label{feat:fun-length} \texttt{LENGTH(X)}, um die Länge einer Zeichenkette zu bestimmen
  \item \label{feat:fun-casing} \texttt{LOWER(X)}, und \texttt{UPPER(X)} um die klein bzw. groß geschriebene Variante einer Zeichenkette zu erhalten
  \item \label{feat:fun-printf} \texttt{PRINTF(FORMAT, ...)}, zur Formatierung von Zeichenketten wie in der gleichnamigen Funktion der \texttt{C}-Standardbibliothek.
  \item \label{feat:fun-random} \texttt{RANDOM()}, um einen zufälligen Wert zu erhalten
  \item \label{feat:fun-replace} \texttt{REPLACE(X,Y,Z)}, um Teilbereiche der Zeichenkette zu ersetzen
  \item \label{feat:fun-round} \texttt{ROUND(X,Y)}, um kaufmännisch zu runden
     \item \label{feat:fun-soundex} \texttt{SOUNDEX(X)} um einen phonetisch orientierten, unscharfen Vergleich von Zeichenketten durchzuführen.
  \item \label{feat:fun-substr} \texttt{SUBSTR(X,Y,Z)}, um einen Ausschnitt der Zeichenketten zu extrahieren
  \item \label{feat:fun-trim} \texttt{TRIM(X)} sowie \texttt{LTRIM(X)} und \texttt{RTRIM(X)}, um Leerzeichen am Anfang oder Ende eines Strings zu entfernen
  \end{enumerate}

\item \textbf{Aggregierende Funktionen (in alphabetischer Reihenfolge)} \\
  Die Verfügbarkeit dieser Funktionen hängt von der Verfügbarkeit der \texttt{GROUP BY}-Komponente ab~(\ref{feat:group-allow}).
  \begin{enumerate}[noitemsep]
  \item \label{feat:fun-avg} \texttt{AVG(X)} bildet das arithmetische Mittel
  \item \label{feat:fun-count} \texttt{COUNT(X)} zählt alle Werte, die nicht \texttt{NULL} sind
  \item \label{feat:fun-group-concat} \texttt{GROUP\_CONCAT(X,Y)} konkateniert einzelne Zellen einer Gruppe
  \item \label{feat:fun-max-min} \texttt{MIX(X)} und \texttt{MAX(X)} selektieren einen minimalen oder maximalen Wert
  \item \label{feat:fun-sum} \texttt{SUM(X)} summiert und gibt im Falle von komplett fehlenden Werten \texttt{NULL} zurück
  \item \label{feat:fun-total} \texttt{TOTAL(X)} summiert und gibt im Falle von komplett fehlenden Werten \texttt{0.0} zurück
  \end{enumerate}
\end{enumerate}

\subsubsection{Sprachstufen}
\label{sec:sql-subset-ranks}

Angelehnt an die bei "`Dr. Racket"' umgesetzte Idee der unterschiedlichen Sprachstufen~\cite{macht-der-abstraktion} beschreibt dieses Kapitel konzeptionell, wie Lehrkräfte, aufbauend auf den im vorigen Kapitel beschriebenen Funktionalitäten, sinnvolle Untermengen von \texttt{SQL} definieren könnten, auf denen die mitgelieferten Beispielprojekte aufbauen. Bei den hier aufgeführten Beispielen handelt es sich keineswegs um feste Vorgaben. Vielmehr soll es für Lehrkräfte möglich sein, fast beliebige Teilmengen von \texttt{SQL} für ihre Schüler vorzugeben, nicht nur die im Rahmen dieser Arbeit als sinnvoll erkannten Kombinationen.

Das grundsätzliche Vorgehen um den Sprachumfang einzuschränken, ist dabei mehrstufig. Initial wird auf Projektebene mit einer Whitelist gearbeitet: Jede explizit erlaubte Funktionalität steht im \texttt{SQL}-Editor (siehe Kapitel \fullref{sec:design-sql-editor}) zur Verfügung. Und sofern eine Funktionalität nicht erlaubt sein sollte, ist sie auch nicht verfügbar. Der Begriff "`Einschränkung"' ist aus der Sicht einer Whitelist also zwar nicht ganz optimal gewählt, beschreibt die stattfindende Reduktion des Umfangs von \texttt{SQL} aber akkurat.

Alternativ sollen sich auch wortwörtliche Einschränkungen im Sinne einer Blacklist angeben lassen. Für die in der Regel sehr übersichtlichen Teilsprachen die in dieser Arbeit konzipiert werden, ist diese Variante häufig schlechter lesbar: Man muss den größtmöglichen Umfang des hier beschriebenen Dialekts immer im Hinterkopf haben. Außerdem kommen im Falle einer Erweiterung des Sprachumfangs, z.B. durch ein späteres Update der Entwicklungsumgebung, möglicherweise unerwünschte Möglichkeiten hinzu.

Danach können die Einschränkungen noch für einzelne Abfragen verfeinert werden. Im allgemeinen Fall wird diese Funktionalität wenig nachgefragt sein: Insbesondere bei der Entwicklung von Webanwendungen ist es nicht hilfreich, sich für jede Abfrage in einen anderen Sprachumfang einarbeiten zu müssen. Sofern die Schüler aber bestimmte Aufgaben mit einem didaktisch motiviertem reduzierten (oder erweiterten) Sprachumfang lösen sollen, kommt diese Möglichkeit zum Einsatz. Die hier exemplarisch aufgeführten Feature-Levels orientieren sich an den im Rahmen der Master-Thesis exemplarisch erstellten Datenbeständen und an den Aufgaben aus Informatik-Lehrbüchern \cite{hubwieser_inf_2, grimm_informatik_2015}.

\begin{description}
\item[Arbeiten mit einfachen Einschränkungen] \hfill \\
  Die Selektion steht in allen betrachteten Schulbüchern am Beginn des Lernprozesses. Verwendet werden dabei durchgängig alle relationalen Operatoren ($<, \leq, =, \neq, \geq, >$), das logische \lstinline{NICHT}, \lstinline{UND} sowie \lstinline{ODER}. Teilweise werden auch schon einfache unscharfe Textsuchen mit dem \lstinline{LIKE}-Operator behandelt. Syntaxzucker wie \lstinline{BETWEEN} kommt jedoch nicht vor.

\item[Arbeiten mit Projektionen] \hfill \\
  Der Funktionsumfang von diesem Feature-Level orientiert sich an gängigen Tabellenkalkulationsprogrammen wie Microsoft Excel oder Libre Office Calc. Im Vordergrund steht die Verwendung oder Schachtelung von Text-Funktionen wie \lstinline{substring} oder \lstinline{find}. Bei den Datensätzen handelt es sich häufig um stark denormalisierte Daten, welche nicht einmal in erster Normalform vorliegen. So werden zum Beispiel Vor- und Zuname in eine einzige Zelle geschrieben und müssen dann in der Projektion wieder voneinander getrennt werden.

\item[Arbeiten mit aggregierten Daten] \hfill \\
  Dieser Schritt ist gewissermaßen die logische Fortführung der Projektion. Die Lernenden müssen verstehen nach welchen Kriterien die Gruppierung erfolgen sollte und welche Spalten danach noch ohne Aggregation zur Verfügung stehen.

\item[Arbeiten mit \texttt{INNER JOIN}s] \hfill \\
  Dieses Feature-Level stellt die Verknüpfung vorhandener Datenbestände in den Vordergrund und blendet jegliche Projektion oder Gruppierung vollständig aus. Schüler sollen auf dieser Stufe lernen, sich in einem Datenmodell anhand der vorhandenen Fremdschlüssel-Beziehungen zu orientieren.

\item[Arbeiten mit \texttt{OUTER JOIN}s] \hfill \\
  Auf dieser Stufe sollen die Schüler erkennen, dass durch einen \texttt{INNER JOIN} nicht nur neue Kombinationen von Datensätzen erschlossen werden, sondern auch Zeilen wegfallen können.
\end{description}

Für diese Arbeit wird der Umfang auf einfache Einschränkungen und \texttt{JOIN}s beschränkt. Diese beiden Stufen erlauben die Navigation in umfangreichen Datenbeständen, also in Schemata mit beliebig vielen Tabellen. Ohne diese Funktionalität wären die sinnvoll verwendbaren Schemata auf jene mit einer einzelnen Tabelle reduziert.

Die verwendete Templatingsprache (siehe \fullref{sec:liquid-language}) verfügt ebenfalls über Funktionen zur Projektion von Daten. Um im Rahmen der Thesis keine redundante Funktionalität zu implementieren, wird zunächst darauf verzichtet transformierende Projektionen (konkret also Funktionen) in \texttt{SQL} zu unterstützen.

Aggregierte Daten sind aus Sicht der Oberfläche nicht besonders spannend: Es handelt sich weiterhin um eine Struktur aus Zeilen und Spalten. Die Unterstützung von \texttt{GROUP BY} stellt aus Sicht des Datenaustausches zwischen Abfragen und Seiten keine Veränderung dar. Aus Zeitgründen wird daher auch diese Funktionalität nicht implementiert um mehr Zeit für die Entwicklung des Oberflächeneditors zu haben. Der Umgang mit \texttt{OUTER JOIN}s schlägt sich hingegen möglicherweise auch in der Oberfläche wieder. Plötzlich müssen dort Platzhalter für nicht vorhandene Werte vorgesehen werden.

\subsection{Drag \& Drop-Editor für \texttt{SQL}}
\label{sec:design-sql-editor}

Der grafische Editor soll weitestehend analog zu den aus Scratch bekannten Bedienkonzepten funktionieren können. Es kommen also distinkte Bedienelemente für die verschiedenen Komponenten einer \texttt{SQL}-Abfrage zum Einsatz, kein reiner Texteditor. Der komponentenorientierte Editor soll dabei nicht die Konzeption von beliebigen Abfragen ermöglichen, wohl aber umfassend den Anforderungen aus Schulbüchern wie \cite{grimm_informatik_2015, hubwieser_inf_2} gerecht werden.

Grundsätzlich bedürfen einige Komponenten der Abfrage besonderer Aufmerksamkeit, weil sie große Auswirkungen auf das Verhalten der anderer Komponenten haben. Vorrangig ist hier die \texttt{GROUP-BY}-Komponente zu nennen. Sobald die Query mit einer \texttt{GROUP BY}-Komponente ausgestattet wird, ist der Zugriff auf die konkreten Spalten einzelner Zeilen z.B. im allgemeinen Fall nicht mehr möglich. Das Hinzufügen (oder Entfernen) dieser Komponente hat also große Auswirkungen auf die Korrektheit der gesamten Abfrage. Ähnliches gilt für den Umgang mit \texttt{JOIN}s: Aus diesen leitet sich ab, welche Daten von der Entwicklungsumgebung überhaupt angeboten werden sollten.

\subsubsection{Visuelle Gestaltung}

Für technische Details irrelevant, aber unbedingt ebenfalls im Voraus zu klären ist die Frage inwiefern es sinnvoll wäre, das sehr bunte, kontrastreiche Design von Scratch zu imitieren. Abbildung~\ref{fig:compare-colourful} zeigt einen Vergleich zweier Prototypen aus der Konzeptionsphase von \idename{}: Einmal sehr bunt und "`blockig"' und einmal angelehnt an konventionelles Syntax-Highlighting.

\begin{wrapfigure}{r}{0.46\textwidth}
  \includegraphics[width=0.45\textwidth]{images/scratch-control-flow}
  \caption{Kontrollfluss in Scratch}
  \label{fig:screen-scratch-control-flow}
\end{wrapfigure}

Das blockige Design orientiert sich an Scratch und macht visuell sehr deutlich, welche Komponenten logisch zusammenhängen. Im Laufe der Entwicklung des Prototypen wurde aber immer deutlicher, dass die Zusammenhänge der Komponenten hier eher überbetont werden. In Scratch ist dieser deutliche visuelle Zusammenhang notwendig. So zeigen z.B. die Konnektoren der Blöcke für Ereignisse oder Endlosschleifen sehr deutlich, wie sich der Kontrollfluss durch diese Elemente verändern wird: Der Kontrollfluss beginnt mit dem Ereignis, ein Anhängen von Blöcken nach der Schleife ist weder möglich noch sinnvoll (Abbildung~\ref{fig:screen-scratch-control-flow}).  Für eine vollständige Programmiersprache ist das mit Sicherheit eine gute Wahl, für den sehr linearen Ablauf einer \texttt{SQL}-Abfrage ist diese so ausgeprägte visuelle Hierarchie im Regelfall nicht nötig.

Die in den Prototypen noch zu sehende Nutzung von "`normalen"' Bedienelementen wie Text- oder Listboxen (Abbildung~\ref{fig:compare-colourful} \& \ref{fig:screen-sql-editor-all-editing}) wurde schon früh in der Entwicklung zugunsten eines auf Drag \& Drop aufbauenden Konzeptes aufgegeben. Die Bedienelemente haben zum einen schon rein visuell die Lesbarkeit merklich gestört und hätten häufig ausgeblendet werden müssen. Zudem ist bei der Bearbeitung von Ausdrücken eine distinkte visuelle Hierarchie sehr von Vorteil. Diese Hierarchie lässt sich am einfachsten durch die konsequente Verwendung von klar codierten Formen und Farben erreichen, was sich für vom Browser bereitgestellte Bedienelemente aber nur in engen Grenzen umsetzen lässt\footnote{Historisch waren diese Bedienelemente überhaupt nicht mit \texttt{CSS} zu gestalten, diese Situation hat sich heutzutage deutlich verändert. Der nötige Aufwand dafür ist jedoch groß und erfordert zum Beispiel das deaktivieren der nativen Bedienelemente mit \texttt{display:none} und dann einen "`Nachbau"' mit anderen Elementen.}.

Darüber hinaus existiert noch ein weiterer Faktor, der zwar keinen Einfluss auf die technischen Details von \idename{} hat, aber trotzdem eine etwas ausführlichere Betrachung rechtfertigt: die größere Nähe des etwas nüchterneren, IDE-ähnlichen Designs zu "`normalen"' Entwicklerprogrammen. Diese wirken möglicherweise weniger einschüchternd, wenn man sich schon an den Anblick von recht viel Text mit Syntax-Highlighting gewöhnt hat. Es ändert sich dann bei der Verwendung von typischen Entwicklerprogrammen dann "`lediglich"' das Bedienparadigma sehr stark (Text schreiben statt Drag \& Drop), aber nicht mehr der visuelle Ersteindruck.

Letztendlich existiert aber auch noch ein sehr viel profanerer Faktor: Der Autor dieser Arbeit ist kein Grafikdesigner und würde ohne Hilfe vermutlich kein ansprechendes, durchgehend "`blockiges"' Gesamtkonzept auf die Beine stellen können. Das endgültige Design lehnt sich bei dem Editor für Ausdrücke durch die Verwendung von Blöcken visuell an Scratch an, nutzt zur Visualisierung der Komponenten jedoch eine an Syntax-Highlighting orientierte Darstellung.

\begin{figure}[h]
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{images/sql-sketch-early-colourful}
    \caption{Starke Betonung der Blöcke}
    \label{fig:screen-sql-editor-early-colourful}
  \end{subfigure}\hfill
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{images/sql-sketch-early-syntax-highlight}
    \caption{Syntax-Highlighting}
    \label{fig:screen-sql-editor-early-syntax-highlighting}
  \end{subfigure}
  \caption{Vergleich unterschiedlicher Gestaltungsansätze}
  \label{fig:compare-colourful}
\end{figure}

\subsubsection{Grundsätzlicher Aufbau}

Es stellt sich zunächst die Frage, ob der Editor, wie Scratch, mit einer Drag \& Drop-Seitenleiste ausgestattet werden sollte oder ob auch ein anderes Bedienkonzept denkbar wäre. Ein grundsätzlicher Nachteil des Drag \& Drop Bedienkonzeptes ist der nötige Platz für die Unterbringung aller verwendbaren Komponenten. Spätestens wenn für die Anzeige aller verfügbaren Optionen nicht ausreichend Platz auf dem Bildschirm vorhanden ist, muss sorgfältig geplant werden, wie die entsprechenden Bedienelemente anzuordnen sind.

Scratch nutzt eine Einordnung der Blöcke in zehn Kategorien. Es sind daher nie alle existierenden Blöcke auf einmal sichtbar, sondern immer die thematisch verwandten Blöcke der aktuell gewählten Kategorie. Eine solche Kategorisierung muss sehr sorgfältig entwickelt und vor allem erprobt werden: Sollten die Zuordnung eines Blocks mehrdeutig oder missverständlich sein, besteht die Gefahr, dass er nicht gefunden wird. Im Rahmen dieser Arbeit wurde diese Problematik der Kategorisierung daher erst einmal verschoben: Es wird darauf verzichtet, solange die zur Verfügung stehenden Bedienelemente noch bequem Platz in einem Full-HD-Browserfenster haben.

Da der Benutzer immer nur eine Abfrage zur Zeit bearbeiten können soll, ergibt sich der einzig mögliche Platz für viele Blöcke automatisch. Darüber hinaus ist die Reihenfolge eines Großteils der Komponenten einer Abfrage sehr strikt festgelegt, so kann eine \texttt{GROUP BY} Komponente nicht an beliebigen Stellen verwendet werden, sondern nur nach der \texttt{FROM} oder der \texttt{WHERE} Anweisung. Andere Komponenten wie z.B. \texttt{HAVING} oder logische Verknüpfungen mit \texttt{AND} oder \texttt{OR} sind nicht nur von der Reihenfolge, sondern auch von der Existenz anderer Bestandteile abhängig. Ein möglicher Ansatz zur Reduktion der verfügbaren Komponenten wäre also, für die möglichen Optionen visuell abgegrenzt Platzhalter innerhalb des Abfrageeditors anzubieten. Ein Klick auf den Platzhalter könnte diesen dann in einen konkreten Block umwandeln und gegebenenfalls zur Angabe der benötigten Parameter auffordern.

\begin{figure}[p]
  \centering\includegraphics[width=0.9\textwidth]{images/sql-sketch-all-editing}
  \caption{Verworfen: Keine Nutzung von Drag \& Drop und daher simultane Anzeige (fast) aller Möglichkeiten, zudem ausgiebige Nutzung von "`normalen"' Bedienelementen.}
  \label{fig:screen-sql-editor-all-editing}
\end{figure}

Im Rahmen der vorab entwickelten, rein visuellen Prototypen hat sich herausgestellt, dass eine permanente Anzeige aller Editierungsmöglichkeiten mit einem sehr überladen wirkenden Benutzerinterface einher geht, insbesondere was die Einblendung von Platzhaltern angeht. Abbildung~\ref{fig:screen-sql-editor-all-editing} zeigt einen Screenshot eines Prototypen, bei dem nahezu alle denkbaren Editierungsoptionen gleichzeitig für den Lernenden verfügbar sind und daher angezeigt werden müssen. Trotz der klaren visuellen Unterscheidung fällt es schwer, mit nur einem Blick zu erkennen, was die Abfrage jetzt tatsächlich beinhaltet.

Statt jederzeit alle Optionen anzuzeigen, könnte dann noch die Position des Mauszeigers herangezogen werden, um zu entscheiden, welche Platzhalter angezeigt werden sollen. So wurden alle Editierfunktionen ausgeblendet, wenn sich die Maus außerhalb der Abfrage befand, die \texttt{JOIN}-Optionen nur gezeigt, wenn der Cursor sich gerade in der Nähe befand, ... Das Ergebnis war allerdings eine Benutzerschnittstelle, deren Bedienelemente häufig und für einen ungeübten Benutzer auch unerwartet ihre Position verändert haben. Dementsprechend wurde dieser Ansatz noch in der Konzeptionsphase verworfen. Darüber hinaus hätte man mit diesem Ansatz nur hierarchisch verwandte Bereiche ausblenden können: Für die \texttt{GROUP BY}-, \texttt{ORDER BY}- oder \texttt{UNION}-Platzhalter ergibt sich keine intuitive Position des Mauszeigers, bei der diese kontextsensitiv eingeblendet werden könnten.

Das endgültig implementierte Design (Abbildung~\ref{fig:screen-sql-editor-drag-drop}) lehnt sich nun doch an Scratch an, versucht allerdings mit Platzhaltern den Benutzer kontextsensitiv zu unterstützen. Wenn dieser zum Beispiel einen Vergleichsoperator für Ausdrücke in der Seitenleiste anwählt, werden im Hauptfenster die validen Drop-Ziele hervorgehoben. Unter dem eigentlichen Editor befinden sich dann zwei weitere Bereiche (Abbildung~\ref{fig:screen-sql-editor-parameters-preview}): Zum einen die Ergebnisanzeige, welche die zur aktuellen Gestalt der Abfrage passenden Zeilen zeigt, zum anderen eine Möglichkeit, bei Abfragen mit Parametern die nötigen Werte zu definieren. An dieser Abbildung wird zudem ein weiteres Detail deutlich: Abfragen lassen sich nur als "`einzeilig"' deklarieren, wenn eine \texttt{WHERE}-Komponente vorhanden ist.

\begin{figure}[t]
  \includegraphics[width=\textwidth]{images/sql-drag-drop}
  \caption{Implementiert: Drag \& Drop-Interface mit Hervorhebung von möglichen Zielen beim Ziehen aus der Seitenleiste, keine Nutzung von "`normalen"' Bedienelementen.}
  \label{fig:screen-sql-editor-drag-drop}
\end{figure}

\begin{figure}[p]
  \centering\includegraphics[width=0.95\textwidth]{images/sql-parameters-preview}
  \caption{Abfrageeditor: Parameter für eine parametriesierte Abfrage und Ergebnisvorschau}
  \label{fig:screen-sql-editor-parameters-preview}
\end{figure}

\subsubsection{Umgang mit Ausdrücken}

Innerhalb der \texttt{SELECT}- und \texttt{WHERE}-Komponenten können fast beliebige Ausdrücke auftreten. Diese unterscheiden sich strukturell vor allem anhand ihrer benötigten Parameter. Konstanten, Spalten und "`Benutzerwerte"' stehen für sich, können also unmittelbar verwendet werden. Sofern Ausdrücke andere Ausdrücke zur Auswertung benötigen, zum Beispiel das logische \texttt{UND}, werden diese zunächst durch einen speziellen Blanko-Platzhalter gefüllt. Auf diesen Platzhalter, symbolisiert durch ein Fragezeichen, lassen sich dann wie gewohnt per Drag \& Drop andere Ausdrücke der Abfrage oder Elemente aus der Seitenleiste ziehen. Damit funktioniert die Entwicklung von Ausdrücken sehr ähnlich, wie es Schülern möglicherweise schon aus Scratch bekannt ist.

Die in Kapitel \fullref{sec:sql-subset-expression} vorgestellten "`einfachen Ausdrücke"' lassen sich schwerer als zunächst vermutet in die Oberfläche integrieren. Schon die Platzierung dieser Vereinfachungen wirft Fragen auf: In der Seitenleiste, einem neuen Dialog oder "`irgendwie kontextabhängig"'? Sollen für komplexe Sachverhalte eigene "`Untereditoren"' entwickelt werden? Wenn es aus didaktischer Sicht hilfreich scheint mit einem "`Wizard"'-Dialog zu arbeiten, soll dafür das Drag \& Drop Paradigma durchbrochen werden? Da sich mit dem Drag \& Drop-Ansatz alle Ausdrücke entwerfen lassen, wurde die Diskussion über eine geeignete Benutzerschnittstelle für diese Funktionalität auf unbestimmte Zeit verschoben.

\subsubsection{Abfragen mit Parametern}
\label{sec:design-query-params}

Um eine Interaktion mit Endbenutzern zu ermöglichen, können in Ausdrücken auch benannte Parameter ("`Benutzerwerte"') anstelle von konstanten Werten verwendet werden. Im Gegensatz zu Konstanten werden diese zur Laufzeit vom Benutzer angegeben. Aus Sicht der \texttt{SQL}-Abfrage ist diese Ergänzung trivial, da benannte Parameter ein Bestandteil faktisch jeder \texttt{SQL}-Implementierung. Die eigentliche Problematik liegt im Binden dieser Parameter zur Laufzeit. Das Kapitel~\fullref{sec:design-ui-bind-output} beschreibt, wie die Verknüpfung mit den Bedienelementen der Oberfläche vorgenommen wird.

Innerhalb des Abfrageeditors können solche parametrisierten Abfragen dann folglich nicht mehr direkt ausgeführt werden. Auf diesen Umstand wird der Entwickler, wie in Abbildung~\ref{fig:screen-sql-editor-parameters-preview} zu sehen ist, direkt innerhalb des Editors hingewiesen. Sofern er die benötigten Parameter dann eingibt, kann die Abfrage auch wieder ausgeführt werden.

\subsubsection{\texttt{FROM}}

Wenn der Benutzer eine Drag-Operation mit einer Tabelle beginnt, kann er die Tabelle wahlweise auf einer bestehenden Tabelle "`fallen lassen"', einen $\bigoplus$-Indikator nach der letzten Tabelle oder den \texttt{FROM}-Text selbst fallen lassen. Eingefügt wird dabei im Falle von schon existierenden Elementen immer nach dem Ziel. Die $\bigoplus$-Indikatoren werden hingegen einfach durch das neue Element ersetzt.

Diese Komponente beinflusst unmittelbar die in der Seitenleiste zur Verfügung stehenden Daten. Für Tabellen, die bisher nicht Teil der \texttt{FROM}-Komponente sind, stehen die entsprechenden Spalten nicht zur Verfügung. Erst wenn man diese Tabelle mit einem \texttt{JOIN} in die Abfrage einbindet, erscheinen auch die dazugehörigen Spalten in der Seitenleiste.

\subsubsection{\texttt{WHERE}}

Die \texttt{WHERE}-Komponente wird ausgeblendet, sofern der Entwickler noch keine Einschränkungen für die Abfrage definiert hat. Existierende Einschränkungen werden natürlich jederzeit eingeblendet und können durch einfaches "`fallen lassen"' anderer Ausdrücke auf die bestehenden Ausdrücke editiert werden.

Erstmalig angelegt (oder mit \texttt{AND} und \texttt{OR} erweitert) wird die Komponente sobald der Entwickler einen Ziehvorgang mit einem Ausdruck beginnt. Im Falle von schon existierenden Einschränkungen werden die \texttt{AND}- und \texttt{OR}-Operatoren angezeigt, andernfalls das \texttt{WHERE} selbst. Hinter den Schlüsselworten wird dabei jeweils mit einem $\bigoplus$-Indikator angezeigt, dass dort das aktuell gezogene Element eingesetzt werden kann. Die Ergänzung einer bestehenden Einschränkung wird in Abbildung~\ref{fig:screen-sql-editor-drag-drop} illustriert.

Syntaktisch gesehen wären die logischen Verknüpfungen natürlich auch als Teil der "`normalen"' binären Ausdrücke möglich; in der Praxis wird der Quelltext von \texttt{SQL}-Abfragen allerdings häufig anhand dieser Verknüpfungen die Zeile umgebrochen. An dieser Stelle folgt \idename{} also einer bewährten Konvention, auch wenn das syntaktisch nicht unbedingt notwendig wäre.

\subsubsection{\texttt{GROUP BY}}

Sobald in einer Abfrage eine \texttt{GROUP BY} Komponente genutzt wird, hat dies Auswirkungen auf die Möglichkeiten innerhalb der \texttt{SELECT} Anweisung. Da keine Auswahl von ungruppierten und nicht-aggregierten Spalten möglich sein darf, müssen diese entfernt werden. Insbesondere wenn der Benutzer vorher schon mit komplizierten Ausdrücken im \texttt{SELECT} gearbeitet hat, ist eine Warnung nötig.

\subsubsection{Manipulation von Daten}

Neben den bisher ausführlich besprochenen \texttt{SELECT}-Anweisungen müssen sich natürlich \texttt{INSERT}-, \texttt{UPDATE}- und \texttt{DELETE}-Anweisungen umsetzen lassen. Da diese ihrer Natur nach nicht idempotent sind, verbietet sich natürlich eine wiederholte, automatische Ausführung während der Entwicklungszeit. Es ist zu erwarten, dass die meisten von den Schülern verfassten Abfragen dieser Art ausführlichen Gebrauch von den in Kapitel~\fullref{sec:design-query-params} beschriebenen Parametern machen.

Die Ausführung dieser Operation sollte daher immer in zwei Schritten erfolgen, die von einer Vorschau auf das Ergebnis begleitet werden. Erst wenn diese Ergebnisvorschau vom Entwickler bestätigt wird, werden die Änderungen tatsächlich übernommen. Für \texttt{DELETE}- und \texttt{INSERT}-Operationen kann diese Vorschau einfach den kompletten neuen bzw. zu löschenden Datensatz anzeigen. Im Falle von \texttt{UPDATE}-Anweisungen sollten alle veränderten Datensätze einander gegenübergestellt werden.

\begin{figure}[h]
  \includegraphics[width=\textwidth]{images/sql-insert-key-value-pairs}
  \caption{Abfrageeditor: Anderes Erscheinungsbild für Spalte-Wert-Paare, wie sie bei \texttt{INSRT} oder \texttt{UPDATE} Operationen nötig sind}
  \label{fig:screen-sql-editor-insert-key-value-pairs}
\end{figure}

Für die Name-Wert-Paare in \texttt{INSERT}- oder \texttt{UDPATE}-Operationen löst sich das Erscheinungsbild des Editors von dem Vorbild der \texttt{SQL}-Syntax (Abbildung~\ref{fig:screen-sql-editor-insert-key-value-pairs}). Zur Erinnerung werden an dieser Stelle noch einmal die SQLite-Syntax für \texttt{UPDATE}- und \texttt{INSERT}-Anweisungen illustriert (Listing~\ref{lst:sql-syntax-insert} \& \ref{lst:sql-syntax-update}). Leider haben diese beiden verwandten Anweisungen offensichtlich eine unterschiedliche Syntax für die Notation der Schlüssel-Wert-Paare.\footnote{Dieser Umstand wurde mit SQLite Version 3.15.0 für die \texttt{UPDATE}-Anweisung verbessert, bisher hat sich diese Syntax substanziell von der \texttt{INSERT}-Schreibweise unterschieden. Jetzt ist es analog zum \texttt{INSERT} ebenfalls möglich, auf beiden Seiten der Zuweisung identisch lange Listen von Spalten und Werten anzugeben. Allerdings ist Version 3.15.0 am 14. Oktober 2016 erschienen, etwa zwei Wochen vor dem Druck dieser Thesis.}. Dieses syntaktische Detail wird allerdings vor dem Entwickler durch die Oberfläche versteckt. Sichtbar ist dort nur die abstrakte Zuweisung von Werten an eine Auswahl von Spalten.

\begin{lstlisting}[language=SQL,float=h!,caption={Syntax einer \texttt{INSERT}-Anweisung}, label={lst:sql-syntax-insert}]
INSERT INTO gefangen (pokedex_nummer, spitzname, staerke)
VALUES (:nummer, :name, :staerke)
\end{lstlisting}

\begin{lstlisting}[language=SQL,float=h!,caption={Syntax einer \texttt{UPDATE}-Anweisung}, label={lst:sql-syntax-update}]
UPDATE gefangen
SET spitzname = :neuer_name, staerke = :neue_staerke
WHERE gefangen_id = :geaendertes_pkmn;
\end{lstlisting}

Um zwischen bewusst und versehentlich nicht vom Entwickler gesetzten Werten zu unterscheiden, ist in der aktuellen Fassung leider noch die Nutzung einer Checkbox vorgesehen. Das ist ein Bruch mit dem üblicherweise verwendeten Drag \& Drop-Paradigma und sollte in einer künftigen Version durch aus der Seitenleiste ziehbare Spalten abgelöst werden.

\subsection{Konzept für Oberflächen}
\label{sec:design-ui-concept}

Damit sich mit der Schülerentwicklungsumgebung erstellte Projekte auch von normalen Endanwendern bedienen lassen, bedarf es natürlich noch einer entsprechenden Benutzer-oberfläche. Hier bietet sich, aus Gründen der einfachen Weitergabe, eine webbasierte Oberfläche an. Dadurch entfällt bei den Endanwendern jegliche Installation und gerade für datenzentrierte, verteilte Anwendungen ist eine einheitliche Sicht auf den Datenbestand von großer Bedeutung. Ein weiterer positiver Aspekt ist die einfache Weitergabe der eigenen Arbeitsergebnisse in Form einer \texttt{URL}: Diese können über eine beliebige soziale Plattform oder durch einen Messenger im Bekanntenkreis geteilt werden.

\warning{Nicht alle hier beschriebenen Optionen sind notwendigerweise in dem Prototypen implementiert! Dieses Kapitel ist eine \textit{allgemeine} Betrachtung eines didaktisch sinnvollen Konzeptes zur Beschreibung von Oberflächen. Um zu sehen, welcher Funktionsumfang im Prototypen tatsächlich verfügbar ist, lohnt sich ein Blick in \fullref{sec:conclusion} und den Anhang \fullref{sec:project-examples}.}

Auch wenn im bisherigen Verlauf der Arbeit stets ausschließlich \texttt{HTML} als Technologie zur Beschreibung von Oberflächen erwähnt wurde, handelt es sich dabei nur um den statischen Teil des technischen Fundaments. Um die interaktive Anbindung von Datenquellen zu ermöglichen, müssen noch einige Erweiterungen in Form einer Templatingengine zum Einsatz kommen. Ähnlich wie für die \texttt{SQL}-Abfragen wird auch für die Oberflächen ein dedizierter Editor (Kapitel~\ref{sec:design-ui-editor}) implementiert. Die Schüler sollten zu keinem Zeitpunkt selber Quelltexte tippen müssen, optional aber durchaus die Möglichkeit dazu haben.

Um das folgende Kapitel anschaulicher zu gestalten, werden die aufgeführten Beispiele meist anhand eines sehr reduzierten Datenbestandes (siehe Tabelle~\ref{tab:ui-concept-data-article} \& \ref{tab:ui-concept-data-comment}) zu einem einfachen Blog illustriert. Dieser besteht aus zwei Tabellen für Artikel und Kommentare, ein Artikel kann dabei mehrfach oder auch überhaupt nicht über Kommentare verfügen. Bei den Zeitangaben handelt es sich um \texttt{UNIX}-Zeitstempel.

\begin{table}[h]
  \centering
  \begin{tabularx}{\linewidth}{ l l X l }
    \texttt{article\_id}&\texttt{caption}&\texttt{text}&\texttt{date}\\
    \hline
    1&Erster Artikel&Mit wenig Text steht.&1393423200\\
    2&Nächster Artikel&Mit ein bisschen mehr Text.&1456498800\\
    3&Dritter Artikel&Mit \texttt{<abbr>}HTML\texttt{</abbr>}&1477872000\\
  \end{tabularx}
  \caption{\texttt{article}-Daten des Blog-Beispiels}
  \label{tab:ui-concept-data-article}
\end{table}

\begin{table}[h]
  \centering
  \begin{tabularx}{\linewidth}{ l l l X l }
    \texttt{comment\_id}&\texttt{article\_id}&\texttt{commenter\_name}&\texttt{text}&\texttt{date}\\
    \hline
    1&1&Ash Ketchum&Erster!&1393423241\\
    2&1&Betreiber&Zweiter :(&1393435123\\
    3&3&Kommentator&\texttt{<i>}HTML\texttt{</i>}&0\\
  \end{tabularx}
  \caption{\texttt{comment}-Daten des Blog-Beispiels}
  \label{tab:ui-concept-data-comment}
\end{table}

Dieser Blog soll dem Endbenutzer über zwei Seiten näher gebracht werden: Eine \textit{Hauptseite} dient der Auflistung aller Blogbeiträge, welche im Einzelnen auf einer \textit{Detailseite} in Gänze betrachtet und kommentiert werden können. Dabei können auf der Hauptseite aus Platzgründen nicht die gleichen Informationen angezeigt werden, wie auf den Detailseiten. Daher werden die Daten auf der Hauptseite teilweise aggregiert: Statt alle Kommentare zu einem Beitrag anzuzeigen, wird nur auf die Anzahl der getätigten Kommentare verwiesen.

Bei dieser Aufteilung handelt es sich um eine typische "`Master-Detail"'-Struktur: Ausgehend von einer sehr komprimierten Darstellung aller Werte können Details zu einem konkreten Datensatz nach einem Navigationsvorgang eingesehen werden. Dieses Navigationskonzept wird von fast allen geschäftlichen Applikationen genutzt und ist eine der Standardvorlagen des Visual Studio Lightswitch.

Abstrakt betrachtet besteht eine \idename{}-Seite aus zwei wesentlichen Informationen: Einer Auflistung aller zum Darstellen benötigten Datenquellen "= im Rahmen dieser Thesis werden das ausschließlich \texttt{SQL}-Abfragen sein "= und einer Vorschrift, wie genau dieser Datenbestand darzustellen ist, also eine \texttt{HTML}-Vorlage mit speziellen Anweisungen zur Datenanbindung. Kapitel \fullref{sec:page-data-sources} erläuert, wie diese Anbindung allgemein organisiert wird, Kapitel \fullref{sec:design-ui-bind-output} beschreibt die konkreten Details der \texttt{SQL}-Anbindung.

\subsubsection{Datenquellen für Webseiten}
\label{sec:page-data-sources}

Um die einer Webseite zur Verfügung stehenden Daten zu strukturieren, wird der verfügbare Datenbestand in unterschiedliche Namensräume eingeteilt. Dadurch werden Kollisionen von Bezeichnern vermieden und es ist schon anhand der Bezeichnung eindeutig, aus welchem Kontext ein abgerufener Wert zur Verfügung gestellt wird.

\begin{description}[noitemsep]
\item[\texttt{page} für Eigenschaften der Seite] \hfill \\
  Der Name der aktuellen Seite ist für die Darstellung möglicherweise relevant und sollte daher während des Rendervorgangs zur Verfügung stehen.
\item[\texttt{project} für Eigenschaften des Projektes] \hfill \\
  Wenn man als Entwickler globale Konstanten ablegen möchte, könnte man dies auch in der Datenbank tun. Einfacher ist aber ein separater Speicherort, welcher tatsächlich keine Modifikationen durch Endbenutzer vorsieht. Das typische Beispiel für einen solchen global verfügbaren Wert wäre der Name des Projekts an sich oder die Routing-Tabelle mit allen verfügbaren Seiten.
\item[\texttt{get} für \texttt{URL}-Parameter] \hfill \\
  Wenn aus einer Vielzahl von verfügbaren Daten zu einem bestimmten Datensatz navigiert werden soll, sieht der \texttt{HTML}-Standard die Verwendung von \texttt{URL}-Parametern vor. Mit diesen lassen sich applikationsspezifische Merkmale der anzuzeigenden Datensätze angeben. Im Falle des Blog-Beispiels wäre das zum Beispiel die \texttt{article\_id} zur Anzeige eines bestimmten Beitrages oder die Angabe eines Startzeitpunktes, um die Hauptseite in mehrere Seiten für unterschiedliche Zeiträume zu unterteilen.
\item[\texttt{query} für \texttt{SELECT}-Abfragen] \hfill \\
  Nicht jede Webseite benötigt die Ergebnisse aller verfügbaren Abfragen. Daher werden die tatsächlich benötigten referenzierten Abfragen in diesem Namensraum gesammelt. Kapitel \fullref{sec:design-ui-bind-output} beschreibt im Detail, wie diese Anbindung funktioniert.
\item[\texttt{form} für Benutzereingaben] \hfill \\
  Dieser Namensraum hat im Gegensatz zu allen anderen Namensräumen keinen globalen Gültigkeitsbereich, sondern hängt eng mit dem \texttt{HTML}-\texttt{form}-Element zusammen. Die zur Verfügung gestellten Daten hängen folglich von der Struktur des Templates ab.
\end{description}

Die Verwendung von Namensräumen ist von Jekyll inspiriert, \texttt{page} und \texttt{project} findet man auch dort. Durch die Kombination der in diesen Namensräumen verfügbaren Namen für Projekt und Seite kann \idename{} automatisch eine sinnvolle Implementierung für den \texttt{HTML}-Titel jeder Seite generieren: "`\texttt{page.name - project.name}"'. Zur Laufzeit würde dann für eine denkbare "`Impressum"'-Seite des "`Beispielblog"' also "`Impressum - Beispielblog"' als Titel angezeigt werden.

Perspektivisch interessant wäre noch die Einbindung von Namensräumen für Cookies und Sessions, um während eines Besuchs (oder auch darüber hinaus) Informationen ablegen zu können. Diese beiden Datenspeicher entfalten ihr volles Potenzial allerdings erst, wenn ihnen dynamisch Werte zugewiesen werden können. Natürlich wäre es nicht undenkbar, dass \idename{} auch hier eine spezielle Lösung zur Verfügung stellt. Sinnvoller erscheint aber die Verwendung einer "`normalen"' Programmiersprache, was außerhalb des abgesteckten Umfangs dieser Arbeit liegt und daher nicht weiter betrachtet wird (vergleiche \fullref{scope:no-programming}).

\subsubsection{Evaluation existierender Templatingsprachen}
\label{sec:eval-templating-language}

Dieses Kapitel beschäftigt sich mit der Wahl einer Templatingsprache für \idename{}. Mit dieser soll die \texttt{HTML}-Ausgabe durch die Einführung von auswertbaren Ausdrücken, Wiederholungen und bedingten Anweisungen zur Laufzeit beeinflusst werden können. Eine zunächst naheliegende Wahl dafür wären vollwertige Programmiersprachen wie \texttt{PHP}, Python oder Ruby. Diese werden jedoch aus den folgenden Gründen nicht berücksichtigt:

\begin{itemize}[noitemsep]
\item Die Möglichkeit der Definition von eigenen Datenstrukturen, Funktionen, Ausnahmebehandlung, ... sind in \texttt{HTML}-Vorlagen nicht von Bedeutung. Analog zu \texttt{SQL} müssten bei der Verwendung von vollwertigen Programmiersprachen also wieder eine dem Einsatzzweck angemessene "`Teilsprache"' definiert werden.
\item \idename{} möchte eine klare Trennung von Präsentations- und Anwendungslogik fördern, die Mächtigkeit dezidierter Programmiersprachen verwischt diese Grenze jedoch: Plötzlich könnten Operationen wie Aggregation nicht nur in \texttt{SQL} ausgedrückt werden, sondern auch durch Schleifen im Template. Und Veränderungen am Datenbestand nehmen nicht mehr zwingend den Weg über eine in \idename{} definierte mutierende Abfrage, sondern werden direkt in das Template eingebettet.
\item Die Mächtigkeit dieser Sprachen geht fast zwangsläufig mit einer inkonsistenten Syntax zur Einbettung von Ausdrücken einher. Zwar kennen viele Skriptsprachen spezielle Modi in denen das Ergebnis eines Ausdrucks direkt in das Dokument geschrieben wird\footnote{In \texttt{PHP} ist beispielsweise \texttt{<?= \$var ?>} in etwa äquivalent zu \texttt{<?php echo \$var ?>}.}, in Einzelfällen, insbesondere bei Iterationen, muss dann allerdings doch mit Funktionen wie \texttt{echo} oder \texttt{print} gearbeitet werden.
\item Der große Umfang dieser Sprachen führt zu Einschränkungen, die einem Lernenden willkürlich vorkommen müssen. Zum Beispiel handelt es sich bei dem Bezeichner "`\texttt{class}"' in vielen Sprachen um ein reserviertes Schlüsselwort, welches daher an bestimmten Orten einfach nicht verwendet werden darf. Die Details der gewählten Templatingsprache ziehen sich dann entweder bis ins Datenmodell (Schlüsselwörter der Sprache könnten dort schlicht verboten werden) oder erfordern spezielle syntaktische Konstrukte.
\end{itemize}

Letztendlich liegen diese Sprachen aus gutem Grund außerhalb des abgesteckten Umfangs dieser Arbeit (vergleiche \fullref{scope:no-programming}): Eine vernünftige Integration mit vollwertigen Programmiersprachen, und sei es auch "`nur"' für die Templating-Logik, wirft schlichtweg zu viele weitere Fragen auf.

Stattdessen soll an dieser Stelle eine Domänenspezifische Sprache zum Einsatz kommen. Diese dezidierten Templatingsprachen fügen sich so knapp und organisch wie möglich in den umliegenden \texttt{HTML}-Kontext ein und erlauben keine komplizierte Logik. Und auch wenn \idename{} zu einem späteren Zeitpunkt nicht mehr nur \texttt{SQL} als alleinige Sprache für die Anwendungslogik vorsehen sollte, wird die klare Trennung zwischen Programmlogik und Oberflächendarstellung aller Voraussicht nach beibehalten werden.

Es gibt eine Vielzahl unterschiedlicher Textauszeichnungssprachen für Webseiten, nicht alle eignen sich allerdings, um dynamisch zur Laufzeit Seiten zu erzeugen. Für \idename{} wurden darüber hinaus zunächst die folgenden Kriterien angelegt, um die Anzahl verfügbarer Sprachen schnell zu reduzieren:

\begin{description}[noitemsep]
\item[Datenanbindung] \hfill \\
  An vordefinierten Stellen im Quelltext müssen zur Laufzeit dynamische Werte eingesetzt werden können.
\item[Kontrollstrukturen] \hfill \\
  Es muss möglich sein, unterschiedliche Ausgaben in Abhängigkeit von zur Laufzeit ausgewerteten Bedingungen zu erzeugen und Anweisungen wiederholt auszuwerten.
\item[Freie Verfügbarkeit] \hfill \\
  Die Verwendung von proprietären oder kostenpflichtigen Abhängigkeiten in \idename{} ist zumindest im Rahmen dieser Thesis ausgeschlossen.
\item[Einbettung von reinem HTML] \hfill \\
  Erfahrenen Entwicklern soll es grundsätzlich möglich sein, ihre \texttt{HTML}-Kennt\-nisse in vollem Umfang anzuwenden. Sofern die Templatingsprache also \texttt{HTML}-Be\-stand\-teile bereinigt, muss es eine Möglichkeit geben, diese Bereinung lokal zu deaktivieren.
\end{description}

Diese Kriterien filtern reine Textauszeichnungssprachen, wie sie in Foren- oder Kommentarsystemen genutzt werden aus. Weder Markdown\footnote{\url{http://daringfireball.net/projects/markdown/} ist die am häufigsten zitierte Spezifikation} noch \texttt{BB}-Code\footnote{Ein Quasi-Standard ohne offizielle Spezifikation, \url{https://de.wikipedia.org/wiki/BBCode}} oder Textile\footnote{Ein Quasi-Standard ohne offizielle Spezifikation, \url{https://de.wikipedia.org/wiki/Textile}} erlauben nativ die programmatische Einbindung von externen Daten. Die innerhalb der Wikipedia genutzte "`Wikisyntax"' erlaubt zwar eine einfache Datenanbindung, kennt aber keine Kontrollstrukturen.

Für eine endgültige Entscheidungen sollen Kandidaten anhand der folgenden Kriterien sowohl qualitativ als auch im Rahmen eines einfachen Scoring-Modells verglichen werden. Die quantitative Auswertung findet sich am Ende dieses Kapitels in Tabelle~\ref{tab:scoring-templating-language}, die qualitative Auswertung findet sich im Anschluss an die Kriterien.

\begin{description}
\item[Geringe Technische Komplexität, 5 Punkte] \hfill \\
  Da \idename{}-Seiten serverseitig gerendert werden sollen, ist es nicht notwendig auf eine komplexe Templatingsprache mit Funktionen wie einem virtuellen Document-Object-Model (\texttt{DOM}) zurückzugreifen. Es gilt die Prämisse: Je komplizierter das interne Verarbeitungsmodell der Sprache ist, desto mehr unverständliche Fehler können auftreten.
\item[Geringe Syntaktische Komplexität, 5 Punkte] \hfill \\
  Die Syntax sollte konsistent sein und optimalerweise nur sehr wenige Syntaxelemente einführen. Je einfacher die Syntax der Sprache ist, desto näher kann die abstrakte Darstellung im Editor den tatsächlich erzeugten Dokumenten sein.
\item[Verbreitung, 3 Punkte] \hfill \\
  Einige Templatingsprachen haben Einzug in eine Vielzahl unterschiedlicher Softwareprojekte gefunden, andere sind im Hinblick auf spezielle Frameworks zugeschnitten. Je weiter die Templatingsprache verbreitet ist, desto höher die Chance, dass ein Lernender sie möglicherweise auch einmal außerhalb von \idename{} einsetzen kann.
\item[Einfache Erweiterbarkeit, 3 Punkte] \hfill \\
  Perspektivisch sollen die Lernenden anhand von \idename{} auch in die "`normale"' Programmierung eingeführt werden können. Vor diesem Hintergrund wäre es von Vorteil, wenn die Templatingsprache eine einfache Programmierschnittstelle bietet, um eigene Funktionen einzubetten.
\item[Sprachübergreifende Implementierungen, 3 Punkte] \hfill \\
  Existiert lediglich die Referenzimplementierung einer Templatingsprache oder gibt es auch alternative Implementierungen? Dieser Aspekt ist nicht nur ein guter Indikator für die tatsächliche Verbreitung einer Templatingsprache, er könnte perspektivisch im Falle eines Exports von Projekten aus \idename{} auch praktische Bedeutung haben.
\end{description}

Diesen Kriterien stellen sich die Templatingsprachen Liquid\footnote{\url{http://liquidmarkup.org/}}, Angular 2\footnote{\url{https://angular.io/docs/ts/latest/guide/template-syntax.html}} und Handlebars\footnote{\url{http://handlebarsjs.com/}}. Liquid wurde schon im Rahmen der vergleicharen Arbeiten (\fullref{sec:software-jekyll}) kurz vorgestellt und bot sich dementsprechend als Kandidat an. Da für die Implementierung des \idename{}-Frontend Angular 2 ohnehin zum Einsatz kommt (siehe \fullref{sec:implementation-analysis}), stellt sich die Frage, ob die Nutzung eines weiteren Frameworks tatsächlich notwendig ist. Möglicherweise könnte durch die Vermeidung einer weiteren Abhängigkeit ja auch Aufwand gespart werden? Handlebars wird unter anderem in den Bibliotheken Meteor und Ember.js verwendet und wurde schlicht aufgrund seiner Popularität ausgewählt.

Um die Komplexität der Technik zu bewerten, wird zunächst das Ergebnis des Rendervorgangs betrachtet: Sowohl die Referenzimplementierungen von Handlebars als auch Angular 2 generieren JavaScript, welches die sich ergebende \texttt{HTML}-Struktur unmittelbar in den \texttt{DOM}-Baum des Browsers injiziert. Angular 2 geht noch einen Schritt weiter und gibt die neue Struktur nicht ungefiltert an den Browser weiter, sondern erstellt mit Hilfe eines speziellen Baumes zur Isolation von Veränderungen einen Satz an inkrementell nötigen Änderungen. Das Ergebnis eines Rendervorgangs mit Liquid ist hingegen ein einfacher String mit dem gerenderten Template.

Und natürlich spielt für die Technik auch die Parametrisierung eine Rolle: Bei Handlebars und Liquid ist es in der Referenzimplementierung möglich, zum Rendern einfach eine Funktion mit zwei Parametern aufzurufen: einmal das Template als normale Zeichenkette und dann die Daten als "`normale"' Datenstruktur. Angular 2 stellt wesentlich komplexere Anforderungen, dort muss ein spezielles Datenmodell für die Präsentationsschicht bereitgestellt werden.

Um die Syntax zu vergleichen, soll der in Listing~\ref{lst:data-control-structures} angedeutete Datenbestand für einen Blogeintrag gerendert werden. Dieses Beispiel ergänzt die exemplarische \texttt{article}-Tabelle um die Spalten \texttt{private} und eine Aufzählung von Kategorien.

\begin{lstlisting}[float=h!, language=JavaScript, caption={JSON-Darstellung eines exemplarischen Datenbestandes}, label={lst:data-control-structures}]
{
  "query" : {
    "article" : {
      "article_id": 4,
      "author": "Alfred E. Neumann",
      "text": "<p>Dies ist ein Text mit HTML-Bestandteilen</p>",
      "private": false,
      "date": -549676800
    },
    "categories" : [
      { "name": "Huch" },
      { "name": "Hoff" }
    ],
  },
  "project" : {
    "name": "Beispielblog"
  }
}
\end{lstlisting}

Dieser Beispielartikel soll in den jeweiligen Sprachen wie folgt visualisiert werden:
\begin{itemize}[noitemsep]
\item Das Datum soll benutzerfreundlich formatiert werden.
\item Die Kategorien eines Beitrages sollen mit einer Schleife durchlaufen werden.
\item Der gesamte Beitrag soll nicht angezeigt werden, sofern er privat ist.
\item Die \texttt{HTML}-Bestandteile in Texten sollen erhalten bleiben.
\end{itemize}

Die \textbf{Liquid}-Syntax (Beispiel-Listing~\ref{lst:liquid-control-structures}) wurde grundsätzlich schon im Rahmen von Kapitel \fullref{sec:software-jekyll} betrachtet. An dieser Stelle sei daher nur noch ergänzt, dass Liquid von Haus aus \texttt{HTML} in \texttt{\{\{\}\}}-Ersetzungen maskiert. Es ist daher nötig, den Artikeltext in drei geschweiften Klammern zu notieren (Zeile 11), diese Syntax deaktiviert diese Sicherheitsfunktion. Die Formatierung der Datumsangabe funktioniert mit einer Syntax wie sie von \texttt{UNIX}-Pipes bekannt ist (Zeile 5), Argumente werden als unbenannte Parameter übergeben.

\begin{lstlisting}[float=h, language=HTML, numbers=left, caption={Blogartikel mit Liquid}, label={lst:liquid-control-structures}]
<h1>{{ project.name }}</h1>
{% if !query.article.private %}
  <h2>{{ query.article.title }}</h2>
  <div>Autor ist {{ query.article.author }}</div>
  <div>Beitrag vom {{ query.article.date | date: "%d.%b.%Y" }}</div>
  <ul>
    {% for query.categories %}
      <li>{{ name }}</li>
    {% endfor %}
  </ul>
  {{{ query.article.text }}}
{% else %}
  <h2>Dies ist eine private Seite</h2>
{% endif %}
\end{lstlisting}

Die Syntax von \textbf{Handlebars} ist der von Liquid bemerkenswert ähnlich und basiert ebenfalls auf geschweiften Klammern, welche sich optisch merklich vom normalen HTML-Inhalt abheben. Für Kontrollstrukturen kommt statt dem \texttt{\%}-Zeichen von Liquid eine Raute zum Einsatz. Listing~\ref{lst:handlebars-control-structures} zeigt, wie das einfache Datenmodell gerendert werden könnte.

Eine praktische syntaktische Eigenart von Handlebars ist die Tatsache, dass auch Schleifen mit einem \texttt{else}-Block für leere oder nicht vorhandene Listen ausgestattet werden könnten. In diesem Beispiel bringt diese Alternative allerdings keinen Mehrwert, weil der \texttt{<ul>}-Knoten außerhalb der Schleife notiert werden muss.

Um einen Ausdruck unverändert zu übernehmen, also inklusive aller HTML-Sonderzeichen, muss dieser wie in Liquid von drei geschweiften Klammern umgeben werden (Zeile 5). Statt der Pipe-Notation verwendet Handlebars eine an konventionelle Funktionsaufrufe angelehnte Syntax. Zu Beginn wird der Name genannt, in diesem Beispiel die nicht standardisierte Funktion \texttt{formatTime}, danach folgen durch Leerzeichen getrennte Parameter (Zeile 5).

\begin{lstlisting}[float=h, language=HTML, numbers=left, caption={Blogartikel mit Handlebars}, label={lst:handlebars-control-structures}]
<h1>{{ project.name }}</h1>
{{ #if !query.article.private }}
  <h2>{{ query.article.title }}</h2>
  <div>Autor ist {{ query.article.author }}</div>
  <div>Beitrag vom {{ formatTime query.article.date "%d.%b.%Y" }}</div>
  <ul>
    {{ #each query.article.categories }}
      <li>{{ this }}</li>
    {{ /each}}
  </ul>
  {{{ query.article.text }}}
{{ else }}
  <h2>Dies ist eine private Seite</h2>
{{ /if }}
\end{lstlisting}

\textbf{Angular 2} verzichtet auf nicht-\texttt{XML}-artige Erweiterungen und nutzt dafür eigene Knoten und Attribute. Darüber hinaus muss immer die Richtung der Datenbindung angegeben werden, dafür werden Attribute mit runden oder eckigen Klammern eingeschlossen. Im Beispiellisting~\ref{lst:angular2-control-structures} kommen allerdings ausschließlich eckige Klammern zum Einsatz, da nicht auf Ereignisse reagiert werden muss.

Kontrollstrukturen müssen entweder in speziellen \texttt{<template>}-Knoten notiert werden (Zeile 2) oder mit einem \texttt{*}-Präfix als Attribut notiert werden (Zeile 11). In diesem Fall ist die Verwendung der \texttt{<template>}-Schreibweise für die oberste Unterscheidung notwendig, weil für den Blogbeitrag kein "`zusammenfassender"' Elternknoten eingefügt werden soll. In der unteren Unterscheidung kann der optionale Knoten hingegen als Ganzes angezeigt oder entfernt werden, daher ist hier die kompaktere \texttt{*}-Notation möglich. Eine Notation für \texttt{else}-Blöcke existiert nicht, komplexere Ausdrücke werden daher typischerweise nicht im Template-Code notiert, sondern bereits vorher in den Daten hinterlegt und dann in einem zweiten \texttt{ngIf} negiert.

Auch Angular 2 wird \texttt{HTML}-Inhalte im Normalfall maskieren. Um diese Beschränkung zu umgehen, können die entsprechenden Daten entweder in der Programmlogik als "`sicher"' markiert werden oder direkt an das \texttt{innerHtml}-Attribut gebunden werden (Zeile 9).

\begin{lstlisting}[float=h, language=HTML, numbers=left, caption={Blogartikel mit Angular 2}, label={lst:angular2-control-structures}]
<h1>{{ project.name }}</h1>
<template [ngIf]="!query.article.private">
  <h2>{{ query.article.title }}</h2>
  <div>Autor ist {{ query.article.author }}</div>
  <div>Beitrag vom {{ query.article.date | date: "%d.%b.%Y" }}</div>
  <ul>
    <li *ngFor="let cat in query.categories">{{ cat.name }}</li>
  </ul>
  <div [innerHtml]="query.article.text"></div>
</template>
<h2 *ngIf="query.article.private">
  Dies ist eine private Seite
</h2>
\end{lstlisting}

Für Handlebars und Liquid existieren Implementierungen in unterschiedlichen Programmiersprachen, zumindest für Ruby, JavaScript und \texttt{PHP} scheinen diese Portierungen auch sinnvoll zu funktionieren. Angular 2 hingegen wird zwar für mehrere Sprachen angeboten, in der Praxis kompilieren diese aber alle zu JavaScript.

Jeder der betrachteten Sprachen macht es möglich, die Funktionalität im Rahmen der jeweiligen Syntax zu erweitern. Für Handlebars und Liquid existieren in allen betrachteten Implementierungen einfache Möglichkeiten Funktionen zu hinterlegen, um neue Schlüsselwörter zu registrieren. Angular sieht zur Erweiterung die Programmierung neuer Komponenten vor, welche sich dann als neue Attribute oder Knoten sehr organisch einbetten lassen. Das ist im Endergebnis zwar sehr ansehnlich, die Definition solcher Komponenten erfordert aber vertiefte Kenntnisse der internen Arbeitsweise von Angular 2.

Für alle hier betrachteten Templatingsprachen gilt ebenfalls, dass sie jenseits von Entwicklerkreisen nicht besonders verbreitet sind. Typische Webseiten benötigen natürlich auch keine umfangreiche Logik, um zum Beispiel einem Benutzer zu ermöglichen, einen Kommentar zu schreiben. Im Internet-Alltag werden die Lernenden von diesen Kenntnissen also wohl nicht profitieren.

Sollten Lernende hingegen selbstständig (und jenseits von \idename{}) Zeit in die Erstellung eigener Webseiten investieren wollen, werden sie dabei häufiger mit Liquid in Berührung kommen. Programme zum generieren von statischen Webseiten verwenden häufig Liquid als Templatingsprache, das gilt insbesondere für das schon vorgestellte Jekyll, welches wiederrum (unter anderem) auch auf Github-Pages\footnote{Dokumentation zum Hosting verfügbar unter \url{https://pages.github.com/}} zum Einsatz kommt. Dieser konkrete Dienst, also Github-Pages, ist interessant, weil er vollkommen kostenfrei genutzt werden kann. Darüber hinaus wird Liquid in den Software-as-a-Service Angeboten von kommerziellen Anbietern wie Salesforce\footnote{\url{https://support.desk.com/customer/portal/articles/2916-list-of-liquid-variables}} oder Shopify\footnote{\url{https://help.shopify.com/themes/liquid}} genutzt. Angular und Handlebars werden hingegen faktisch ausschließlich in entwicklerorientierten JavaScript-Bibliotheken verwendet.

Auch wenn für die Lernenden von der konkreten Syntax der Templatingsprache abstrahiert werden soll, wird es immer wieder zu Momenten kommen, in denen diese Abstraktion löchrig ist\footnote{\url{http://www.joelonsoftware.com/articles/LeakyAbstractions.html}}. Die häufigste Ursache für ein solches Leck werden dabei Fehlermeldungen sein: Sobald diese auftreten, sollte zur Unterstützung der Fehler im generierten Quelltext angezeigt und möglichst hervorgehoben werden. Im Falle von Angular 2 wären die angezeigten Quellen für die Zielgruppe absolut unverständlich.

Letzten Endes stellt sich daher nur die Frage, ob Handlebars oder Liquid zum Einsatz kommen sollte: Angular 2 ist sowohl technisch als auch syntaktisch sehr kompliziert und eignet sich daher nicht besonders gut als "`erste Templatingsprache"'. Die qualitative Entscheidung fiel dabei zugunsten von Liquid und berücksichtigt vor allem die geringe technische Komplexität. Diese Entscheidung wird von der quantitativen Auswertung in Tabelle~\ref{tab:scoring-templating-language} in jeder Einzeldisziplin bestätigt. Die Tatsache, dass die Referenzimplementierung von Liquid wie der \idename{}-Server in Ruby entwickelt wird, ist ein netter zusätzlicher Faktor. Er wird zwar von der quantitativen Auswertung nicht berücksichtigt, gesucht wurde schließlich die "`allgemein beste"' Lösung, erleichtert aber erfreulicherweise zusätzlich die Implementierung.

\begin{table}[h]
  \centering
  \begin{tabular}{ l c c c }
                      & Liquid   & Handlebars      & Angular 2   \\
    \hline
    Einfache Technik  & 5        & 3               & 2           \\
    Einfache Syntax   & 5        & 5               & 3           \\
    Verbreitung       & 3        & 3               & 1           \\
    Erweiterbar       & 3        & 3               & 2           \\
    Übergreifend      & 3        & 2               & 0           \\
    \hline \hline
                      & 19       & 15              & 8
  \end{tabular}
  \caption{Scoring-Modell für evaluierte Templatingsprachen}
  \label{tab:scoring-templating-language}
\end{table}

Ebenfalls nicht entscheidend, aber erfreulich, ist der Umstand, dass mit Liquid beliebige Textdateien angereichert werden können, da die Struktur des umgebenden Dokuments vom Liquid-Renderer ignoriert wird. Dieser kümmert sich lediglich um die eingebetteten Anweisungen und behandelt alle Teile dazwischen als einfachen \texttt{string}. Für \idename{} hat dieser Umstand vor allem zur Folge, dass für andere Arten von Dokumenten nicht zwingend eine weitere Templatingsprache notwendig wäre. Zum Beispiel wäre ebenfalls die Bereitstellung einer "`entwickler-generierten"' \texttt{robots.txt}\footnote{Diese Datei wird von Suchmaschinen ausgewertet, um gewisse Teile der Seite von der Indexierung auszuschließen.} oder Sitemap\footnote{Typischerweise ein XML-Dokument, welches alle zu indexierenden Seiten mit einigen Metadaten, zum Beispiel der Frequenz von Veränderungen, auflistet.} möglich. Mit rein auf die Generierung von \texttt{HTML} ausgelegten Sprachen wäre dieser Einblick nicht möglich.

\subsubsection{Die Templatingsprache Liquid}
\label{sec:liquid-language}

Auch wenn die Schüler mit der Syntax der verwendeten Templatingsprache in der finalen Version von \idename{} nur oberflächlich in Berührung kommen sollen, wird Liquid an dieser Stelle sehr knapp und formal vorgestellt. Aufbauend auf dieser Vorstellung wird dann untersucht, wie die entsprechenden Funktionalitäten den Lernenden gezielt vermittelt werden können. Und abgesehen davon sollen Schüler den gesamten Umfang der Sprache bei Bedarf (oder Interesse) perspektivisch auch textuell nutzen können.

Grundsätzlich wird in Liquid zwischen drei verschiedenen Arten von Anweisungen mit jeweils eigener Syntax unterschieden:

\begin{description}
\item[Objekte] \hfill \\
  In das Dokument eingebettete Bezeichner werden in doppelt geschweiften Klammern notiert (\texttt{\{\{Objekt\}\}}) und dann zur Laufzeit durch den hinterlegten Wert ersetzt. Konstante Strings werden in Anführungszeichen notiert, Zahlen und boole\-sche Werte (also \texttt{true} und \texttt{false}) stehen für sich selbst.
\item[Tags] \hfill \\
  Tags steuern den Programmfluss mit Anweisungen wie \texttt{if} und \texttt{for}. Um sie von interpolierten Werten zu unterscheiden, werden diese Anweisungen in \texttt{\{\% \%\}}-Klam\-mer\-paaren notiert.
\item[Filter] \hfill \\
  Mit Filtern können in Ausdrücken genutzte Daten manipuliert werden. Sie funktionieren nach dem gleichen Prinzip wie Pipes auf der Kommandozeile und ermöglichen es, die Repräsentation von Daten zu verändern. Jeder Wert kann über einen Filter modifiziert werden, der Ausdruck \texttt{\{\{~'miXeD cAse'~|~downcase~\}\}} würde also zu \texttt{'mixed case'} ausgewertet werden.
\end{description}

Alle diese Anweisungen beziehen sich immer auf einen vordefinierten Datenbestand, welcher dem Renderer zusammen mit dem eigentlichen Template übergeben wird. Dieser Datenbestand gliedert sich in Name-Wert-Paare, Listen und atomare Werte, die Navigation erfolgt mittels des \texttt{.}-Operators für Zugriffe auf benannte Schlüssel oder mit dem \texttt{[]}-Operator für einzelne Werte eines Arrays.

Verschiedene Werte können mit den typischen Vergleichsoperatoren (\texttt{==}, \texttt{!=}, \texttt{>}, \texttt{<}, \texttt{>=}, \texttt{<=}) zu booleschen Ausdrücken kombiniert werden. Für Zeichenketten existiert noch der infix-notierte \texttt{contains}-Operator, um zu prüfen, ob eine Zeichenkette in einer anderen enthalten ist. Mehrere Ausdrücke können dann ihrerseits  mit \texttt{and} und \texttt{or} kombiniert werden. Dabei werden stets die mit \texttt{and} verknüpften Ausdrücke vor jenen, die mit einem \texttt{or} verknüpft sind, ausgewertet. Der Ausdruck (\texttt{true or false and false}) wird folglich nicht von links nach rechts ausgewertet, sondern ergibt insgesamt \texttt{true}. Diese Reihenfolge kann nicht beeinflusst werden, Klammern in Liquid-Ausdrücken sind ein Syntaxfehler.

Neben dem schon häufig erwähnten \texttt{if}-Tag stehen zur Beeinflussung des Kontrollflusses aber noch einige weitere Tags bereit: Verkettungen sind über \texttt{elsif}- und \texttt{else}-Tags möglich, bei \texttt{unless} handelt es sich schlichtweg um ein negiertes \texttt{if}. Und wie in anderen Programmiersprachen existiert auch in Liquid ein \texttt{case}- / \texttt{when}-Konstrukt, um auf verschiedene Ausprägungen eines einzelnen Wertes zu reagieren.

Iteriert wird in Liquid hauptsächlich mit dem schon oberflächlich betrachteten \texttt{for}-Tag. Die grundsätzliche Syntax lautet dabei "`\texttt{for~\textit{varname}~in~\textit{collection}}"', wobei \texttt{varname} der Bezeichner der Iterationsvariable ist und \texttt{collection} der Container, über den iteriert werden soll. Auf ein \texttt{for}-Tag kann ein \texttt{else}-Tag folgen, welches dann im Fall eines leeren Containers angezeigt wird.

Anfang und Ende der Iteration kann über die Eigenschaften \texttt{offset} und \texttt{limit} gesteuert werden. Mit der Angabe "`\texttt{for item in collection offset:20,~limit:10}"' kann zum Beispiel von Element \#20 an über maximal 10 weitere Elemente iteriert werden. Mittels der Angabe \texttt{reversed} kann die Iterationsreihenfolge umgedreht werden.

In Schleifen ist ein Objekt names \texttt{forloop} verfügbar. Dieser verfügt in Abhängigkeit vom aktuellen Stand der Iteration über Eigenschaften wie \texttt{first}, \texttt{last} und \texttt{index}, um während der Iteration auf "`spezielle Durchläufe"' reagieren zu können.

Das wesentliche Tag zur Strukturierung der eigenen Webseite in logische Komponenten ist die \texttt{include}-Anweisung. Diese funktioniert ähnlich wie ein Funktionsaufruf mit Paremetern. Die konkrete Syntax für einen Aufruf wird in Listing~\ref{lst:liquid-include-caller} demonstriert, als aufgerufenes Template wird eine Liste von Kategorien gerendert (Listing~\ref{lst:liquid-include-template}). Mit dieser Anweisung können also in unterschiedlichen Kontexten identisch zu rendernde Bestandteile ausgelagert werden. Für den "`Beispielblog"' müsste die Aufzählung von Kategorien nicht mehr für Übersichts- und Detailseite dupliziert werden.

\begin{lstlisting}[float=h, language=HTML, caption={Verwendung der Liquid-Anweisung \texttt{include}}, label={lst:liquid-include-caller}]
{% include 'categories' categories: query.article_categories %}
\end{lstlisting}

\begin{lstlisting}[float=h, language=HTML, caption={\texttt{categories.liquid}, Template für die Liquid-Anweisung \texttt{include}}, label={lst:liquid-include-template}]
{% if categories.length > 0 %}
  <ul>
    {% for category in categories %}
      <li>{{ category.name }}
    {% endfor %}
  </ul>
{% else %}
  Keine Kategorien
{% endif %}
\end{lstlisting}

Perspektivisch wäre es natürlich interessant diese Mechanik auch unmittelbar in \idename{} verfügbar zu machen. Für den Augenblick ist diese Anweisung aber vor allem für die Implementierung relevant. Die in Kapitel \fullref{sec:complex-ui-elements} beschriebenen Funktionen könnten als Liquid-Templates bereitgestellt werden. Darüber hinaus ließen sich mit diesem Ansatz auch "`übergeordnete"' Seiten erstellen, wie sie oftmals für ein einheitliches Layout notwendig sind.

Bei den Filtern liegt eine funktionale Überschneidung mit den Projektionen in \texttt{SQL} vor, insbesondere im Hinblick auf die Textfunktionen (siehe \ref{feat:fun-casing} in Kapitel~\fullref{sec:sql-subset-expression}). Alle dort beschriebenen Funktionen könnten auch mit Liquid ausgedrückt werden. Und darüber hinaus kennt Liquid noch ein paar weitere Filter wie zum Beispiel \texttt{capitalize} (wandelt jeden Wortanfang in Großbuchstaben um), die keine Entsprechung in SQLite haben. Im Sinne einer Trennung von Datenmodell und Anzeigelogik ist es im Regelfall sinnvoll, diese Arten von Transformationen mit Liquid vorzunehmen, letzten Endes ist das aber eine Entscheidung der Lehrperson.

Die Einbindung von den schon erwähnten Textauszeichnungssprachen, wie zum Beispiel Markdown, könnte ebenfalls über Filter erfolgen. Für das Blogbeispiel wäre es folglich ein leichtes, zwar "`echtes"' \texttt{HTML} in den Artikeln zuzulassen, in den Kommentaren hingegen nur eine von Textauszeichnungssprachen zugelassene \texttt{HTML}-Teilmenge ohne gefährliche Inhalte zu erlauben.

\subsubsection{Layout}

Eine immer wiederkehrende Frage bei der Entwicklung von Webseiten ist die nach dem Layout der gesamten Seite. \idename{} orientiert sich explizit an dem "`Responsive Design"'-Paradigma, anstatt die Seiten für eine bestimmte Bildschirmgröße zu optimieren. Letztendlich soll sich eine gerenderte \texttt{HTML}-Seite auf mobilen Geräten also ebenso "`richtig"' anfühlen wie auf "`klassischen"' Computern.

Technisch gesehen erfolgt die Umsetzung eines responsiven Layouts über eine Vielzahl unterschiedlicher \texttt{CSS}-Direktiven, deren Erstellung oder Bearbeitung keinesfalls ein Kernbereich von \idename{} ist. Allerdings lassen sich auf den meisten Seiten immer wiederkehrende Strukturen feststellen: die Unterteilung der Seite in ein Raster aus Zeilen und Spalten. Diese Layoutstruktur wird mittlerweile von einer Vielzahl von vorhandenen \texttt{CSS}-Bib\-lio\-the\-ken und den \texttt{HTML5}-Flex\-boxen unterstützt und soll auch das grundsätzliche Gedankenmodell für die hier beschriebenen Oberflächen sein. Es ergeben sich daraus die folgenden Layoutelemente:

\begin{description}
\item[Zeilen] \hfill \\
  Zeilen enthalten eine oder mehrere Spalten, wobei jeder Inhalt zwingend in einer Spalte platziert werden muss. Die Höhe einer Zeile entspricht der Höhe der höchsten Spalte.
\item[Spalten] \hfill \\
  Die Breite einer Spalte wird in einem relativen Maß mit Bezug zu einer bestimmten Bildschirmgröße angegeben. So können für breite Bildschirme z.B. drei Spalten vorgesehen werden, für sehr schmale Geräte wie Smartphones hingegen nur eine Spalte. Sollte die Summe dieser Breitenangaben der Spalten die maximale Breite einer Zeile überschreiten, werden diese auf mehrere Zeilen umgebrochen.
\end{description}

\begin{figure}[t]
  \begin{center}
    \resizebox{\textwidth}{!}{%
      \includegraphics[height=6.5cm]{sketches/grid-example-desktop}%
      \quad
      \includegraphics[height=6.5cm]{sketches/grid-example-mobile}%
    }
  \end{center}
  \caption{Identische Layoutstruktur auf großen und kleinen Bildschirmen. Der Navigationsbereich wird für den kleinen Bildschirm nur auf Aufforderung eingeblendet.}
  \label{fig:grid-example}
\end{figure}

Abbildung~\ref{fig:grid-example} zeigt das identische Layout aus Zeilen und Spalten in der Darstellung auf unterschiedlich großen Anzeigegeräten. Auf keinem der Geräte werden die beiden obersten Zeilen für den Header und die Pfadangabe weiter in Spalten unterteilt. Diese bestehen technisch gesehen also aus einer einzigen, sehr breiten Spalte.

Die dritte Zeile enthält drei Spalten (Navigation, Inhalt und eine Leiste für Module), wobei diese letzte Modulspalte wiederum mehrere Zeilen enthält. In der mobilen Ansicht wird die Navigationsleiste möglicherweise dynamisch verborgen und kann mit dem Dreieck im Header angezeigt werden. Die Module wandern in dieser Ansicht unter den Inhalt.

\subsubsection{\texttt{HTML}-Bedienelemente}

Grundsätzlich lassen sich alle Bedienelemente anhand der Struktur von Ein- und Ausgaben unterscheiden (Abbildung~\ref{fig:ui-element-concept}). Die Unterscheidung, ob eine Ein- bzw. Ausgabe exakt einen Wert oder alternativ mehrere (oder keinen) Wert(e) erwartet bzw. liefert, ist für die Oberfläche von zentraler Bedeutung. Die Kapitel \fullref{sec:design-ui-bind-output} und \fullref{sec:design-ui-bind-input} erläutern diese Unterscheidung noch einmal ausführlich.

\begin{figure}[t]
  \centering \input{images/ui-element-concept}
  \caption{Einordnung von Bedienelementen}
  \label{fig:ui-element-concept}
\end{figure}

Zwar sollen im Regelfall keine komplett statischen Seiten angezeigt werden, trotzdem muss es natürlich eine Möglichkeit geben statische Texte ohne Bindung an irgendwelche Abfragen zur Anzeige zu bringen. Die hier vorgestellten Bedienelemente funktionieren auch ohne jede Datenquelle, erlauben aber auch die Einbettung von Liquid-Objekten in den Text.

\begin{description}[noitemsep]
\item[Überschriften] \hfill \\
  \texttt{HTML} sieht die Verwendung von Überschriften in sechs Hierarchiebenen vor und stellt dafür distinkte Elemente zur Verfügung (\texttt{<h1>} bis \texttt{<h6>}). Dieser Umstand soll nicht unmittelbar abgebildet werden. Stattdessen gibt es ein allgemeines Bedienelement ``Überschrift'', zu dem sich dann eine Ebene angeben lässt.
\item[Absätze] \hfill \\
  Blöcke von zusammenhängendem Text werden als Absatz ausgezeichnet, das entsprechende \texttt{HTML}-Äquivalent ist das \texttt{<p>}-Element.
\item[Links] \hfill \\
  Um dem Endbenutzer die Navigation von einer Seite zur nächsten zu ermöglichen, kommen üblicherweise Links in Form von \texttt{<a>}-Elementen zum Einsatz. Wenn das Ziel des Links, also das \texttt{href}-Attribut, eine Seite des gleichen Projektes ist, sollte \idename{} die Gültigkeit der Angaben validieren.
\item[Formulare, Eingaben \& Knöpfe] \hfill \\
  Immer wenn vom Benutzer Werte abgefragt werden sollen, kommen dabei Formulare zum Einsatz. Auf diesen können mittels Eingabefeldern (\texttt{<input>}) und Auswahlelementen (\texttt{<select>}) Benutzereingaben getätigt werden. Aktionen werden dann mit einem Klick auf einen Knopf (\texttt{<button>}) ausgelöst, was wiederrum eine serverseitige Operation oder eine Navigation auslösen könnte.
\item[Bilder] \hfill \\
  Zwar syntaktisch betrachtet ein eher simples Unterfangen, für Schüler erfahrungsgemäß aber motivierend, ist die Einbindung von Bildern. Diese entsprechen einem \texttt{HTML}-\texttt{<img>}-Element, für welches das \texttt{src}-Attribut gesetzt werden muss.
\end{description}


\subsubsection{Komplexe Bedienelemente}
\label{sec:complex-ui-elements}

Viele im Desktopbereich "`typische"' Bedienelemente haben in reinem \texttt{HTML} keine Entsprechung. So gibt es zum Beispiel jenseits der \texttt{alert()} und \texttt{input()} Funktionen keine standarisierte Möglichkeit, modale Dialoge anzuzeigen. Stattdessen existieren je nach Einsatzzweck eine Vielzahl von Bibliotheken. So genannte "`Lightboxen"' kommen zum Einsatz, um Bilder nach einem Klick großformatig anzuzeigen, ohne dafür die aktuelle Seite zu verlassen. Und so ziemlich jedes größere \texttt{HTML}-Framework bietet Möglichkeiten, faktisch beliebige \texttt{HTML}-Strukturen im Vordergrund anzuzeigen.

Trotzdem haben sich viele Endanwender an komplexe Webanwendungen gewöhnt, deren Umsetzung um die Jahrtausendwende im Browser vollkommen undenkbar gewesen wäre. Diese Erwartungshaltung bringt \idename{} in ein Dilemma: Gibt man dieser Erwartungshaltung nach und bietet zahlreiche "`künstliche"' Bedienelemente für Spezialfunktionen an, hat das mit der Vermittlung von \texttt{HTML}-Kenntnissen nur noch am Rande etwas zu tun. Andererseits sollen die Lernenden mit "`praktisch vorzeigbaren Ergebnissen"' motiviert werden.

Um solche Arten von Bedienelementen umzusetzen, werden komplexe \texttt{CSS}-Eigenschaften für \texttt{HTML}-Block- oder -Inline-Elemente (also \texttt{<div>} und \texttt{<span>}) verwendet. Diese beiden Elemente haben keine unmittelbare inhaltliche Bedeutung, sondern ziehen diese aus den gesetzten Klassen oder IDs (also den Attributen \texttt{class} und \texttt{id}). Im Rahmen dieser Thesis wird die Unterstützung von diesen \texttt{CSS}-orientierten Elementen aber nicht weiter betrachtet (siehe \fullref{scope:no-design}).

Auch die semantisch bedeutungsvollen \texttt{HTML}-Elemente können aber durchaus kompliziert ausfallen. Dieses Spannungsfeld lässt sich gut anhand eines für \idename{} zentralen Bedienelements diskutieren: der Tabelle. Aus didaktischer Sicht scheint es sinnvoll, den Lernenden dieses Element möglichst frühzeitig vorzustellen. Immerhin wird bei den Abfragen mit tabellarischen Daten gearbeitet, da liegt es nahe, diese Daten in der Oberfläche zunächst auch auf genau diese Art und Weise zu präsentieren.

Allerdings handelt es sich bei Tabellen um eine der deutlich komplizierteren \texttt{HTML}-Konstrukte. Es besteht typischerweise aus zwei unmittelbaren Kindelementen, nämlich \texttt{<thead>} für die Spaltenüberschriften und \texttt{<tbody>} für die eigentlichen Daten. Für neue Zeilen kommen dann die "`Table Row"'-Elemente \texttt{<tr>} zum Einsatz, Zellen werden in den Überschriften dann in \texttt{<th>}-Knoten ("`Table Head"') und im Rumpf mit \texttt{<td>}-Knoten ("`Table Data"') notiert. Und natürlich muss die Anzahl dieser durch Zellenknoten definierten Spalten über alle \texttt{<tr>}-Elemente hinweg identisch sein\footnote{Eine mögliche Ausnahme hiervon wäre theoretisch das \texttt{colspan}-Attribut. Dadurch wird die Implementierung jedoch lediglich noch komplizierter.}. Erfahrungsgemäß bereitet es Anfänger auch immer wieder Probleme, dass die in der Tabelle nebeneinander angezeigten Zellen im \texttt{HTML}-Quelltext typischerweise untereinander notiert werden. Und damit nicht genug: Um wirklich alle Zeilen einer Abfrage anzuzeigen, ist die Verwendung von geschachtelten Schleifen für Zeilen und Spalten notwendig. Listing~\ref{lst:html-table-pure} zeigt exemplarisch, wie der nötige Quelltext aussehen könnte.

\begin{lstlisting}[language=HTML, float=h, caption={Code für eine \texttt{HTML}-Tabelle mit Datenanbindung}, label={lst:html-table-pure}]
<table>
  <thead>
    <tr>
      {% for name in data.columnNames %}
        <th>{{ name }}</th>
      {% endfor %}
    </tr>
  </thead>
  <tbody>
    {% for row in data.rows %}
      <tr>
        {% for name in data.columnNames %}
          <td>{{ row[name] }}</td>
        {% endfor %}
      </tr>
    {% endfor %}
  </tbody>
</table>
\end{lstlisting}

Mit Liquid bietet sich allerdings auch die Möglichkeit, diesen Code weitestgehend vor den Lernenden zu verstecken. Listing~\ref{lst:html-table-liquid} illustriert, wie mit der Verwendung des \texttt{include}-Tags die Einbindung der Tabelle auf die Angabe der darzustellenden Zeilen und Spalten reduziert wird. Dabei handelt es sich natürlich nicht um die exakte Darstellung, wie sie innerhalb eines Drag \& Drop-Editors dargestellt werden sollte.

\begin{lstlisting}[language=html,float=h,caption={Code für eine Liquid-Tabelle mit Datenanbindung}, label={lst:html-table-liquid}]
{% include "query_table" 
     data: query.alle_kommentare,
     columns: ["spalte_a","spalte_b"] %}
\end{lstlisting}

\subsubsection{Bindung von Abfragen an die Oberfläche}
\label{sec:design-ui-bind-output}

Die vergangenen Kapitel haben demonstriert, wie mit Liquid auf prinzipiell beliebige Datenstrukturen zugegriffen werden kann. Aber wie sollten die Ergebnisse der verfügbaren Abfragen bereitgestellt werden? Auf abstrakter Ebene ist die Beantwortung dieser Frage eindeutig: Da das Ergebnis einer \texttt{SQL}-Abfrage grundsätzlich eine Tabellenstruktur mit Zeilen, Spalten und Zellen ist, wird dieses Datenmodell auch für die Oberfläche zugrunde gelegt. Die an die Bedienelemente zu bindenden Daten sind also grundsätzlich tabellarischer Natur. Dabei bedürfen einige Details bezüglich der Benennung und der Indizierung jedoch besonderer Beachtung.

Um im Falle von mehreren in Frage kommenden Abfragen eine eindeutige Zuordnung vornehmen zu können, müssen Abfragen, deren Ergebnis an die Oberfläche gebunden werden soll, mit einem eindeutigen Namen bezeichnet werden. Dieser Name kann von den Entwicklern frei gewählt werden, sollte aber analog zu einem Funktionsbezeichner sinnvoll darüber Auskunft geben, was eine Abfrage bewirkt. Diese Trennung zwischen dem Namen der Abfrage innerhalb des Projekts und dem Namen innerhalb des \texttt{query}-Namensraums erlaubt die mehrfache Verwendung von ein und derselben (vermutlich unterschiedlich parametrisierten) Abfrage auf der gleichen Seite.

Der Umgang mit den Zeilen erfordert keine Sonderbehandlung, hier genügt die Angabe eines Zeilenindexes. Im Normalfall wird die Iteration sowieso nicht explizit über den Index, sondern implizit über die Elemente stattfinden. Für die Spalten entfällt glücklicherweise eine "`künstliche"' Benennung, diese werden trivialerweise über ihren Namen entsprechend der \texttt{SELECT}-Komponente angesprochen. Mit diesen drei Werten (Name der Abfrage, Zeilenindex, Spaltenname) lässt sich jede Zelle einer Menge von Abfragen eindeutig identifizieren.

Aus praktischen Gründen sollten Abfragen allerdings bezüglich der Anzahl der erwarteten Zeilen annotiert werden, konkret unterschieden werden muss dabei zwischen "`exakt eine Zeile"' und "`beliebig viele (auch keine) Zeilen"'. Im Falle einer Abfrage mit nur einer Zeile entfällt dann die Notwendigkeit einen Zeilenindex anzugeben, dieser bezieht sich dann implizit immer auf die einzige, zur Verfügung stehende Zeile. Wenn Daten an die Oberflächen gebunden werden, entfällt durch diese Abkürzung die permanente Angabe einer redundanten Information. Listing~\ref{lst:sql:multi-row} zeigt eine Abfrage, die in Listing~\ref{lst:html:article-with-index} und \ref{lst:html:article-no-index} einmal mit und einmal ohne Index gebunden wird. Die Schreibweise ohne Index kommt der Lesbarkeit eindeutig zu gute.

\begin{lstlisting}[float=h, language=SQL, caption=Abfrage mit maximal einer Ergebniszeile,label=lst:sql:multi-row]
SELECT caption, text
FROM   article
LIMIT  1;
\end{lstlisting}

\begin{lstlisting}[float=h, language=HTML, caption=String-Interpolation mit Indexzugriff, label=lst:html:article-with-index]
<!-- query.article = Listing (*@\ref{lst:sql:multi-row}: \nameref{lst:sql:multi-row}@*) -->
{{ query.article[0].name }}, beginnt mit den folgenden Worten {{ query.article[0].text | truncatewords: 4 }}.
\end{lstlisting}

\begin{lstlisting}[float=h, language=HTML, caption=String-Interpolation mit implizitem Index, label=lst:html:article-no-index]
<!-- query.article = Listing (*@\ref{lst:sql:multi-row}: \nameref{lst:sql:multi-row}@*) -->
{{ query.article.name }}, beginnt mit den folgenden Worten {{ query.article.text | truncatewords: 4 }}.
\end{lstlisting}

Die Annotation "`Abfrage betrifft genau eine Zeile"' muss jedoch vom Entwickler manuell im \texttt{SQL}-Editor gesetzt werden, eine automatische Berechnung wäre für beliebige Abfragen unmöglich\footnote{Viele \texttt{SQL}-Dialekte sind Turing-Vollständig und schon das Halteproblem ist nicht entscheidbar.} und auch für speziell strukturierte Abfragen ist diese Unterscheidung zumindest nicht trivial. Oder um es anders auszudrücken: Die Erweiterung der Entwicklungsumgebung um diese automatische Vorhersage wäre Stoff für eine weitere wissenschaftliche Arbeit, keinesfalls aber Gegenstand dieser Arbeit. Praktischerweise lässt sich eine auftretende Verletzung dieser Annotation zur Laufzeit aber sehr gut erkennen und daher auch unmittelbar an den Entwickler oder Endanwender kommunizieren. 

Abfragen mit beliebig vielen Ergebniszeilen bedürfen zur Darstellung einer Schleife oder eines dezidierten komplexen Bedienelements. Auch hier könnte im Einzelfall die Behandlung eines leeren Ergebnisses sinnvoll sein, dann aber "`nur"' aus ästhetischen Gründen: Eine Schleife, die nicht ein einziges Mal durchlaufen wird, ist auch in Liquid kein Fehler.

Diese gesonderte Behandlung von bestimmten Tabellendimensionen ist übrigens keine Erfindung dieser Thesis: Auch \texttt{SQL} selbst hebt einige Abfragen mit speziellen Strukturen hervor. Tabellen mit nur einer Zelle können als skalarer Wert eingesetzt werden, bei nur einer Spalte können Abfragen z.B. für \texttt{IN}-Ausdrücke verwendet werden.

\subsubsection{Eingabe von Daten über die Oberfläche}
\label{sec:design-ui-bind-input}

Immer, wenn eine Abfrage mit Platzhaltern an eine Seite gebunden wird ist es notwendig, dem Benutzer eine Möglichkeit zu geben, diese Platzhalter zu füllen. Benutzereingaben sind in \texttt{HTML} nur zulässig, wenn sie innerhalb  eines \texttt{<form>}-Elements platziert werden. Für diese Formulare müssen entweder global im \texttt{<form>}-Element oder als Teil der vom Benutzer gedrückten Knöpfe stets die Methode der Übertragung (\texttt{method}, eines der \texttt{HTTP}-Verben \texttt{GET} oder \texttt{POST}) und eine Ziel-\texttt{URL} (\texttt{action}) angegeben werden. Diese Optionen zur Navigation werden im Rahmen von Kapitel \fullref{sec:concept-navigation} besprochen.

Jedes Kindelement eines Formulars muss mit einem Namen ausgestattet werden. Aus diesem Namen und dem vom Benutzer eingegebenen oder ausgewähltem Wert wird dann ein Schlüssel-Wert-Paar gebildet, welches zusammen mit der jeweiligen Anfrage versendet wird.

Im einfachsten Fall kann diese Bindung über simple \texttt{<input type=''text''>}-Elemente hergestellt werden. Das ist für viele Arten von Such- und Eingabemasken auch sicherlich ausreichend, führt jedoch zu Problemen bei Beziehungen zwischen Entitäten. In diesem Fall müsste in das Textfeld vom Benutzer ein Primärschlüssel eingegeben werden, was ganz sicher kein besonders benutzerfreundliches Konzept darstellt.

In einem solchen Fall soll es also möglich sein auch Bedienelememente wie Comboboxen zu verwenden, die ihrerseits wieder eine Abfrage zur Anzeige der zur Verfügung stehenden Daten benötigen. Dabei muss klar zwischen zwei benötigten Informationen unterschieden werden. Auf der einen Seite muss das Resultat eines solchen Bedienelements einen identifizierenden Wert zurückliefern, aller Regel nach vermutlich einen Primärschlüssel. Auf der anderen Seite erwarten die Benutzer aber die Anzeige von \enquote{intuitiven} Informationen, anhand derer sie ihre Auswahl treffen können. Der Primärschlüssel ist hingegen üblicherweise eine künstliche Spalte, welche für den Endanwender keinerlei Informationsgehalt hat.

Praktischerweise ist auch diese Unterscheidung in \texttt{HTML} vorgesehen: Bei einem \texttt{<select>}-Element wird explizit zwischen dem internen Wert (das Attribut \texttt{value}) und der Repräsentation für den Benutzer (der Inhalt des Elements) unterschieden. Listing~\ref{lst:html:select-example} demonstriert, wie diese Informationen mit Liquid im \texttt{<option>}-Element als Kinder eines \texttt{<select>}-Elements beschrieben werden. Die Darstellung in Browsern erfolgt in der Regel über eine Combobox.

\begin{lstlisting}[float,language=HTML, caption=Containerelemente mit Kindern, label=lst:html:select-example]
<!-- query.alle_artikel = "SELECT * FROM article" -->
<select>
  {% for article in query.alle_artikel %}
    <option value="{{ article.article_id }}">
      {{ article.article_id }}
    </option>
  {% endfor %}
</select>
\end{lstlisting}

\subsubsection{Navigation}
\label{sec:concept-navigation}

Die Navigation auf Webseiten teilt sich in zwei unterschiedliche Problemstellungen: Noch vor dem Rendervorgang stellt sich die Frage, zu welcher konkreten Seite eine beliebige \texttt{URL} aufgelöst werden soll. Und während der Generierung einer Seite müssen sich Verweise auf andere Seiten erzeugen lassen können.

Damit für jede relevante URL eindeutig ist, zu welcher Seite sie aufgelöst werden soll, könnte man in \idename{} eine zentrale Routing-Konfiguration hinterlegen. In dieser wird einer Menge von Pfaden, welche möglicherweise auch Platzhalter für Parameter vorsehen, mit den entsprechenden Zielseiten verknüpft. Solche Pfadangaben könnten für das Blogbeispiel wie in Listing~\ref{lst:central-routing-example} angedeutet repräsentiert werden. Bei dem \texttt{selector} handelt es sich um ein Prädikat, welches im Falle einer positiven Auswertung darauf hinweist, dass die entsprechende \texttt{page} dargestellt werden soll.

\begin{lstlisting}[float=h!, language=JavaScript, caption={Zentrales Routing für das Blog-Beispiel}, label={lst:central-routing-example}]
[
  { "selector": "/",             "page": "Hauptseite" },
  { "selector": "/beitrag/:id",  "page": "Artikel" },
]
\end{lstlisting}

Dabei bedürfen zwei Details besonderer Beachtung: Parameter in der \texttt{URL} werden mit der  \texttt{:parametername}-Notation eingeführt\footnote{Es handelt sich dabei um die gleiche Notation, wie sie von den Bibliotheken Sinatra oder Angular 2 verwendet wird.}. Außerdem handelt es sich um eine Liste von Regeln, die Reihenfolge der Einträge ist folglich von Bedeutung. Wenn ein hypothetischer Eintrag mit dem Selektor \texttt{/beitrag/test} eingeführt werden sollte, muss das auf jeden Fall vor dem Selektor \texttt{/beitrag/:id} geschehen. Andererseits passt der Parameter \texttt{:id} auf das \texttt{URL}-Segment \texttt{test} und maskiert diese Route. Unter dieser Randbedingung lässt sich dann aber die Abbildung $\mathtt{URL} \rightarrow \mathtt{Seite}$ eindeutig berechnen.

In diesem Datenmodell können allerdings Inkonsistenzen entstehen, wenn sich die Anzahl oder Benennung der für eine Seite erforderlichen Parameter verändert. Die Behandlung solcher Fehler erfordert allerdings grundsätzlich die Unterstützung des Entwicklers: Nur er kann entscheiden, ob eine umbenannte Variable auch unter neuem Namen semantisch gleichwertig ist. Es handelt sich also um ein Problem, dem am ehesten durch eine passende Benutzeroberfläche beizukommen ist.

Nachdem die zu rendernde Seite bekannt ist, stellt sich folglich die inverse Frage: Wie kann die \texttt{URL} zu einer bestimmten Seite generiert werden? Dabei stellt man zunächst fest, dass der \texttt{HTML}-Standard zwei unterschiedliche Mechanismen zur Navigation vorsieht. Die naheliegendste Variante ist die direkte Generierung eines \texttt{<a>}-Knotens mit dem passenden \texttt{href}-Attribut. Mit der Liquid-Syntax lassen sich beliebige Strings generieren, also auch gültige URLs. Allerdings funktioniert dieser Ansatz nur mit Daten, die auf dem Server während des Rendervorgangs bekannt sind. Benutzereingaben in Formularelementen wie \texttt{<input>} können in diesem Kontext nicht verwendet werden.

Es ist folglich schon aufgrund der Vorgaben des \texttt{HTML}-Standards sinnvoll, die Unterstützung von zwei separaten Mechanismen zur Navigation zu unterstützen: Sofern der Endanwender eigene Eingaben vornehmen soll, kommt ein \texttt{<form>}-Element zum Einsatz. Durch die Nutzung von versteckten Eingabelementen (\texttt{<input type=''hidden''>} können aber auch serverseitig vorhandene Daten, zum Beispiel aus Abfragen oder \texttt{GET}-Parametern innerhalb von Formularen, verwendet werden.

Um den Zugriff auf mutierende Abfragen zu ermöglichen, existiert für jede Seite noch ein spezieller \texttt{query/:queryName}-Unterpfad. Wenn eine unter \texttt{/beitrag/:artikel\_id} erreichbare Seite die Abfrage zum Hinzufügen eines neuen Kommentars (Listing~\ref{lst:sql-add-comment}) unter dem Namen \texttt{add\_comment} verfügbar machen möchte, sähe die vollständige Routendefinition aus wie folgt: \texttt{/beitrag/:artikel\_id/query/add\_comment}. Die Parameter der Abfrage (\texttt{article\_id}, \texttt{name} und \texttt{text}, das aktuelle Datum wird automatisch berechnet) müssen von der Seite (oder genauer: von dem Formular) bereitgestellt werden.

\begin{lstlisting}[float=h!, language=SQL, caption={Abfrage zum Hinzufügen eines neuen Kommentars}, label={lst:sql-add-comment}]
INSERT INTO comment (article_id, commenter_name, text, date)
VALUES (:article_id, :name, :text, strftime('%s','now'))
\end{lstlisting}

Abfragen werden immer mittels der \texttt{POST}-Methode ausgeführt und haben keine eigene Darstellung. Stattdessen leitet eine ausgeführte Abfrage normalerweise zur aufrufenden Seite zurück, auch eine Umleitung zu einer anderen Seite wäre aber denkbar. Diese Umleitung und die Übertragung via \texttt{POST} stellt sicher, dass ein Endanwender durch einfaches Neuladen der Seite eine Abfrage mehrfach ausführt.

\subsection{Drag \& Drop-Editor für Oberflächen}
\label{sec:drag-drop-ui-editor}

Nachdem das vorige Kapitel den technischen Unterbau für die mit \idename{} erstellten Seiten beschrieben hat, stellt sich die Frage, wie man diesen in eine angemessene Oberfläche "`verpacken"' kann. Diese Suche nach dem richtigen Editor für einen sowohl lehrreichen, als auch produktiven Seiten-Editor, wird sich wohl aller Voraussicht nach nicht mit einer definitiven Antwort abschließen lassen. Die Anzahl an möglichen Herangehensweisen ist immens, das zeigt schon die Vielfalt an existierenden und historischen Produkten zur Erstellung von Webseiten oder auch "`normalen"' Programmoberflächen. Die wesentlichen Leitfragen für dieses Kapitel sind daher die Folgenden:

\begin{enumerate}[noitemsep]
\item \textbf{Wie funktionieren andere, verbreitete Oberflächeneditoren und was kann \idename{} von ihnen lernen?} Insbesonders kommerzielle Produkte für "`normale"' Anwender werden im Regelfall auf einen hohen Produktivitätsgrad ausgerichtet sein, nicht auf einen nachhaltigen Lerneffekt. Und trotzdem stellt sich die Frage, nach welchen Mustern diese Werkzeuge funktionieren.
\item \textbf{Welches Abstraktionsniveau passt zur Zielgruppe von \idename{}?} Es gilt eine geeignete Balance zwischen vorzeigbaren Ergebnissen und nachhaltigem Lerneffekt zu finden. Diese Fragestellung hängt eng mit der gewählten Darstellung im Editor zusammen, daher werden die beiden wesentlichen Optionen zur Visualisierung in den kommenden Kapiteln besprochen.
\end{enumerate}

\subsubsection{Vor- und Nachteile von WYSIWYG-Darstellungen}
\label{sec:pro-con-wysiwyg-editor}

Eine typische Methode, um die Einstiegshürde für die Gestaltung von Oberflächen zu senken, ist die Verwendung von WYSIWYG-Editoren. Programmiersprachen wie Delphi oder Visual Basic verdanken einen Großteil ihrer initialen Popularität auch ihren Entwicklungsumgebungen, in denen eben diese Funktionalität prominent unterstützt wird. Diese \texttt{IDE}s ermöglichten schon zur Entwicklungszeit eine sehr gute Vorschau auf das endgültige Aussehen der aktuell bearbeiteten Oberfläche. Der zeitaufwändige Kreislauf aus "`Wert im Quelltext verändern $\rightarrow$  kompilieren $\rightarrow$ ausführen $\rightarrow$ zu korrekter Maske navigieren $\rightarrow$ Darstellung überprüfen $\rightarrow$ Wert erneut anpassen"' wird drastisch verkürzt.

Dieser Ansatz hat aber auch Grenzen: Ohne Kenntnis der genauen Datenbestände bleibt die Vorschau oftmals unvollständig. Und insbesondere bei sehr dynamischen Oberflächen mit vielen optionalen Bestandteilen, welche dann zur Laufzeit ein- oder ausgeblendet werden, im Editor aber stets sichtbar sind, gleicht die Vorschau innerhalb des WYSIWYG-Editors der Endbenutzeransicht dann doch nur noch sehr beschränkt.

Bei der Entwicklung von Desktopanwendungen ist auch heute noch die Verwendung eines WYSIWYG-Editors sehr verbreitet, allerdings werden die Beschreibungen der Oberflächen häufig in spezielle Textdateien ausgelagert. Diese lassen sich dann sowohl mit einem normalen Texteditor, als auch mit spezialisierten Editoren bearbeiten. Moderne Bibliotheken für Benutzerschnittstellen wie JavaFX, Android oder die \textit{Windows Presentation Foundation} (WPF) erlauben mit diesem Ansatz die größtmögliche Flexibilät: Jeder Programmierer kann entscheiden, ob er mit der Beschreibungssprache, dem grafischen Werkzeug oder beiden Herangehensweisen arbeiten möchte.

Auch zur Pflege und Generierung von Webseiten existieren und existierten eine Vielzahl unterschiedlicher WYSIWYG-Editoren wie Microsoft Frontpage, Adobe Dreamweaver,~... Diese spielen als Lösungen für hobbymäßige Webseitenbetreiber mittlerweile eine eher untergeordnete Rolle. Heute gängige Lösungen für den Betrieb eigener Webseiten bieten dem Endanwender als primäre Schnittstelle eine im Web verfügbare, administrative Oberfläche. Die meisten quelloffenen Content-Management-Systeme wie Wordpress, Joomla oder Typo3 fallen in diese Kategorie. Diese Oberfläche erlaubt es dabei aber vornehmlich, den eigentlichen Inhalt der Seiten zu verändern, weniger das Rahmenwerk außen herum. Fortgeschrittene Webentwickler halten sich daher von den WYSIWYG-Web-Editoren fern und editieren lieber unmittelbar die in \texttt{HTML} (oder Skriptsprachen) notierten Templates.

Ein allgemein "`bester"' Ansatz hat sich bis heute also nicht herausgebildet. Dennoch können die gängigen Ansätze zur Bearbeitung von Oberflächen recht gut anhand eines einzigen Merkmals kategorisiert werden: Wie weit ist die im Editor zu sehende Darstellung von der Darstellung im Browser des Endanwenders entfernt? Diese Frage ist natürlich sehr eng verknüpft mit dem fachlichen Hintergrund der Zielgruppe. Ein als "`Webseitenbaukasten für Jedermann"' beworbenes Produkt wird um eine möglichst originalgetreue Darstellung im Editor bemüht sein, fortgeschrittene Entwickler nutzen dann lieber einen Texteditor mit speziellen Hilfsfunktionen wie Syntaxvervollständigung.

Bei WYSIWYG-Webseiten-Editoren handelt es sich im Normalfall um sehr spezielle Anwendungen, mit denen man allerdings sehr schnell Ergebnisse erzielen kann. Hat man eine von Ihnen verstanden, kann der Umgang mit einem konkurierenden Produkt immer noch in vielen Belangen unterschiedlich ausfallen. \texttt{HTML}-Code schaut hingegen in allen Editoren gleich aus und leidet daher weniger unter einem "`Lock-in-Effekt"'.

Insbesondere bei der Visualisierung von Schleifen und bedingten Ausgaben kommt es beim WYSIWYG-Ansatz systemimmanent zu Problemen. Der darzustellende Datenbestand ist im Falle von \idename{} zwar bekannt, es müssen also immerhin keine künstlichen Daten für die Vorschau fingiert werden. Dennoch muss an irgendeiner Stelle der Vorschau auch ein aktuell inaktiver Zweig einer Bedingung oder der abstrakte Schleifenrumpf mit Variablen dargestellt werden können. Endbenutzer werden hingegen niemals beide Seiten einer \texttt{if/else}-Kombination oder die "`Vorlage"' für alle Schritte eines Schleifendurchlaufes zu Gesicht bekommen. Darüber hinaus gibt es in \texttt{HTML} auch noch einige unsichtbare Knoten wie zum Beispiel \texttt{<form>}, \texttt{<audio>} oder \texttt{<menu>}. Diese bedürfen einer "`künstlichen"' visuellen Repräsentation, damit sie bearbeitet werden können. Die WYSIWYG-Darstellung kann also prinzipiell nicht exakt wie beim Endanwender aussehen, sondern muss noch modifiziert werden.

Darüber hinaus bereitet auch das responsive Design der Vorschau Probleme: Es gibt schließlich nicht nur eine Art und Weise die Seite darzustellen, sondern mehrere. Zwischen diesen muss dabei zumindest umgeschaltet werden können.

Kein unlösbares, aber dennoch ein praktisches Problem bei der Implementierung von WYSIWYG-Editoren ist deren technische Komplexität. Grundsätzlich kann der Code zur Erzeugung der Darstellung für Endanwender nicht 1:1 für die editierbare Darstellung im Editor übernommen werden. Jedes Bedienelement muss im Endeffekt also doppelt implementiert werden\footnote{Im Falle von \idename{} ist das schon aufgrund der unterschiedlichen technischen Grundlagen für Server und Client notwendig (siehe Kapitel \fullref{sec:implementation-client-server}). Allerdings wird auch in Frameworks mit nur einer Codebasis, zum Beispiel in der .net-Bibliothek WPF, im Code von Bedienelementen explizit zwischen "`Designtime"' und "`Runtime"' unterschieden.}. Bei einer textuellen Repräsentation von \texttt{HTML}-Dokumenten im Editor kann die Darstellung allerdings ausgesprochen gut generalisiert werden. Schließlich handelt es sich im Kern um eine Baum-Darstellung mit einer sehr festen Struktur aus \texttt{XML}-Knoten mit Attributen.

Für einen WYSIWYG-Editor sind hingegen vielfältige Bearbeitungsmöglichkeiten erforderlich. Bilder bedürfen anderer Handgriffe als zum Beispiel Tabellen, Knöpfe oder Links. Um das System für die Entwickler der Entwicklungsumgebung wartbar und für die Lernenden verständlich zu halten, darf an dieser Stelle allerdings auch nicht blind eine spezielle Editorkomponente für jedes Bedienelement entwickelt werden. Es gilt vielmehr die möglichen Gemeinsamkeiten herauszuarbeiten und soweit wie möglich zu generalisieren. Ein dafür zu erstellendes Konzept wäre dabei sowohl technisch als auch fachlich kompliziert.

\subsubsection{Vor- und Nachteile einer Blockdarstellung}

Die Blockdarstellung, wie sie im Sinne dieses Kapitels verstanden wird, lehnt sich optisch an das Erscheinungsbild eines \texttt{HTML}-Text-Dokumentes an. Damit wird grundsätzlich ein ähnliches Ziel wie beim \texttt{SQL}-Editor verfolgt: Der Schritt vom \idename{}-Editor zu einem Texteditor ist nicht besonders groß, trotzdem können Syntaxfehler durch die Drag \& Drop-Bedienung unterbunden werden. Und weil der Begriff "`Block"' durchaus ein wenig unspezifisch sein kann, illustriert Abbildung~\ref{fig:screen-ui-editor-block} die Darstellung der Blöcke im Prototypen.

\begin{figure}[t]
  \includegraphics[width=\textwidth]{images/screenshots/20161019/editor-page-blocks}
  \caption{Blockdarstellung im Editor}
  \label{fig:screen-ui-editor-block}
\end{figure}

Der wesentliche Vorteil der Blockdarstellung ist Konsistenz, das gilt gleichermaßen für die Implementierung wie für die Bedienung. Anders als beim WYSIWYG-Editor müssen für neue Bedienelemente nämlich keine spezifischen Visualisierungen programmiert werden: Alles ist ein Block. Zwar unterscheiden sich einige der Attribute, die Anzahl der hierfür nötigen Sonderfälle ist aber überschaubar, zumal praktisch jede Art von Attribut bei mehr als einem Bedienelement zum Einsatz kommen kann.

Die Nähe zum Quelltext macht für Lernende den Übergang zu "`normalem"' \texttt{HTML} sehr einfach. Ein Blick in den Quelltext einer gerenderten Seiten, zum Beispiel mit den typischen Debuggingtools im Browser, sollte anhand von vielen bekannten Fragmenten genug Anhaltspunkte liefern, um zum Beispiel die Auswirkungen von konkreten Fallunterscheidungen oder Schleifendurchläufen nachvollziehen zu können.

Umgekehrt ist diese Nähe zum Quelltext natürlich auch der wesentliche Nachteil. Ohne eine mehr oder minder formale Einführung in \texttt{HTML}, kann man die Blöcke nur sehr mühevoll nutzen. Und anders als beim WYSIWYG-Editor kann man die Funktionsweise unbekannter Blöcke auch nur sehr eingeschränkt durch einfaches Einsetzen in das Dokument abschätzen.

Für Oberflächeneditoren jenseits von \idename{} ist das Verpacken der Quelltextfragmente in Blöcke kein sehr geläufiges Konzept. Die meisten Entwicklungsumgebungen verfolgen, wie im vorigen Kapitel angedeutet, einen hybriden Ansatz und erlauben sowohl die Bearbeitung im Quelltext als auch über einen WYSIWYG-Editor. Eine Sicht "`zwischen"' diesen beiden Extremen existiert in keinem Produkt, welches dem Autor dieser Thesis bekannt wäre. Einige Umgebungen sind in der Lage, die Struktur des aktuell bearbeiteten Dokumentes als Baumdarstellung zu visualisieren, diese dient dann aber nur der schnelleren Navigation in komplexen Oberflächenbeschreibung.

Bei genauerer Betrachtung ist das aber auch nicht sehr verwunderlich: Die wesentliche Zielgruppe dieser professionellen Entwicklungsumgebungen sind erfahrene Programmierer, die selbst am besten entscheiden können, welche Visualisierung gerade sinnvoll ist. Eine Darstellung, die sich rein optisch nur sehr wenig vom Text unterscheidet, bietet da keinen besonderen Mehrwert.

Lernende sind hingegen in einer ganz anderen Situation: Sie sind mit der Gestaltung von Oberflächen wenig vertraut und wissen im Regelfall noch nicht, welche Möglichkeiten ihnen offenstehen. Optische Hervorhebungen von möglichen Optionen im Quelltext helfen dann dabei, über die nächsten Schritte zu entscheiden. Ein wesentliches Merkmal der blockigen Visualisierung ist, dass sie fehlende Parameter direkt an Ort und Stelle darstellen kann. Wenn man ein unbekanntes Bedienelement "`einfach mal so"' in die Seite zieht, bekommt man also zumindestens einen Hinweis auf die konkret benötigten Parameter.

\subsubsection{Mögliche Ansätze}

Für \idename{} stellt sich bei der Gestaltung des Editors für Oberflächen also eine zentrale Frage: Welches Abstraktionsniveau passt zu der avisierten Zielgruppe? Und wie soll zwischen den Zielen "`Motivation durch praktisch vorzeigbare Ergebnisse"' und der Tatsache, dass \idename{} sich als Lehranwendung für \texttt{HTML} versteht, umgegangen werden?

Das Abstraktionsniveau kann dabei im Wesentlichen auf zwei voneinander weitestgehend unabhängigen Achsen variiert werden (Abbildung~\ref{fig:two-axis-ui-description}): Die horizontale Achse erstreckt sich von "`Texteditor"' zu "`WYSIWYG-Editor"' und beschreibt die Komplexität der Vorschau. Je näher der Editor an der textuellen Darstellung ist, desto mehr müssen die Schüler gedanklich ergänzen. Der Mittelpunkt auf dieser Achse ist ein "`blockiger"' Drag \& Drop-Editor bei dem mehr oder minder abstrakte Blöcke miteinander kombiniert werden. Nur in dafür besonders geeigneten Fällen erfolgen Eingaben über die Tastatur, zum Beispiel wenn es um die Eingabe von Texten für Absätze oder Überschriften geht.

Die vertikale Achse ist die Komplexität der zur Verfügung gestellten Bedienelemente, sie geht von "`Reines \texttt{HTML}"' bis hin zu "`Komplexe Bedienelemente"' und wurde schon in Kapitel \fullref{sec:complex-ui-elements} diskutiert. Der Mittelpunkt dieser Achse ist eine Mischung aus \texttt{HTML}-Elementen und Liquid-Kontrollstrukturen. Unterhalb der Mitte entfällt die Nutzung des \texttt{include}-Tags für Bedienelemente, die nur mit den freigeschalteten \texttt{HTML}-Elementen nicht abgebildet werden könnten. Der Entwickler darf also keine Elemente mehr verwenden, deren Implementierung er nicht nachvollziehen könnte.

Für dieses Kapitel werden einige denkbare Ansätze auf dem beschriebenen Koordinatensystem ungefähr verordnet und deren individuelle Vor- und Nachteile diskutiert. Drag \& Drop als vornehmliches Bedienparadigma ist dabei für alle Varianten gesetzt, sofern die Beschreibung dies nicht explizit abspricht.

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[scale=3]
    \coordinate (center)    at ( 0  , 0  ); 
    \coordinate (horzLeft)  at (-1.1, 0  );
    \coordinate (horzRight) at ( 1.1, 0  );
    \coordinate (vertUp)    at ( 0  , 1.1);
    \coordinate (vertDown)  at ( 0  ,-1.1);
    
    %\draw[step=0.5,black,thin] (-1,-1) grid (1,1);
    \draw [thick,<->]          (horzLeft) -- (horzRight);
    \draw [thick,<->]          (vertUp)   -- (vertDown);

    \node [left=of  horzLeft]  {Text};
    \node [right=of horzRight] {\enquote{WYSIWYG}};
    \node [above=of vertUp]    {Komplexe Bedienelemente};
    \node [below=of vertDown]  {Reines \texttt{HTML} mit Liquid};

    \node [draw, fill=white, circle] at (   1, 1  ) {1};
    \node [draw, fill=white, circle] at (   1, 0.5) {2};
    \node [draw, fill=white, circle] at ( 0.5, 0.5) {3};
    \node [draw, fill=white, circle] at (   0, 0.5) {4};

    \draw [rounded corners=0.5cm, fill=white] (-1,1.1) rectangle (-0.7,-1.1);

    \draw [rounded corners=0.5cm, fill=white] (-1,1.1) rectangle (-0.7,-1.1);
    \node at (-0.85,0) {5};
  \end{tikzpicture}
  \caption{Die horizontale Achse beschreibt die Komplexität der Visualisierung, die vertikale Achse die Komplexität der Bedienelememente}
  \label{fig:two-axis-ui-description}
\end{figure}

\begin{description}
\item[\circled{1} WYSIWYG-Editor für vordefinierte Seiten mit festen Einsatzzwecken] \hfill \\
  Gedacht für Entwickler, die mit \idename{} einfach nur eine generische Oberfläche für einen Datenbestand erzeugen möchten. Das Layout und die verfügbaren Bedienelemente sind dabei vordefiniert, es können lediglich an vorgesehenen Stellen Abfragen eingebunden, konstante Texte hinterlegt oder ähnliche Parametrisierungen vorgenommen werden. Prinzipiell wäre es auch denkbar, diese Angaben in einer sehr nüchternen, tabellarischen Darstellung vorzunehmen, sinnvoller erscheint im Hinblick auf den Einsatzzweck jedoch eine umfangreiche Vorschau.

  Die wesentliche Herausforderung bei diesem Ansatz ist die Bereitstellung von Vorlagen, welche weder zu viele noch zu wenige Konfigurationsmöglichkeiten bieten. Ist die Vorlage zu flexibel besteht die Gefahr, dass sie für den Entwickler undurchschaubar wird. Auf der anderen Seite sind zu eingeschränkte Vorlagen aber Gift für kreative Experimente: Wenn die Antwort auf fast jede Idee der Lernenden "`das geht damit nicht"' wäre, kommt schnell Frust auf.

\item[\circled{2} WYSIWYG-Editor mit komplexer Vorschau] \hfill \\
  Dieses Vorgehen ähnelt dem Vorgehen von Programmen wie Frontpage oder Dream\-weaver. Dem Entwickler wird kein Quelltext präsentiert, sondern eine annotierte Fassung der Vorschau mit all den im vorigen Kapitel beschriebenen Problemen bezüglich der Visualisierung von Wiederholungen, Alternativen und unsichtbaren Elementen.

  Kontrollstrukturen würden bei diesem Ansatz allerdings nicht durch typische Begriffe wie \texttt{for} oder \texttt{if} dargestellt, sondern durch dem konkreten Bedienelement angepasste Blöcke. Im Falle der Tabelle könnte man zum Beispiel die Spaltenüberschriften auswählbar und sortierbar gestalten. Diese Auswahl und die Reihenfolge aus der Editoransicht werden dann für die Benutzeransicht übernommen.
\item[\circled{3} WYSIWYG-Layout mit Block-Editor für ausgewählte Elemente] \hfill \\
  Dieser Ansatz kommt dem Entwickler noch ein Stück weiter entgegen, wenn es um die Gestaltung des grundlegenden Layouts, also die Aufteilung in Zeilen und Spalten geht. Innerhalb der Zellen kommt dann allerdings ein an Quelltext angelehnter Block-Editor zum Einsatz. Die komplexen Bedienelemente stehen zwar weiterhin zur Verfügung, werden aber nicht mehr durch einen speziellen "`Untereditor"' repräsentiert. Stattdessen werden die Parameter per Drag \& Drop-Editor mit den verfügbaren Daten verbunden.
  
\item[\circled{4} Block-Editor für beliebige \texttt{HTML}- und Liquid-Blöcke] \hfill \\
  In diesem Schritt werden die Liquid-Kontrollstrukturen für Schleifen und Verzweigungen freigeschaltet. Als Entwickler könnte man jetzt eigene beliebig komplexe Strukturen bauen, auch unter Zuhilfenahme von \texttt{HTML}-Elementen wie \texttt{<div>} oder \texttt{<span>}.
  
\item[\circled{5} Texteditor für Quelltext] \hfill \\
  Da die einfachste Implementierung dieser Variante schon fast durch ein einfaches \texttt{HTML}-\texttt{<textarea>}-Element bereitgestellt werden kann, ist die technische Umsetzung vergleichsweise trivial. Die unterstützte Bandbreite an Bedienelementen ist grundsätzlich beliebig, Drag \& Drop kommt nicht vor. Anders als bei Block- oder WYSIWYG-Editoren müssen daher keine speziellen Komponenten für einzelne Bedienelemente programmiert werden. Die textuelle Darstellung von \texttt{HTML} und Liquid fungiert als die denkbar allgemeinste Schnittstelle.  
\end{description}

Eine detaillierte Betrachtung dieser unterschiedlichen Ansätze, also zum Beispiel die Diskussion der Erscheinungsbilder von individuellen Komponenten im Editor, wäre im Rahmen dieser Arbeit leider zu umfangreich. Außerdem ist fraglich, ob sich die Qualität von Bedienkonzepten in einer theoretischen Diskussion gut beurteilen lassen würde. Im Sinne der prototypischen Entwicklung wird im weiteren Verlauf also vor allem Wert auf die Implementierung der beiden weiter verfolgten Visualisierungskonzepte gelegt: WYSIWYG und eine Blockdarstellung.

\subsubsection{Grundsätzlicher Aufbau}
\label{sec:design-ui-editor}

Nach dieser Betrachtung unterschiedlichster Ansätze stellt sich die Frage, inwiefern diese miteinander vereinbar sind. Dieses Kapitel stellt daher zunächst Gemeinsamkeiten heraus, für die eine Ansatz-übergreifende Lösung möglich ist. Sofern bei dem konkreten Ansatz Drag \& Drop zum Einsatz kommt (mit Ausnahme des Texteditors sind das alle) muss ein fester Bereich zur Präsentation der ziehbaren Elemente vorgesehen werden. Ebenfalls übergreifend sinnvoll ist eine generische Möglichkeit zur Bearbeitung von Eigenschaften eines Bedienelements.

Diese beiden Funktionen werden üblicherweise in eigenen Unterfenstern bereitgestellt. In dieser Form hat man dann ein sehr typisches Interface, das von so ziemlich jedem Oberflächeneditor genutzt wird. Egal ob Visual Studio, JavaFX Scenebuilder, Delphi oder QtCreator, die grundlegenden Bedienansätze unterscheiden sich an dieser Stelle nur marginal (Abbildung~\ref{fig:sidebar-example}).

\begin{figure}[h]
  \begin{subfigure}[b]{0.45\textwidth}
      \includegraphics[width=\textwidth]{images/sidebars-visual-studio.png}
      \caption{Visual Studio 2015}
      \label{fig:sidebar-example-visual-studio}
  \end{subfigure}\hfill
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{images/sidebars-qt-creator.png}
    \caption{Qt Creator 4.1}
  \end{subfigure}
  \caption{Auswahl von Bedienelementen und Eigenschaftseditor in unterschiedlichen Entwicklungsumgebungen}
  \label{fig:sidebar-example}
\end{figure}

Für \idename{} sollte allerdings noch ein weiterer Bereich zum Einsatz kommen: Eine Auflistung aller verfügbaren Datenquellen. Diese Funktion wird von Entwicklungsumgebungen, im Vergleich zu dem Editor für Eigenschaften und der Aufzählung verfügbarer Bedienelemente, nur sehr uneinheitlich angeboten. Häufig liegt das an sehr großen oder nur unstrukturiert vorliegenden Datenbeständem, die manchmal sogar erst zur Laufzeit erzeugt werden. Insbesondere bei Skriptsprachen liegt der Entwicklungsumgebung in der Regel kein formales Datenmodell vor. An dieser Stelle behelfen sich die Editoren, indem sie für jede zu bearbeitende Oberfläche explizit ein formales Datenmodell einfordern. Der \texttt{WPF}-Editor des Visual Studio erlaubt zum Beispiel die Angabe einer "`ViewModel"'-Klasse, die dann zur Designzeit vom Editor instanziiert wird. Dementsprechend muss diese Klasse auch losgelöst von ihren typischen Datenquellen (Datenbank, Webservice,~...) agieren können.

Bei \idename{} ist der gesamte Datenbestand hingegen in Namensräumen vorstrukturiert und typischerweise in Bezug auf die Datenmenge auch übersichtlich (siehe \fullref{sec:page-data-sources}). Dementsprechend sollten beim Editieren der Seite die zur Verfügung stehenden Datenquellen einfach ausgewählt werden können, ohne dass dafür aus Sicht des Entwicklers besondere Vorkehrungen getroffen werden müssten.

\idename{} wird den Seiteneditor also in zwei wesentliche Bereiche unterteilen: Einen großen Hauptbereich zum Editieren und eine schmale Seitenleiste mit verfügbaren Daten, Bedienelementen und den Eigenschaften eines ausgewählten Bedienelements. Die Inhalte der Seitenleiste sollen dabei wann immer möglich zwischen dem WYSIWYG- und dem Block-Editor geteilt werden können. Die unterschiedlichen Bestandteile der Seitenleiste können bei einer größeren Anzahl von Elementen die Übersichtlichkeit negativ beeinträchtigen. Andere Entwicklungsumgebungen lösen das durch die Nutzung von Tab- oder Akkordeon-Containern, so dass sich aktuell störende Elemente ausblenden lassen. An dieser Stelle wird ein praktischer Test mit Anwendern am Besten zeigen können, welcher Ansatz für \idename{} zu bevorzugen ist.

\subsubsection{Seitenleiste: Editieren von Eigenschaften}

Um Eigenschaften von Bedienelementen auch ohne spezielle Komponenten editieren zu können, wird in der Seitenleiste ein Editor für Eigenschaften bereitgestellt. Diese Vorgehensweise ermöglicht eine universelle Bearbeitungsmöglichkeit unabhängig von der Repräsentation im eigentlichen Editorbereich. Sowohl ein WYSIWYG- als auch ein "`Block"'-Editor können also, bewusst oder als "`Fallback"', auf identische generische Bearbeitungsmethoden für Bedienelemente zurückgreifen. Abbildung~\ref{fig:sidebar-property-editor} zeigt Beispiele für die im Prototypen implementierten Editoren.

Sofern möglich werden dabei identische Eigenschaften bei unterschiedlichen Bedienelementen auch identisch angeordnet. Eingabeelemente für Formulare (\fullref{fig:sidebar-property-editor-input} \& \fullref{fig:sidebar-property-editor-select}) fragen immer zuerst nach dem \texttt{name}-Attribut ("`Eingabename"') und dem dargestellten Titel des editierten Elements.

\begin{figure}[p]
  \begin{subfigure}[b]{0.4\textwidth}
    \includegraphics[width=\textwidth-2pt, frame]{images/screenshots/20161019/editor-page-sidebar-input}
    \caption{Eingabe}
    \label{fig:sidebar-property-editor-input}
  \end{subfigure}\hfill
  \begin{subfigure}[b]{0.4\textwidth}
    \includegraphics[width=\textwidth-2pt, frame]{images/screenshots/20161019/editor-page-sidebar-select}
    \caption{Auswahl}
    \label{fig:sidebar-property-editor-select}
  \end{subfigure}

  \begin{subfigure}[b]{0.4\textwidth}
    \includegraphics[width=\textwidth-2pt, frame]{images/screenshots/20161019/editor-page-sidebar-link}
    \caption{Link}
    \label{fig:sidebar-property-editor-link}
  \end{subfigure}\hfill
  \begin{subfigure}[b]{0.4\textwidth}
    \includegraphics[width=\textwidth-2pt, frame]{images/screenshots/20161019/editor-page-sidebar-table}
    \caption{Tabelle}
    \label{fig:sidebar-property-editor-table}
  \end{subfigure}
  
  \caption{Beispiele für Eigenschaftseditoren in der Seitenleiste}
  \label{fig:sidebar-property-editor}
\end{figure}

\subsubsection{Seitenleiste: Angebot von Bedienelementen}

Technisch gesehen ist dieses Element keine besondere Herausforderung: Es handelt sich um eine einfache Auflistung von verfügbaren Bedienelementen. Um den Wiedererkennungswert von bestimmten Bedienelementen zu steigern, werden diese mit einem kleinen Symbol ausgestattet (Abbildung~\ref{fig:sidebar-editor-widgets}).

Die wesentliche Herausforderung für diese Komponente liegt in der absehbar immer größer werdenden Anzahl von Bedienelementen. Der Prototyp nimmt schon den Versuch einer Kategorisierung vor (blau für Layoutelemente, grün für \texttt{HTML}-Elemente, orange für Elemente mit einer komplexen Darstellung), diese konkreten Einordnungen sind aber noch nicht endgültig.

\subsubsection{Seitenleiste: Angebot von verfügbaren Daten}
\label{sec:ui-editor-sidebar-data}

Die Anzeige der verfügbaren Daten ist grundsätzlich auch eine Aufzählung der Inhalte aller gefüllten Namensräume. Und ähnlich wie beim vorigen Punkt ist auch an dieser Stelle die wesentliche Herausforderung erneut die potenziell sehr große Anzahl von Bedienelementen.

Zur besseren Visualisierung sind an dieser Stelle verschiedene Symbole für die korrekte Verbindung notwendiger Parameter vorgesehen. Der in das Rechteck eintretende Pfeil (zum Beispiel bei \texttt{GET}-Parametern und Abfragen) symbolisiert Werte, die bereits vor dem Rendervorgang zur Verfügung stehen und daher in das Template eingesetzt werden können. Werte, die aus einem Rechteck austreten, stehen erst auf der Folgeseite zur Verfügung, zum Beispiel Formulardaten.

Problematisch bei dieser Visualisierung ist ein technisches Detail: Ein Formular kann in Abhängigkeit der verwendeten \texttt{<button>}-Elemente auf mehr als ein Ziel verweisen. Daher hat das \texttt{<form>}-Element intern bisher keine weitere Bedeutung außer "`Elternelemente für Eingabeelemente"' und damit auch keinen Namen oder eine ähnlich identifizierende Eigenschaft, die in der Seitenleiste angezeigt werden könnte. Daher kommt es in der Darstellung zu einer Doppelung des Begriffs "`Formular"'.

Die Kettenglieder stehen für korrekt gebundene Parameter einer Abfrage. Sofern ein erforderlicher Parameter nicht an einen Wert gebunden wurde, verfärbt sich der Name des entsprechenden Parameters rot und das Symbol zeigt ein gerissenes Glied.

\begin{figure}[h]
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{images/screenshots/20161019/editor-page-widgets}
    \caption{Verfügbare Bedienelemente}
    \label{fig:sidebar-editor-widgets}
  \end{subfigure}\hfill
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{images/screenshots/20161019/editor-page-data}
    \caption{Verfügbare Daten}
    \label{fig:sidebar-editor-data}    
  \end{subfigure}
  \caption{Weitere Elemente der Seitenleiste}
  \label{fig:sidebar-widgets}
\end{figure}

\subsubsection{Binden von Parametern}
\label{sec:ui-editor-params}

Die Bindung von Parametern erfolgt ebenfalls über Drag \& Drop. Als Entwickler kann man ein zur Verfügung stehendes Datum von der Seitenleiste oder aus dem Editorbereich direkt auf auf den zu bindenden Parameter ziehen.

Problematisch ist dabei vor allem die in Kapitel \fullref{sec:ui-editor-sidebar-data} erwähnte Unterscheidung zwischen Daten die während des Rendervorgangs nicht oder eben doch zur Verfügung stehen. Um den Wert eines Formularfeldes an einen Liquid-Ausdruck oder eine serverseitig ausgeführte Abfrage zu binden, wäre der Einsatz von Javascript nötig. Dabei handelt es sich nicht um eine willkürliche Einschränkung von \idename{}, \texttt{HTTP} und \texttt{HTML} funktioneren schlicht auf diese Art und Weise.

Den Lernenden muss daher verdeutlicht werden, zu welchem Zeitpunkt die Daten zur Verfügung stehen beziehungsweise wann diese benötigt werden. Es wäre zum Beispiel denkbar, für jedes eingesetzte Formularelement automatisch einen gleichnamigen \texttt{GET}-Parameter, gegebenenfalls mit einem Standardwert, vorzusehen. In diesem Fall stünden Formulardaten automatisch zur Verfügung, allerdings erst nach einem Klick auf den "`Absenden"'-Knopf.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% End:
