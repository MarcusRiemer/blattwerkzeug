\section{Implementierung}
\label{sec:implementation-analysis}

Dieses Kapitel beschreibt den Implementierungsprozess von \idename{} und erläutert einige technische Entscheidungen. Sofern sich während der Entwicklung Ideen für bisher nicht bedachte Funktionalität ergaben, wurden diese in Anlehnung an den "`Minus 100 Points"'-Artikel von Eric Gunnerson \cite{gunnerson-minus-100} geprüft.

\todo[inline]{Mehrere Datenbanken je Projekt, "`Veränderungsanzeige"' für Abfragen, Breite von Spalten}

\subsection{Client-Server-Architektur}
\label{sec:implementation-client-server}


Der softwaretechnische Unterbau der Entwicklungsumgebung setzt auf aktuelle Webtechnologien auf (siehe \fullref{sec:req-web-application} für die Diskussion der Begründung) und teilt sich in zwei distinkte Codebasen für Server und Client.

\begin{description}
\item[Server: Ruby mit Sinatra] \hfill\\
  Die Aufgaben des Servers sollen sich konzeptionell möglichst auf die Auslieferung und Speicherung von Daten beschränken. Die Interaktion findet dabei primär über eine REST-artige JSON Schnittstelle statt, serverseitig gerendert werden lediglich die Projekte der Schüler.
\item[Client: Typescript mit Angular 2] \hfill\\
  Aufgrund des hohen Grades an Interaktivität bietet sich eine rein clientseitige Visualisierung an, die weitestgehend auf Roundtrips zum Server verzichtet. Außer für den Zugriff auf serverseitige Resourcen (Datenbank, gespeicherte Ressourcen, gerenderte Seiten) werden alle Operationen im Browser ausgeführt.
\end{description}

\begin{figure}[p]
  \centering \includegraphics[width=\textwidth]{images/openapi-query-example.png}
  \caption{Generiert aus der Spezfikation: API-Browser für \idename{}}
  \label{fig:openapi-query-example}
\end{figure}

Um die Schnittstelle zwischen diesen beiden Komponenten so transparent wie möglich zu halten, werden diese gemäß der OpenAPI Spezifikation \cite{open-api} dokumentiert. Dieses offene Format ermöglicht es auf eine hilfreiche Auswahl an standarisierten Tools aufzubauen. Zum Beispiel können aus der Spezifikation interaktive Testumgebungen für die Server-Schnittstellen erzeugt werden, Abbildung \ref{fig:openapi-query-example} zeigt ein Beispiel dafür\todo{Screenshot zeigt alten Namen}.

Als primäres Interface für die Kompilierung wird ein \lstinline{Makefile} genutzt. Dieses prüft ob auf dem aktuellen System alle nötigen Abhängigkeiten verfügbar sind und stellt sicher, dass Übersetzungsschritte nur ausgeführt werden, wenn sie tatsächlich notwendig sind. Von den technischen Details der unterschiedlichen Programmierumgebungen aufgrund der unterschiedlichen Programmiersprachen kann so außerdem elegant abstrahiert werden: Ein Programmierer kann sich die exakten Aufrufe der unterschiedlichen Paketmanager zwar anschauen, wird im Normallfall aber nur \texttt{make install-deps} aufrufen.

\subsection{Meilensteine}

Der Editor für Datenbankabfragen versprach im Vergleich zum Seiteneditor das einfachere Teilprojekt zu sein: Die Struktur einer Abfrage ist sehr strikt festgelegt, der Umfang lässt sich gut lokal eingrenzen. Im ersten Schritt wird allerdings nicht der komplette Editor implementiert, sondern zunächst nur das interne Datenmodell für die Abfragen in Form eines abstrakten Syntaxbaumes mitsamt den dazugehörigen Tests.

Um den Umfang des Prototypen zu Begrenzen, wurde die Implementierungsphase anhand der folgenden funktionalen Meilensteine geplant:

\begin{description}
\item[Bearbeitung von Projektdaten] \hfill \\
  Schwerpunkt dieses Meileinsteins ist die Implementierung grundlegender gemeinsamer Schnittstellen. Diese müssen auf vom Server als \texttt{HTTP}-Endpunkte angeboten und vom Client angesprochen werden können.
  \begin{itemize}[noitemsep]
  \item Persistierung von Projekten mit Name und Beschreibung
  \item Editor für Projekteigenschaften
  \item Auflistung aller Projekte einer \idename{}-Instanz
  \end{itemize}
\item [Anzeige eines Datenbankschemas] \hfill \\
  Neben der funktionalen Anforderung umfasst dieser Meilenstein die Erweiterung des Clients um die typischen Bestandteile des Benutzerschnittstelle einer Entwicklungsumgebung. Serverseitig erfordert dieser Meilenstein zum ersten Mal eine Verbindung mit der Datenbank.
  \begin{itemize}[noitemsep]
  \item Editor zur Anzeige eines Datenbankschemas
  \item Seitenliste mit Übersicht über alle Bestandteile eines Projekts
  \item Toolbar mit Knöpfen, deren Verfügbarkeit vom aktuellen Editor abhängt
  \item Wechsel zwischen verschiedenen Editoren
  \end{itemize}
\item [Datenmodell \& Code-Generator für Abfragen] \hfill \\
  Der abstrake Syntaxbaum für Datenbankabfragen in \idename{} sowie dessen Validierung gegen ein Datenbankschema. Dieses Datenmodell soll soweit wie möglich von der Visualisierung entkoppelt werden, damit es sich möglichst einfach testen lässt.
  \begin{itemize}[noitemsep]
  \item Einfache Projektion durch Auswahl von Spalten im \texttt{SELECT}
  \item Kreuzprodukte unterschiedlicher Tabellen im \texttt{FROM}
  \item Einschränkungen der Ergebnismenge mit Ausdrücken im \texttt{WHERE}
  \item Ausdrücke mit binären Operationen zwischen Spalten, Konstanten und benutzerdefinierten Werten
  \item Validierung des Datenmodells mit im Fehlerfall aussagekräftigen Hilfen
  \end{itemize}
\item [Editor für Abfragen] \hfill \\
  Implementierung des Drag \& Drop Editors für SQL-Abfragen. Wesentliche Herausforderung in diesem Schritt wird die Implementierung eines möglichst allgemeingültigen Ansatzes zur Behandlung der Drag \& Drop Vorgänge.
  \begin{itemize}[noitemsep]
  \item Drag \& Drop Editor für Abfragen
  \item Ausführung von SQL-Abfragen auf dem Server
  \item Clientseitige Anzeige von serverseitigen Ergebnissen
  \end{itemize}
\item [Datenmodell \& Code-Generator für darstellende Webseiten] \hfill \\
  Das Datenmodell für Webseiten zur Anzeige der Ergebnisse von \texttt{SELECT}-Abfragen sowie die dazu passenden Testfälle. Auch hier gilt, dass dieses Datenmodell soweit wie möglich von der Darstellungsebene (Angular 2) losgelöst sein soll.
  \begin{itemize}[noitemsep]
  \item Layout mit Zeilen und Spalten
  \item Einfache, textbasierte Elemente wie Absätze und Überschriften
  \item Ausgabe von Abfrageergebnissen in einer Tabelle
  \item Navigation zu projekt-internen und externen Seiten
  \item Übergabe von \texttt{GET}-Parametern an Seiten
  \end{itemize}

\item [Rendern von darstellenden Webseiten] \hfill \\
  Um auszuschließen, dass sich dem Modell aus dem vorigen Meilstein noch grobe Schnitzer befinden sollen diese nun den Endanwendern zugänglich gemacht werden.
  \begin{itemize}[noitemsep]
  \item Manuelle Erstellung einiger einfach Testprojekte mit Testdaten
  \item Serverseitiges Rendern der verfügbaren Testprojekte
  \end{itemize}
  
\item [Editor für darstellende Webseiten] \hfill \\
  Dieser Schritt profitiert hoffentlich von den Erfahrungen mit dem Drag \& Drop Editor für SQL. Anders als für den recht offensichtlich "`richtigen"' Ansatz des SQL-Editors hat sich im Rahmen der Analyse für diesen Meilenstein noch keine endgültig favorisierte Darstellung gefunden. Daher ist in diesem Schritt mit mehreren Iterationen bis zur "`richtigen"' Implementierung zu rechnen.
  \begin{itemize}[noitemsep]
  \item Zuordnung von \texttt{SELECT}-Abfragen zu einer Seite
  \item Drag \& Drop Editor für Seitenelemente
  \item Integrierte Rendervorschau
  \end{itemize}
  
\item[Erweiterung der Seiten um Benutzereingaben]
  Bisher können mit Webseiten nur Informationen präsentiert, aber nicht verändert werden.
  \begin{itemize}[noitemsep]
  \item Einführung des \texttt{<form>}-Elementes in das Datenmodell.
  \item Eingabe von Texten mit dem \texttt{<input>}-Element.
  \item \textit{1 aus n}-Auswahl mit dem \texttt{<select>}-Element.
  \end{itemize}
  
\item [Qualitätssicherung] \hfill \\
  Zu diesem Zeitpunkt sollte ein voll funktionsfähiger Prototyp existieren, der jedoch noch einer rigorosen Qualitätskontrolle unterzogen muss. Bisher wude der Prototyp ausschließlich durch Entwickler bedient, es stellt sich insbesondere die Frage wie \idename{} auf Bedienfehler oder Inkonsistenzen reagiert.
  \begin{itemize}[noitemsep]
  \item Was passiert mit bestehenden Inhalten, wenn sich das Schema deutlich verändert?
  \item Wie sollten Seiten für Endanwender gerendert werden, wenn diese fehlerhaft sind?
  \end{itemize}
\end{description}

\subsection{Datenbanksystem}
\label{sec:implementation-database-system}

Die Wahl des konkreten Datenbanksystems hat einen unmittelbaren Einfluss auf nahezu alle Bereiche von \idename. Im einzelnen handelt es sich dabei um die exakte Variante der SQL Syntax, auf die Rahmenbedingungen für den Betrieb der Entwicklungsumgebung und auch auf die Fortführung der Projekte mit externen Programmen.

Die in der Praxis häufig dominierenden Entscheidungskriterien der Skalierbarkeit, die Unterstützung unterschiedlichster Zugriffsrechte und auch die allgemeine Performance spielen nur eine sehr untergeordnete Rolle. Die zu erwartenden Datenbeständen sollten normalerweise im Bereich nur einiger Megabyte liegen und die in der Praxis möglicherweise einzige Unterscheidung von Zugriffsrechten wäre zwischen lesendem und schreibenden Zugriff. Für die Wahl des Datenbanksystems werden stattdessen die folgenden Kriterien gewählt und hinsichtlich ihrer Relevanz sortiert:

\begin{description}  
\item[Kostenlose Verfügbarkeit] \hfill \\
  Der Betrieb des Datenbanksystems soll nicht mit Lizenzkosten für Schulen, Lehrkräft, Lernende oder auch freiwillige Entwickler verbunden sein.
\item[Einfacher Betrieb] \hfill \\
  Zwar ist für den Einsatz von \idename{} aufgrund des Browsers als Client schon die Nutzung eines Servers nötig, das Datenbanksystem sollte den Betrieb dennoch nicht mehr als unbedingt notwendig weiter verkomplizieren. Eine wesentliche Rolle spielt dabei die Platformunabhängigkeit: Das Datenbanksystem sollte, wie auch der \idename{} Server, auf jedem gängigen Betriebssystem lauffähig sein.
\item[Einfache Backups] \hfill \\
  Die gewünschte Exportfunktion für Projekte macht es nötig, den gesamten Datenbestand vergleichsweise einfach exportieren und importieren zu können. Darüber hinaus sollte es auch für Lehrkräfte möglichst einfach sein mit allen Projekten zu einem anderen \idename-Server umzuziehen.
\item[Tools zur Modellierung] \hfill \\
  Da diese Arbeit sich nicht mit der Datenmodellierung befasst, muss das entsprechende Datenbankschema extern erzeugt werden. Von einer guten Unterstützung für Modellierungsvorhaben profitiert dementsprechend indirekt auch \idename.
\item[Tools zur Entwicklung von SQL-Abfragen] \hfill \\
  Sobald ein Entwickler an die Grenzen des SQL-Editor von \idename{} stößt, soll es so einfach wie möglich sein die Abfragen in einem externen Editor zu schreiben und danach in Textform wieder an \idename{} zu übergeben.
\end{description}

Das Kriterium der "`kostenlosen Verfügbarkeit"' ist dankenswerterweise sehr einfach zu erfüllen: Es existiert eine Vielzahl von praktisch eingesetzten quelloffenen Datenbanksystemen. Die Kriterien "`einfacher Betrieb"' und "`einfache Backups"' teilen die denkbaren Systeme recht eindeutig in zwei Lager: Eingebette Datenbanken lassen sich sehr einfach betreiben und sichern. Das starten eines weiteren SQL-Server-Prozesses ist bei dieser Betriebsart nicht nötig, der Im- oder Export des gesamten Datenbestandes erfordert nur das kopieren einer einzigen Datei.

Um den Betrieb folglich so einfach wie möglich zu halten, wurden für \idename{} zunächst eingebettete Datenbanksysteme betrachtet. Aus der Masse an verfügbaren Systemen sticht das SQLite-System jedoch sehr weit hinaus: Der Quelltext ist gemeinfrei, die Anbindung an so ziemlich jede Programmiersprache ist bequem möglich und es existiert eine Fülle von verschiedensten Modellierungsprogrammen für alle Betriebssysteme. Auf eine genauere Analyse der zur Verfügung stehenden Alternativen wurde daher verzichtet.

\subsection{Tests}

Die Funktionalität der, relativ isolierten und daher gut zu testenden, internen Datenmodelle samt den darauf definierten Operationen wird über Unit-Tests sichergestellt. Diese Tests können einfach in jedem Browser ausgeführt werden und eignen sich daher auch um im Zweifelsfall unterschiedliche Verhaltensweisen verschiedener Browser zu erfassen.

Als technisches Fundament wird für diese Testfälle auf der Jasmine-Bibliothek aufgebaut. Zu prüfende Zusicherungen werden durch Verkettung zweier Funktionen ausgedrückt: \texttt{expect().toEqual()}. Neben \texttt{toEqual()} sind natürlich auch andere Vergleiche wie \texttt{isUndefined()} möglich. Wenn innerhalb eines Testfalls auch nur eine einzige dieser Prüfungen nicht zu \texttt{true} auswertet, wird der Testfall als ingesamt fehlgeschlagen markiert. Im Falle von mehreren gescheiterten Prüfungen sind werden dabei alle unerwarteten Ergebnisse aufgelistet.

Listing \ref{lst:unit-test-example} illustriert, wie die meisten Unit-Testfälle in \idename{} aufgebaut sind. Jeder Testfall beginnt mit der Definition eines Datenmodells (Zeile 6 bis 23) und endet mit Zusicherungen um die korrekte Serialisierung sicherzustellen (Zeile 43). Ganz konkret existiert also in jedem Testfall eine Variable \texttt{model}, welche im Konstruktor der zu testenden Klasse zum Einsatz kommt und in nicht-mutierenden Testfällen als Ergebnis der \texttt{toModel()}-Methode reproduziert werden muss. Für Abfragen muss noch die Generierung der korrekten \texttt{SQL}-Anweisungen geprüft werden, im Beispiel geschieht dies in Zeile 20.

\lstinputlisting[
  language=javascript,
  caption=Unit-Test für eine korrekte \texttt{SELECT}-Abfrage,
  label=lst:unit-test-example,
  float,floatplacement=h,
  numbers=left
]{snippets/unit-test-example.ts}

Die serverseitige Funktionalität wird aktuell ausschließlich über "`end-to-end"'-Tests mit einem speziell instrumentierten Browser geprüft. Für diese Tests ist ein speziell vorbereitetes Testprojekt in einem exakt definierten Zustand Teil des Repositories. Auch diese Testfälle nutzen die von Jasmine bereitgestellten Zusicherungen mit den \texttt{expect()}- und \texttt{toEqual()}-Verkettungen. Listing~\ref{lst:e2e-test-example} zeigt wie mit einem solchen Test die Funktionaliät des Editors für Projekteinstellungen sichergestellt wird. Mittels der \texttt{browser.get()}-Funktion kann zu einer bestimmten Seite navigiert werden. Um mit den einzelnen Bedienelementen dieser Seite interagieren zu können, müssen diese Anhand ihrer \texttt{ID} oder anderen eindeutigen Merkmalen zugreifbar sein (Zeile 6, 8 und 14 des Listing~\ref{lst:e2e-test-example}). Dann können für solche Elemente Tastatureingaben simuliert oder der Inhalt verglichen werden. Bestimmendes Merkmal dieser Tests zum Speichern ist, dass sie die initial geladene Seite nach dem Speichervorgang erneut aufrufen. Nur wenn die zuvor gesetzten Werte auch nach diesem Ladevorgang noch vorhanden sind, kann von der korrekten Funktionsweise des Servers ausgegangen werden.

\lstinputlisting[
  language=javascript,
  caption=End-to-end Test für den Speichervorgang eines Projektes,
  label=lst:e2e-test-example,
  float,floatplacement=h,
  numbers=left
  ]{snippets/e2e-test-example.ts}

Die Dateien mit den Tests liegen im Dateisystem immer "`neben"' ihren Implementierungen, der Dateiname wird allerdings um das Suffix \texttt{spec} wie "`specification"' oder \texttt{e2e} wie "`end-to-end"' ergänzt. Das Beispiel in Listing  \ref{lst:unit-test-example} wurde der Datei \texttt{select.spec.ts} entnommen, der Code für die zu testende Funktionalität findet sich folglich in \texttt{select.ts}.

\subsection{Datenmodell}

Die grundsätzliche Struktur eines \idename-Projektes wird in Diagramm \ref{uml:class-diagram-core-entities} ersichtlich. Diese Darstellung visualisert nicht die konkrete Implementierung des Servers oder des Clients, sondern illustriert die grundlegenden beteiligten Datenstrukturen. Jede dieser Entitäten, also sowohl Projekte als auch ihre Ressourcen, enthält eine eigene Versionsangabe. Dadurch kann auf jede Veränderung an dieser Struktur explizit eingegangen werden (\fullref{sec:implementation-migration}). Aktuell laden sowohl Server als auch Client nur Ressourcen, deren Version exakt passt.

Jede Ressource (\texttt{ProjectResource}) verfügt über eine interne ID sowie einen sprechenden Namen. In der aktuellen Version von \idename{} handelt es sich bei dieser ID um eine \lstinline{GUID}, sollte also weltweit einzigartig sein. Theoretisch wäre es dadurch denkbar, diese Ressourcen auch zwischen Projekten zu kopieren oder zu teilen. Intern werden Referenzen auf Ressourcen immer anhand der ID vorgenommen. Eine Umbenennung von Ressourcen durch den Benutzer hat daher keine Auswirkungen auf etwaige Referenzen an anderer Stelle.

Die Methode \texttt{ProjectResource.toModel()} wird genutzt um aus dem spezifischen Res\-sour\-cen-Objekt eine rein beschreibende Datenstruktur zu erzeugen. Diese Beschreibung ist selbstverständlich abhängig vom Typ der jeweiligen Ressource und kommt auch in dessem Konstruktor zum Einsatz. Tiefe Kopien von Ressourcen können daher über diese Se\-ria\-lisierungs- und Deserialisierungsschritte vorgenommen werden.

\begin{diagram}[p]
  \begin{tikzpicture}
    \begin{interface}[text width=7cm]{ApiVersionable}{-4, 0}
      \attribute{apiVersion : string}
    \end{interface}
    
    \begin{class}[text width=7cm]{Project}{-8, -4}
      \implement{ApiVersionable}
      
      \attribute{id : string}
      \attribute{name : string}
      \attribute{description : string}
      \attribute{indexPageId : string}
    \end{class}

    \begin{abstractclass}[text width=7cm]{ProjectResource}{0, -6}
      \implement{ApiVersionable}

      \operation[0]{toModel() : ProjectResource}
      
      \attribute{id : string}
      \attribute{name : string}
    \end{abstractclass}

    \begin{class}[text width=7cm]{Page}{0, -10}      
      \attribute{body: BodyNode}
      \attribute{referencedQueries: QueryReference[]}
      \attribute{parameters: PageParameter[]}
    \end{class}

    \begin{class}[text width=7cm]{Query}{0, -14}
      \attribute{select : Select}
      \attribute{delete : Delete}
      \attribute{insert : Insert}
      \attribute{update : Update}
      \attribute{from   : From}
      \attribute{where  : Where}
    \end{class}

    % query and page implement projectresource
    \draw[->] (Query.east) -- ++ (1,0) -- ($(ProjectResource.east)+(1,0)$) -- (ProjectResource.east);
    \draw[-] (Page.east) -- ++ (1,0);

    % each resource has a reference to the project
    \draw[] (ProjectResource.north)  |- (Project.east);
    \node[xshift=0.3cm, yshift=0.3cm] at (ProjectResource.north) {n};
    \node[xshift=0.3cm, yshift=0.3cm] at (Project.east) {1};
    
    % a project has pages ...
    \draw[] (Page.west)  -| (Project.south);
    \node[xshift=0.3cm, yshift=-0.5cm] at (Project.south) {1};
    \node[xshift=-0.5cm, yshift=0.3cm] at (Query.west) {0..n};
    \node[xshift=-2.5cm, yshift=0.3cm] at (Query.west) {Queries};

    % ... and queries.
    \draw[] (Query.west) -| (Project.south);
    \node[xshift=-0.5cm, yshift=0.3cm] at (Page.west) {0..n};
    \node[xshift=-2.5cm, yshift=0.3cm] at (Page.west) {Pages};
  \end{tikzpicture}

  \caption{Abstrakte Übersicht über die Ressourcen eines Projektes}
  \label{uml:class-diagram-core-entities}
\end{diagram}

\subsubsection{Serverseitige Persistenz}
\label{sec:implementation-persistence}

Grundsätzlich sollte die serverseitig persistierte Repräsentation einer Ressource identisch mit dem Übertragungsformat sein. Dieses Vorgehen spart durch die Einsparung eines Transformationsvorganges potenziell Zeit, vor allem erleichtert es aber die serverseitige Implementierung. Bei der folgenden Betrachtung von möglichen Optionen zur Speicherung der Daten, wird also grundsätzlich von \texttt{JSON}-Dokumenten ausgegangen. Bei der Auslieferung durch den Server können diese dann möglicherweise sogar unverändert weitergereicht werden. Um die Persistierung vorzunehmen, kommen im Wesentlichen zwei Speichermethoden in Frage: Entweder werden Datensätze direkt als Datei im Dateisystem abgelegt oder in einer dokumentenorientierten Datenbank gespeichert.

Bei einer Speicherung im Dateisystem wäre der rein lesende Zugriff auf \idename-Datensätze sogar mit einem einfachen Webserver für statische Dateien möglich. Um ein Projekt zu Testzwecken anzusehen oder zu editieren reicht ein normaler Texteditor, neue Projekte können einfach per Copy \& Paste im Dateisystem angelegt werden. Perspektivisch wäre es relativ einfach möglich, ein Projekt mit gängigen Versionsverwaltungsprogrammen wie git oder mercurial zu versionieren. Diese Implementierung besticht also vor allem durch ihre Einfachheit in Bezug auf die zum Zugriff notwendigen Programme.

Die Speicherung in dokumentenorientierten Datenbanken wie MongoDB oder in einem Key/Value-Store wie redis macht den Zugriff auf die persistierten Daten abhängig von einem externen Serverprozess. Der universelle Zugriff über das Dateisystem weicht einem speziellem Programm zur Navigation innerhalb der jeweiligen Datenbank. Mit dieser Komplexität erkauft man auf der anderen Seite eine wesentlich größere Flexibilät in Bezug auf horizontale Skalierung: Sollte es jemals notwendig werden den Server auf mehr als einem Rechner zu betreiben, existiert dafür dann schon eine hilfreiche Basis.

Letzten Endes fiel die Entscheidung auf das Dateisystem. Die Gründe ähneln jenen, wie sie schon bei der Wahl von \texttt{SQLite} aufgezählt wurden (\fullref{sec:implementation-database-system}): Backups des Dateisystems sind trivial, der Betrieb außerordentlich eine, externe Programme sind zahlreich vertreten. Sollte eine komplizierte Lösung notwendig werden, kann man diese immer noch implementieren, sobald sie tatsächlich notwendig wird.

Technisch gesehen ist ein Projekt folglich eine Sammlung von Dateien in einer festgelegten Ordnerstruktur. Abbildung~\ref{fig:project-disk-structure} zeigt ein beispielhaftes Projekt mit jeweils einer Datenbank, Abfrage und Webseite.

\begin{figure}[h!]
  \dirtree{%
    .1 example-project/.
    .2 databases/.
    .3 default.sqlite.
    .2 queries/.
    .3 0c396a9a-1947-4c2b-a5fb-195df2b91b84.json.
    .3 0c396a9a-1947-4c2b-a5fb-195df2b91b84.sql.
    .2 pages/.
    .3 0a436465-b074-46a4-ac12-b091a77c9d6b.json.
    .3 0a436465-b074-46a4-ac12-b091a77c9d6b.liquid.
    .2 config.yaml.
  }
  \caption{Dateistruktur eines Projekts}
  \label{fig:project-disk-structure}
\end{figure}

Dabei werden Seiten und Abfragen in zwei Versionen gespeichert: Einmal das \texttt{JSON}-serialisierte Datenmodell und eine jeweils "`kompilierte"' Version in Form von \texttt{SQL}- oder Liquid-Code.

\subsubsection{Projekt}
\label{sec:data-model-project}

Die vornehmlichen Eigenschaften eines Projektes sind die darin enthaltenen Abfragen und Webseiten, darüber hinaus werden in den Projekteinstellungen aber noch einige andere Einstellungen festgehalten:

\begin{description}[noitemsep]
\item[Name, Beschreibung \& Bild] \hfill \\
  Von Entwicklern frei wählbare Elemente, mit denen das Projekt einem Endanwender kurz \& knapp beschrieben wird. Der Prototyp erlaubt zum aktuellen Zeitpunkt noch nicht den Upload von Bildern, Endanwendern werden die Bilder aber dennoch angezeigt.
\item[Aktivierte Datenbank] \hfill \\
  Ein Entwickler kann in einem Projekt zwischen mehreren "`Evolutionsstufen"' oder Sicherheitskopien einer Datenbank auswählen. Für einen Endanwender ist diese Unterscheidung allerdings nicht von Relevanz: Er erwartet nicht beim erstmaligen Besuch einer Seite zunächst eine Datenbank auswählen zu müssen. Daher legt der Entwickler in dieser Einstellung fest, welche Datenbank zum Rendern verwendet werden soll.
\item[Startseite] \hfill \\
  Sobald in einem Projekt mehr als eine Webseite verfügbar ist, muss eine dieser Seiten als Startseite festgelegt werden.
\item[Benutzerdatenbank] \hfill \\
  Die in Kapitel \fullref{sec:concept-access-control} beschriebenen Zugriffskontrollen bedürfen einer rudimentären Benutzerdatenbank. Aktuell wird diese als Teil des Projekts gespeichert, die Passwörter werden dabei selbstverständlich verschlüsselt.
\item[Routendefinitionen (abgeleitet)] \hfill \\
  Der aktuelle Stand der Implementierung erstellt für jede existierende Seite implizit eine Route, die einfach dem Namen der Seite entspricht. Eine Seite mit dem Namen "`impressum"' ist folglich unter der \texttt{URL} \texttt{'http://projektname/impressum'} erreichbar. 
\end{description}

\subsubsection{Abfrage}
\label{sec:data-model-query}

\subsubsection{Seite}


\subsection{Client}

\subsubsection{Warum nicht Blockly?}

\subsection{Server}

\subsubsection{Nutzung von Subdomains}

\idename{}-Seiten werden unter eigenen Subdomains gerendert. Das erhöht die Anforderungen an die technische Infrastruktur, geht jedoch mit einer Reihe von Vorteilen einher.

Zunächst einmal gilt im Internet auch heute noch die Annahme, dass auf jeder Domain nur ein logischer Internetauftritt hinterlegt ist. Das sich hinter einer \texttt{URL} wie \texttt{blatt\-werk\-zeug.de\-/project\-/pokemongo} eine völlig andere Seite als hinter \texttt{blatt\-werk\-zeug.de\-/project\-/cyoa} verbirgt ist zwar in keinster Weise verboten, aber zumindest ungewöhnlich.

Praktisch Subdomains von vielen Suchmaschinen, sonstigen Angeboten im Internet und auch innerhalb der technischen Standards anders behandelt, als wenn die gleichen Inhalte als untergeordnete \texttt{URL} einer anderen Seite existierten. Das beginnt schon bei entscheidenden technischen Details: So können zum Beispiel Zertifikate für \texttt{SSL}-Verbindungen nur für Domains, nicht aber Teile einer \texttt{URL} ausgestellt werden. Und Webseiten werden im Falle von unerwünschten Inhalten, zum Beispiel Phishing-Angriffen, üblicherweise für Subdomains gesperrt.

Darüber hinaus kann jede Webseite davon ausgehen, dass die gesamte Routing-Hierarchie nur ihr gehört, was die Nutzung von absoluten Pfadangaben erlaubt. Insbesondere um Bilder, \texttt{CSS}-Dateien oder JavaScript-Bibliotheken zu verlinken ist das eine hilfreiche Garantie, welches viele praktische Probleme vermeidet.

\subsection{Unerwartete Hindernisse}

\subsubsection{Instabile API von Angular 2}

\subsubsection{Fehlerhafte Codegenerierung des Typescript-Compilers}

Der verwendete Typescript-Compiler hat zum Zeitpunkt der Anfertigung dieser Arbeit einen bekannten Bug in der Codegenerierung \cite{ts-compiler-class-order-bug} um den wiederholt herumgearbeitet werden musste. Konkret äussert sich dieser Fehler, wenn die Definition der Oberklasse einer sich davon ableitenden Klasse erst im Nachhinein erfolgt (Listing \ref{lst:ts:class-order-bug}). In diesem Fall kommt es zu keiner Warnung durch den Compiler, sondern zu einem Laufzeitfehler im kompilierten Javascript-Code.

\lstinputlisting[language=JavaScript,caption=Falsche Reihenfolge der Klassendefinition, label=lst:ts:class-order-bug]{snippets/class-inheritance-order-bug.ts}

\subsection{Administration}
\label{sec:implementation-administration}

Momentan aufgrund von Zeitmangel nur in Form der Kommandozeilenschnittstelle.

\subsubsection{Schema-Migrationen}
\label{sec:implementation-migration}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "thesis"
%%% End:
