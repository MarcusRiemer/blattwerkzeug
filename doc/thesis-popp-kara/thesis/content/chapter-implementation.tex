%************************************************
% Implementierung
%************************************************
\chapter{Implementierung}
\label{sec:implementation}

In diesem Kapitel wird die Implemetierung des im Rahmen dieser Arbeit entwickelten Programm dargestellt, sowie die technischen Entscheidungen, die zu ihr geführt haben erläutert. Außerdem beschreibt dieses Kapitel die Integration des entstandenen Tools in BlattWerkzeug.

%************************************************
% Rahmenhandlung
%************************************************
\section{Rahmenhandlung}
\label{sec:implementation:story}

Für die Festlegung einer Rahmenhandlung bieten sich im wesentlichen zwei Vorgehensweisen an:

\begin{enumerate}[noitemsep]
  \item Es wird zunächst eine Logik entwickelt und teilweise bereits implementiert. Die Rahmenhandlung wird erst später festgelegt und richtet sich nach den gewünschten und ggf. implementierten Funktionen. Mit dieser Vorgehensweise lässt sich die Logik noch klarer von der Darstellung trennen. Die Darstellung wird austauschbar und es ist sogar denkbar verschiedene Rahmenhandlungen auf der selben Logik zu implementieren.
  \item Eine andere Vorgehensweise ist es die Rahmenhandlung direkt am Anfang festzulegen. Die Anforderungen der Rahmenhandlung diktieren in diesem Fall die Logik. Naturgemäß fließen Anforderungen an die Logik bei der Festlegung der Rahmenhandlung auch hier mit ein. Allerdings sind Darstellung und Logik bei dieser Vorgehensweise viel enger aneinander geknüpft. Ein späteres Austauschen der Darstellung wird deutlich erschwert. Die engere Verbindung bedeutet allerdings auch eine bessere Abstimmung der beiden Komponenten.
\end{enumerate}

Für diese Arbeit wurde die zweite Vorgehensweise gewählt und im ersten Schritt eine Rahmenhandlung unter Berücksichtigung der Anforderungen an die Logik gewählt. Ziel des Spiels ist es mit Hilfe eines Lastwagen, welcher vom Spieler über Programmbefehle steuerbar ist (siehe \ref{sec:requirements:program}), über ein Netz von Straßen, verschiedenfarbige Container an ihre vorgesehenen Ablageorte zu bringen. Dabei ist die Ladefläche des Lastwagen auf einen Container begrenzt, womit unter Umständen zur Lösung mehrfache Fahrten -- auch Teilfahreten -- notwendig werden können. Dargestellt wird die Mikrowelt in einer Überkopf-Ansicht, wie sie aus Turtle Grafiken, Karel und Kara bekannt ist.

Diese Rahmenhandlung wurde gewählt, da der Transport von Waren in dieser vereinfachten Darstellung jedem bekant sein sollte und sich die Nutzer gut in die Rolle des Fahrers hineinversetzten kann. In Zeiten in denen autonomes Fahren ein vieldiskutiertes Thema ist, gewinnt diese Rahmenhandlung zusätzlich an Relevanz. Außerdem bietet die Rahmenhandlung verschiedene Erweiterungsmöglichkeiten und ermöglicht eine schrittweise Erhöhung der Komplexität. So ist z.B. die Einführung von Verkehrsampeln zur Vermittlung des Konzeptes der Verzweigungen und zeitlicher Zusammenhänge möglich.

%************************************************
% Objektstruktur
%************************************************
\section{Objektstruktur}
\label{sec:implementation:structure}

Es wurde zunächst eine objektorientierte Datenstruktur erarbeitet, die eine Welt repräsentiert und Methoden bereitstellt, welche Operationen auf der Welt durchführen können. Abbildung \ref{fig:implementation:structure:uml} zeigt ein UML-Diagram dieser Struktur. Zur besseren Übersicht wurde diese Darstellung auf die wesentlichen, zum Verständnis notwendigen Klassen, Attribute und Operationen beschränkt.

\begin{figure}
  \input{snippets/implementation-structure-uml}
  \caption{Vereinfachtes UML-Diagramm der Weltobjektstruktur}
  \label{fig:implementation:structure:uml}
\end{figure}

Wurzelelement dieser Struktur ist die \inlinec{World}-Klasse. Sie wird mit einer Beschreibung der zu generierenden Welt instanziiert. Anhand dieser Beschreibung erzeugt der Konstruktor die Größe (\inlinec{Size}) der Welt, einen Lastwagen (\inlinec{Truck}) und eine Menge von Kacheln (\inlinec{Tile}). Lastwagen und Kacheln werden in einem Weltzustand (\inlinec{WorldState}) verpackt. Die Daten eines einmal gespeicherten Zustandes werden nicht mehr geändert. Stattdessen wird eine Kopie des aktuellen Zustandes erzeugt, verändert und in der Liste aller Zustände abgespeichert. Diese Vorgehen ermöglicht dem Nutzer Operationen rückgängig zu machen. Außerdem wird dadurch die für die Animationen \tref{sec:implementation:rendering:animation} notwenige Interpolation zwischen Zuständen vereinfacht. Die Veränderung der Zustände übernimmt die \inlinec{World}-Klasse in der Operation \inlinec{command}. Da alle Operationen auf der Welt Parameterlos sind, wird der \inlinec{command}-Methode lediglich der Name der auszuführenden Operation übergeben. Eine Liste der verfügbaren Befehle findet sich in Tabelle \ref{tbl:implementation:program:elements:cmds} auf Seite \pageref{tbl:implementation:program:elements:cmds}.

%************************************************
% Minisprache
%************************************************
\section{Minisprache}
\label{sec:implementation:program}

Mit den nachfolgend beschriebenen Elementen, wurde zunächst eine Grammatik entwickelt. Die Syntax orientiert sich dabei grob an der JavaScript-Syntax mit der Besonderheit, dass auch Leerzeichen in Funktionsnamen erlaubt sind.

\subsection{Elemente der Sprache}
\label{sec:implementation:program:elements}

Im Folgenden sind die Elemente beschrieben, welche dem Nuzter zum Programmieren innerhalb der bereitgestellten Umgebung zur Verfügung stehen.

\subsubsection{Atomare Befehle}
\label{sec:implementation:program:elements:cmds}

Wichtigster Bestandteil sind die atomaren Befehle. Durch die Aneinanderreihung mehrerer Befehle lässt sich bereits ein sinnvolles Programm implementieren. Als notwendige Befehle wurden identifiziert und implementiert:

\begin{table}[H]
  \begin{tabular}{|p{0.175\textwidth}|p{0.175\textwidth}|p{0.56\textwidth}|}
    \hline
    \textbf{Befehl} & \textbf{Interne\newline Repräsentation} & \textbf{Beschreibung} \\ \hline
    Vorwärts fahren & \inlinec{goForward} & Bewegt den Lastwagen nach vorne. Falls dabei ein Blinker in eine Richtung gesetzt ist, biegt der Lastwagen in die entsprechende Richtung ab. \\ \hline
    Blinker\newline links setzten & \inlinec{turnLeft} & Setzt den Blinker auf der linken Seite. Dadurch biegt der Lastwagen bei der nächsten Vorwärtsbewegung links ab. \\ \hline
    Blinker\newline rechts setzten & \inlinec{turnRight} & Setzt den Blinker auf der rechten Seite. Bei der nächsten Vorwärtsbewegung biegt der biegt der Lastwagen dadurch entsprechend rechts ab. \\ \hline
    Blinker\newline ausschalten & \inlinec{noTurn} & Schalten einen zuvor gesetzten Blinker wieder aus. Dies ist nicht notwendig, nach der Fahrt um eine Kurve, da sich der Blinker hier selbst ausschaltet, allerdings kann so ein "versehentliches" Setzen des Blinkers rückgängig gemacht werden. \\ \hline
    Aufladen & \inlinec{load} & Läd ein Frachstück, welches vor dem Lastwagen auf der Straße liegt auf. \\ \hline
    Abladen & \inlinec{unload} & Läd ein Frachtstück auf eine Ablagefläche oder einem leeren Steckenabschnitt vor dem Lastwagen wieder ab. \\ \hline
    Warten & \inlinec{wait} & Wartet einen Zeitschritt ab. Dieser Befehl ist wichtig um das Warten auf eine Ampel zu ermöglichen. \\ \hline
  \end{tabular}
  \vspace{5pt}
  \caption{Atomare Befehle}
  \label{tbl:implementation:program:elements:cmds}
\end{table}

Bewegungen finden dadurch immer relativ zur aktuellen Blickrichtung des Lastwagen statt. Dieser Ansatz wurde einem absoluten Ansatz mit Befehlen wie "Fahre nach Norden", "Fahre nach Osten", usw. vorgezogen, da er der intuitiven Steuerungsart eines Lastwagen am nächsten kommt. Außerdem können daraus Vorteile für die Darstellung gewonnen werden, wie Abschnitt \ref{sec:implementation:rendering:truck-position} zeigt.

Der "Vorwärts fahren"-Befehl wurde zunächst mit einer gewissen Intelligenz ausgestattet. Dadurch konnten Kurven gefahren werden ohne dass ein Blinker gesetzt werden musste. Im Laufe der Arbeit wurde diese Logik als eine geeignete Aufgabenstellung identifiziert und daher deaktiviert. Nutzer sollten sich eine Funktion definieren, die eben diesen intelligenten "Vorwärts fahren"-Befehl umsetzt.

\subsubsection{Zählerschleife}
\label{sec:implementation:program:elements:for}

Um Codeverdoppelung zu vermeiden, kann eine Schleife eingesetzt werden, die einen Befehlsblock wiederholt. Die Anzahl der Wiederholungen kann vom Nutzer festgelegt werden.

\subsubsection{Sensoren}
\label{sec:implementation:program:elements:sensors}

Um Verzweigungen nutzen zu können, gibt es die Möglichkeit Werte von Sensoren abzufragen. Sensoren stehen immer entweder auf wahr oder falsch. Folgende Sensoren stehen zur Verfügung:

\begin{table}[H]
  \begin{tabular}{|p{0.175\textwidth}|p{0.19\textwidth}|p{0.56\textwidth}|}
    \hline
    \textbf{Sensor} & \textbf{Interne\newline Repräsentation} & \textbf{Beschreibung} \\ \hline
    Ampel ist rot & \inlinec{lightIsRed} & Dieser Sensor ist wahr, wenn die Ampel vor dem Lastwagen rot ist. Ist, die Ampel grün, oder es gibt keine Ampel vor dem Lastwagen, so steht dieser Sensor auf falsch. \\ \hline
    Ampel ist grün & \inlinec{lightIsGreen} & Analog dazu ist dieser Sensor wahr, wenn die Ampel vor dem Lastwagen grün ist und falsch, wenn sie auf rot steht oder es keine Ampel vor dem Lastwagen gibt. \\ \hline
    Kann geradeaus fahren & \inlinec{canGoStraight} & Dieser Sensor wertet zu wahr aus, wenn das Straßennetz es zulässt, dass der Lastwagen im nächsten Schritt geradeaus fahren kann. \\ \hline
    Kann links abbiegen & \inlinec{canTurnLeft} & Dieser Sensor wertet zu wahr aus, wenn im nächsten Schritt links abgebogen werden kann. \\ \hline
    Kann rechts abbiegen & \inlinec{canTurnRight} & Wenn im nächsten Schritt nach rechts abgebogen werden kann, wertet dieser Sensor zu wahr aus. \\ \hline
    Ist gelöst & \inlinec{isSolved} & Wenn die aktuelle Welt gelöst wurde, also alle Frachtstücke zu ihren Zielen transporiert wurden, wertet dieser Sensor zu wahr aus. \\ \hline
  \end{tabular}
  \vspace{5pt}
  \caption{Sensoren}
  \label{tbl:implementation:program:elements:sensors}
\end{table}

\subsubsection{Abweisende Schleife}
\label{sec:implementation:program:elements:while}

Mit den Sensoren ist es möglich eine abweisende Schleife zu nutzen. Diese wiederholt den Befehlsblock solange der angegebene Ausdruck zu wahr auswertet. Wird die Schleifenbedingung vor der ersten Ausführung des Schleifenblocks oder nach ein oder mehrerer Ausführungen zu falsch ausgewertet, wird der nachfolgende Block ausgeführt. Der Schleifenblock kann also auch komplett übersprungen werden.

\subsubsection{Verzweigungen}
\label{sec:implementation:program:elements:if-else}

Sensoren ermöglichen außerdem Verzweigungen, die einen Befehlsblock nur dann ausführen, wenn der angegebene Sensor zu wahr ausgewertet wird und einen weiteren, optionalen Befehlsblock, wenn der Sensor zu falsch ausgewertet wird.

Das aus anderen Sprachen bekannte \inlinec{elseif} gibt es, wie auch in JavaScript, in der hier definierten Sprache nicht. Um dieses Verhalten zu erreichen, müssen mehrere \inlinec{if...else}-Anweisungen geschachtelt werden. In Zukunft wäre es denkbar, in dieser Form geschachtelte Verzweigungen auch im generierten Code ohne zusätzliche geschweifte Klammern und Einrückung darzustellen. Bisher wurde auf diese Darstellung verzichtet, da auch der Drag \& Drop-Editor hierzu noch nicht in der Lage ist.

\subsubsection{Logische Operatoren}
\label{sec:implementation:program:elements:op}

Mit Hilfe von logische Operatoren können neue Ausdrücke erzeugt werden, welche sich wiederum in Schleifen und Verzweigungen einsetzen lassen.

\begin{itemize}[noitemsep]
  \item Die \emph{Nicht}-Operation kehrt den Wahrheitswert um.
  \item Die \emph{Und}-Verknüpfung ist wahr, wenn beide Verküpften Werte wahr sind.
  \item Die \emph{Oder}-Verküpfung ist wahr, wenn mindestens einer der beiden Verküpften Werte wahr ist.
\end{itemize}

Mit diesen logischen Operatoren ist es nun z.B. möglich zu prüfen, ob das vorrausliegende Steckenstück eine Kurve ist: (Kann nicht geradeaus fahren und ((Kann links abbiegen und Kann nicht rechts abbiegen) oder (Kann nicht links abbiegen und Kann rechts abbiegen)))

\subsubsection{Prozeduren}
\label{sec:implementation:program:elements:proc}

Desweiteren ist es möglich eigene Prozeduren zu definieren und aufzurufen. Für Prozeduren lassen sich zusätzlich Parameter definieren, deren Nutzung innerhalb des Prozedurenblocks möglich ist. Jeder Parameter erhält einen vom Nuzter festgelegten Namen, kann jedoch ausschließlich boolsche Werte übergeben. Beim Aufruf der Prozedur werden die übergebenen Werte -- wie bei auch Prozeduraufrufen in JavaScript üblich -- kopiert.

Alle Funktionen werden im Drag \& Drop-Editor in einem Deklarationsteil am Anfang des Programms definiert, da sich der Nutzer sonst zusätzliche Gedanken über den richtigen Ort der Deklaration machen müsste. Da Funktionen deklariert werden müssen, bevor sie aufgerufen werden können, ist mit dieser Vorgehensweise sichergestellt, dass alle Funktionen überall im Programm aufrufbar sind. Funktionen sind auch in der Lage sich selbst aufzurufen. Dies ermöglicht zusätzlich die Nutzung von Rekursion. In Verbindung mit Verzweigungen ist auch Rekursion mit Abbruchbedingung möglich.

\subsection{Auswertung}
\label{sec:implementation:program:evaluation}

Für die Auswertung und Ausführung des durch den Syntaxbaum beschriebenen Codes kommen zwei Vorgehensweisen infrage. Im Grundlagenkapitel \ref{sec:basics:compile-interpret} wurde der Unterschied zwischen Kompilieren und Interpretieren im klassischen Sinne bereits erklärt. Da im Browser jedoch nicht direkt Maschienencode ausgeführt werden kann, ist der Unterschied in diesem Zusammenhang etwas anders zu verstehen:

\begin{itemize}
  \item Beim \emph{Interpretieren} wird der Syntaxbaum nach und nach durch ein in JavaScript geschriebenes Programm abgearbeitet und die entsprechenden Befehle direkt ausgeführt. In dieser Umgebung lässt sich der Fortschritt des Programms leicht verfolgen, da der Interpreter zu jedem Zeitpunkt die Position kennt, bis zu der der Code bisher ausgeführt wurde. Dies ermöglicht den Einbau von aussagekräftigen Debuggingfunktionen für den den auszuführenden Code. Außerdem ist es leicht möglich Mechanismen bereitzustellen, welche die Ausführung an einer beliebigen Stelle stoppen oder pausieren und später fortsetzen.
  \item Im Unterschied dazu ist \emph{Kompilieren} in diesem Zusammenhang so zu verstehen, dass ein JavaScript-Programm den Syntaxbaum zunächst in ein vollständig ausführbares JavaScript-Programm überführt. Der JavaScript-Code liegt bei diesem Vorgehen nach dem Kompilieren als String vor und kann anschließend als Ganzes in einer Art Sandkasten ausgeführt werden. Innerhalb dieser "Blackbox" lässt sich nur recht unzuverlässig auf den aktuellen Zustand des laufenden Programmes schließen ohne zusätzlichen Code einzufügen, der die Lesbarkeit des generierten Codes verschlechtert. Eben diese Lesbarkeit des generierten Codes ist aber einer der wichtigsten Vortile dieser Vorgehensweise. Der Code lässt sich nicht nur für seine Ausführung nutzen, sondern kann gerade im Kontext einer Lernsoftware für den Nutzer interessant sein und ihm angezeigt werden.
\end{itemize}

Im Verlauf der Arbeit wurde die Vorgehensweise "Kompilieren" an dieser Stelle als Anforderung festgelegt, da dieses Vorgehen speziell für BlattWerkzeug den Vorteil mit sich bringt, dass generierter Code in Zukunft vor der Ausführung dem Nutzer angezeigt und von ihm bearbeitet werden kann, was den Übergang zu einer Universalsprache erleichtern würde (siehe auch \ref{sec:conclusion:future}).

\subsubsection{Codegenerator}

Für die Kompilierung des Syntaxbaum wird auf den von BlattWerkzeug zur Verfügung gestellten Codegenerator-Strukturen zurückgegriffen, die es ermöglichen einen Codegenrator zu implementieren, der Übersetzungsregeln für jeden Knotentypen definiert. Abbildung \ref{fig:implementation:program:evaluation:while} zeigt die Implementierung eines Codegenrators für Knoten, die eine While-Schleife repräsentieren. Zwischen den Klammern innerhalb der \inlinec{while}-Anweisung wird der Kindknoten für die Bedingung der Schleife eingefügt, gefolgt vom Inhalt der Schleife. Diese Kindknoten werden wiederrum durch ähnlich aufgebaute Generatoren umgewandelt bis der vollständige Code des Wurzelknoten im Syntaxbaum übersetzt wurde.

\begin{figure}
  \lstinputlisting{snippets/implementation-program-evaluation-while.ts}
  \caption{Beispielhafte Implementierung eines Codegenrator für eine While-Schleife}
  \label{fig:implementation:program:evaluation:while}
\end{figure}

\subsubsection{Syntaxfehler}

Es kann nicht garantiert werden, dass der Code, welcher vom Codegenrator erzeugt wurde, frei von Syntaxfehlern ist. Dies kann aus der Kompilierung eines unvollständigen Syntaxbaumes resultieren. So kann es z.B. vorkommen, dass die Bedingung bei einer While-Schleife leer ist. JavaScript wirft bei der Erzeugung der Funktion einen \inlinec{SyntaxError}. Um diesen Fehler abzufangen, muss die Erzeugung der Funktion innerhalb einer try...catch-Anweisung\footnote{\url{https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Statements/try...catch}} stattfinden \fref{fig:implementation:program:evaluation:try-catch}.

\begin{figure}
  \lstinputlisting{snippets/implementation-program-evaluation-try-catch.js}
  \caption{Möglicher Syntaxfehler innerhalb des generierten Code}
  \label{fig:implementation:program:evaluation:try-catch}
\end{figure}

\subsubsection{Umgebung zur Ausführung}

Dem kompilierten Code muss zur Ausführung eine Umgebung bereitgestellt werden, welche die eingangs als "atomaren Befehle" bezeichneten Funktionen, sowie Funktionen zur Ermittlung der Sensorwerte zur Verfügung stellt. Für diese Aufgabe bietet sich der \inlinec{Function}-Konstruktor\footnote{\url{https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Function}} an. Im Gegensatz zu \inlinec{eval} ermöglicht der \inlinec{Function}-Konstruktor die Ausführung von Code im globalen Gültigkeitsbereich, was zu besseren Programmiergewohnheiten führt und eine effizientere Code-Minimierung ermöglicht~\cite{mdn-function}. In diesem speziellen Fall wird für die Ausfühung des Codes der \inlinec{AsyncFunction}-Konstruktor verwendet (siehe dazu Abschnitt \ref{sec:implementation:rendering:animation}).

Für die Bereitstellung der Befehle und Sensoren werden im folgenden drei Varianten betrachtet. In Abbildung \ref{fig:implementation:program:environment} werden Implementationsbeispiele dieser Varianten gegenüber gestellt.

\begin{enumerate}
  \item Eine Enum-Klasse mit allen Sensoren und Befehlen, sowie zwei Funktionen für deren Auswertung gibt es schon. Darauf aufbauend wäre eine naheliegend Möglichkeit, diese Funktionen und die Enum-Klassen einfach in der Welt bereitzustellen. Ein deutlicher Vorteil dieser Lösung ist der geringe zusätzliche Implementierungsaufwand und die verbesserte Wartbarkeit. Kommen neue Befehle oder Sensoren dazu, stehen diese automatisch auch in der Umgebung zur Verfügung. Der generierte Code ist jedoch nicht intuitiv und sollte er dem Nutzer angezeigt werden, nicht besonders gut zu verstehen. Außerdem halten sich die Funktionsaufrufe nicht an gängige Muster, was den späteren Umstieg auf Universalsprachen erschweren könnte \fref{fig:implementation:program:environment:func}.
  \item Eine weitere denkbare Lösung ist es ein Objekt mit allen benötigten Funktionen für Befehle und Sensoren zu erzeugen und dieses als Wert von \inlinec{this} innerhalb der Funktion zur Verfügung zu stellen. Selbstdefinierte Prozeduren werden innerhalb der Funktion ebenfalls als Kinder von \inlinec{this} definiert. Dieses Vorgehen hat den Vorteil, dass der Code deutlich intuitiver wird, als dies bei der vorgehend beschriebenen Variante der Fall wäre. Jedem Aufruf muss zwar ein \inlinec{this} vorangestellt werden, jeder Befehl hat aber seinen eigenen Funktionsaufruf. Der zusätzliche Implemetierungsaufwand ist allerdings ein Nachteil dieser Variante. Es müssen in einem Objekt, Wrapper-Funktionen für alle Befehle und Sensoren definiert werden. Kommt zu einem späteren Zeitpunkt ein Befehl oder ein Sensor hinzu, muss dieser zusätzlich auch an dieser Stelle hinzugefügt werden \fref{fig:implementation:program:environment:this}.
  \item Auch wäre es möglich alle Befehle und Sensoren als Parameter der Funktion zu definieren. Dadurch würde im Vergleich zur vorigen Variante die Notwendigkeit entfallen \inlinec{this.} vor jeden Aufruf zu stellen. Da die Wrapper-Funktionen in diesem Fall allerdings ebenfalls zusätzlich definiert werden müssen und die Zuordnung ihrer Namen fehleranfällig ist, birgt dieses Vorgehen abgesehen des etwas kompakteren Codes, keine weiteren Vorteile \fref{fig:implementation:program:environment:param}.
\end{enumerate}

Während alle drei Varianten ihre Vor- und Nachteile haben, scheint Variante zwei für die Implementierung am sinnvollsten. Es wird also ein Objekt mit Wrapper-Funktionen für alle Befehle und Sensoren erzeugt und dieses mittels \inlinec{call}\footnote{\url{https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Function/call}} an die generierte Funktion übergeben.

\begin{figure}
  \begin{subfigure}[b]{\textwidth}
    \lstinputlisting{snippets/implementation-program-environment-func.js}
    \caption{Definition und Aufruf mit Enum-Klasse}
    \label{fig:implementation:program:environment:func}
    \vspace{0.5cm}
  \end{subfigure}
  \begin{subfigure}[b]{\textwidth}
    \lstinputlisting{snippets/implementation-program-environment-this.js}
    \caption{Definition und Aufruf mit \inlinec|call|}
    \label{fig:implementation:program:environment:this}
    \vspace{0.5cm}
  \end{subfigure}
  \begin{subfigure}[b]{\textwidth}
    \lstinputlisting{snippets/implementation-program-environment-param.js}
    \caption{Definition und Aufruf über Parameter}
    \label{fig:implementation:program:environment:param}
  \end{subfigure}
  \caption{Varianten für die Bereitstellung der Befehle und Sensoren innerhalb der generierten Funktion}
  \label{fig:implementation:program:environment}
\end{figure}

\subsubsection{Behandlung von Endlosschleifen}

Beim obigen Vergleich wurde ein Vorteil der Vorgehensweise "Interpretieren" genannt, welcher gleichzeitig ein Nachteil beim Kompilieren darstellt: Wurde mit der Ausführung des kompilierten Codes einmal begonnen, kann diese nicht einfach unterbrochen werden. Dies stellt insbesondere ein Problem dar, wenn der Nuzter eine Endlosschleife in sein Programm eingebaut hat. Um dieses Problem zu umgehen, wurde zusätzlich der \inlinec{doNothing}-Befehl eingeführt. Dieser Befehl steht im Drag \& Drop-Editor nicht zur Verfügung. Er verändert -- änlich wie der \inlinec{wait}-Befehl -- den Zustand der Welt nicht, fügt im Gegensatz zu \inlinec{wait} allerdings keinen neuen Zustand ein, kann also auch nicht rückgängig gemacht werden. Trotzdem erzeugt dieser Befehl eine für den Nutzer kaum merkliche Wartezeit von wenigen Millisekunden. Mit diesem Vorgehen kann aktives Warten ("busy waiting") beim Aufruf einer leeren While-Schleife und daraus resultierendes Blockieren der Bedienelemente von BlattWerkzeug, vermieden werden.

Den \inlinec{doNothing}-Befehl nur in leeren Schleifen einzufügen, reicht nicht aus. Zwar wäre es möglich verzeiltelte Konstellation zu überprüfen und auf den zusätzlichen Befehl zu verzichten, wenn eine andere Anweisung auf gleicher Ebene aufgerufen wird, allerdings wird dieses Vorgehen sehr aufwändig, wenn auch kompliziertere Strukturen wie z.B. Verzweigungen oder untergeordnete Schleifen geprüft werden sollen. So kann in vielen Fällen nicht sichergestellt werden, dass der untergeordnete Block auch wirklich aufgerufen und der darin enthaltene Befehl ausgeführt wird.

Zusätzlich wird innerhalb von allen Befehlen geprüft, ob der Nuzter die Beendigung des laufenden Programmes angewiesen hat. Ist dies der Fall, wird die Ausführung des aktuellen Codes durch den Wurf einer Exception vorzeitig beendet. Dieses Vorgehen ist die einzig sinnvolle Möglichkeit die Ausführung des Codes vorzeitig zu beenden ohne die Lesbarkeit durch zusätzliche Kontrollbefehle zu verschlechtern, auch wenn es die Nebenwirkung hat, dass \inlinec{try...catch}-Anweisungen in Zukunft nicht innerhalb des generieten Codes eingesetzt werden können.

%************************************************
% Darstellung
%************************************************
\section{Darstellung}
\label{sec:implementation:rendering}

Erst die Darstellung in einer Mikrowelt erweckt die Minisprache zum Leben. Im Folgenden soll die Implementierung der Darstellung der bisher beschriebenen Datenstruktur beschrieben werden.

\subsection{Technologie}
\label{sec:implementation:rendering:technology}

Als mögliche Technologien für die Darstellung und Animation der Welt im Browser wurden vier Ansätze evaluiert. Eine Übersicht der Eigenschaften findet sich in Tabelle \ref{tbl:implementation:rendering:technology}.

\begin{itemize}[noitemsep]
  \item Rendering über klassische \emph{HTML}-Elemente und Styling mittels CSS und Integration von nachgeladenen Bilddateien.
  \item Rendering mittels eines eingebetteten \emph{SVG}-Element.
  \item Rendering mittels eines \emph{Canvas}-Element und Integration von nachgeladenen Bilddateien.
  \item Einsatz von \emph{WebGL} für die Darstellung einer dreidimensionalen Welt.
\end{itemize}

WebGL ist als Technologie für diese Arbeit als zu mächtig einzustufen. Die Erstellung von dreidimensionalen Modellen hätte den Rahmen dieser Arbeit gesprengt und -- abgesehen von einer möglichen schöneren Darstellung -- im Vergleich zu den übrigen Technologien keinen nennenswerten Nutzen gehabt.

Rendering mittels HTML und SVG haben den Vorteil, dass sie sehr von den Funktionen des Angular-Framework profitieren. Die Datenstruktur kann direkt an HTML und SVG-Elemente angebunden werden und Angular kümmert sich um die Aktualisierung des DOM. Dieses Vorgehen reduziert den Aufwand für die Implementierung des Renderes enorm. Zusätzlich bringt Angular nativ ein Animationsframework mit. Für die Implementierung eines Prototyp wurde das Rendering mittels eines SVG-Element gewählt, da es gegenüber einfachem HTML den Vorteil bietet, Grafiken direkt und ohne zusätliches Nachladen von Ressourcen integrieren zu können.

In der Implementierung des Prototyp erwies sich allerdings das Animationsframework als ein Nachteil dieser Technologie. Angular setzt an dieser Stelle auf ein zustandsbasiertes System. Eine Animationen finden immer zwischen zwei definierten Zuständen statt. Zustände können bestimmte CSS Regeln angeben, zwischen denen bei einem Zustandswechel interpoliert wird~\cite{angular-animations}. Dieses System ist mit den Anforderungen, die der im Rahmen dieser Arbeit behandelte Anwendungsfall stellt, nicht kompatibel. Für die Animation eines Lastwagen müsste vielmehr zwischen verschiedenen Positionen interpoliert werden. Diese lassen sich nicht sinnvoll auf Zustände in Angular abbilden.

So setzt die aktuelle Version des Programms auf einen Renderer mittels Canvas-Element. Dass Angular keine Funktionen zum Rendern in einem Canvas-Element bereithält und dieser Prozess vollständig außerhalb und unabhängig von Angular stattfinden muss, erwies sich schnell als ein Vorteil dieser Technologie. Der Renderer hat dadurch keine externen Abhängigkeiten, ermöglicht eine leichte Integration in BlattWerkzeug und könnte potenziell auch in eine Anwendung portiert werden, welche Angular nicht einsetzt. Der Nachteil, dass das Canvas in jedem Frame vollständig neu gezeichnet werden muss, wäre technisch zu umgehen indem Bereiche ermittelt werden, die sich im Vergleich zum letzten Frame geändert haben und nur diese Bereiche neu gezeichnet werden. Auf die Implementierung dieses Verhaltens wurde allerdings in diesem Fall verzichtet, da auf Grund der geringen Komplexität der zu zeichnenden Grafik zu erwarten ist, dass moderne Computer keinerlei Schwierigkeiten beim ständigen Neuzeichnen des Bildes haben werden und die angesprochene Technik mitnichten trivial umzusetzen ist.

\begin{table}
  \centering
  \begin{tabular}{l|c|c|c|c}
                                      & HTML   & SVG    & Canvas & WebGL  \\ \hline
    Direkte Integration in Angular    & \cmark & \cmark & \xmark & \xmark \\ \hline
    Frameweises Rendering             & \xmark & \xmark & \cmark & \cmark \\ \hline
    Nachladen von Ressourcen notwenig & \cmark & \xmark & \cmark & \cmark \\ \hline
    Abhängigkeitsfrei                 & \xmark & \xmark & \cmark & \cmark \\
  \end{tabular}
  \vspace{5pt}
  \caption{Vergleich der Darstellungstechnologien}
  \label{tbl:implementation:rendering:technology}
\end{table}

\subsection{Objektstruktur}
\label{sec:implementation:rendering:structure}

Die Objektstruktur des Renderers ist in \figreft{sec:implementation:rendering:structure:uml} zur besseren Übersicht vereinfacht dargestellt. Wurzelklasse ist hier der Renderer, welche mit einem \inlinec{World}-Objekt (Diese Objektstruktur wurde in Abschnitt \ref{sec:implementation:structure} beschrieben) und einem Canvas-Context instanziiert wird. Mit dem Aufruf der \inlinec{render}-Methode wird der Render-Prozess gestartet. Diese Methode zeichnet den Canvas-Inhalt und ruft sich mittels der \inlinec{requestAnimationFrame}-Funktion\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}} immer wieder selbst auf.

Die Eigentliche Zeichenaufgabe gibt die \inlinec{Renderer}-Klasse jedoch an einen Baum von \inlinec{ObjectRenderer}-Klassen ab, die für die Darstellung wesentlicher visueller Objekte zuständig sind. Die Struktur der \inlinec{ObjectRenderer} ist an der Weltobjektstruktur orientiert. Die \inlinec{Renderer}-Klasse hält eine Instanz eines \inlinec{WorldRenderer}, welcher die von ihm gehaltene \inlinec{WorldStateRenderer}-Instanz über Zustandsänderungen der Welt informiert. Der \inlinec{WorldStateRenderer} verwaltet genau eine \inlinec{TruckRenderer}-Instanz, welche für das letztendliche Zeichnen des Lastwagen und die Animation von dessen Zustandsübergängen verantwortlich ist, sowie die notwenige Anzahl von \inlinec{TileRenderer}-Instanzen. Die \inlinec{draw}-Methode der \inlinec{ObjectRenderer} werden immer mit einem \inlinec{RenderingContext} aufgerufen, welcher den Zeitstempel der Animation verwaltet, einen Verweis auf den zu verwendenden Canvas-Context enhält, sowie einige Hilfsmethoden zum Zeichnen bereitstellt.

Das sichtbare Bild wird durch die \inlinec{ObjectRenderer} vollständig aus verschiedenen Komponenten zusammengesetzt, die aus SVG-Sprites an die richtige Stelle im Bild gezeichnet werden. Die Hintergründe der Straßen stammen aus einer freien Sammlung von Spielegrafiken\footnote{\url{https://opengameart.org/node/16589}}, der Truck und die Fracht wurden für den Zweck dieser Arbeit selbst gezeichnet. Alle 16 Varianten von Kacheln sind im Sprite verfügbar. Lediglich der Truck muss vor dem Zeichnen in die richtige Richtung gedreht werden. Ein Vorbereiten aller möglichen Drehungen des Lastwagen im Sprite ist an dieser Stelle nicht sinnvoll, da die Drehung des Lastwagen animiert interpoliert werden soll.

\begin{figure}
  \input{snippets/implementation-rendering-structure-uml}
  \caption{Vereinfachtes UML-Diagramm der Rendererobjektstruktur}
  \label{sec:implementation:rendering:structure:uml}
\end{figure}

\subsection{Angular-Zone}
\label{sec:implementation:rendering:ngzone}

Wenn die \inlinec{render}-Methode aus einer Angular-Anwendung heraus aufgerufen wird, empfielt es sich diesen Aufruf außerhalt der Angular-Zone vorzunehemen. Angularanwendungen werden immer innerhalb der "Angular-Zone" ausgeführt. Wenn ein Browserereignis (z.B. ein Klick oder ein \inlinec{setTimeout}) eintritt, wird die Angular Zone betreten und der Code zur Ereignisbehandlung ausgeführt. Anschließend führen die Zone und Angular die Änderungserkennung für die Anwendung durch. In den meisten Fällen ist dieses Verhalten erwünscht. Beim Zeichnen führt dies jedoch dazu, dass \inlinec{requestAnimationFrame} ebenfalls in der Angular-Zone ausgeführt wird. Dies bedeutet, wenn eine Animation läuft, werden pro Sekunde bis zu 60 Änderungserkennungen ausgeführt~\cite{angular-canvas}. Da die \inlinec{render}-Methode lediglich der Darstellung dient, keinerlei Änderungen an der Welt oder ihren Zuständen vornimmt und somit nie Änderungen zu detektieren sein werden, kann und muss sie dementsprechend außerhalb der Angular-Zone ausgeführt werden.

\begin{figure}
  \lstinputlisting{snippets/implementation-rendering-structure-ngzone.ts}
  \caption{Aufruf außerhalb der Angular-Zone (in Anlehnung an~\cite{angular-canvas})}
  \label{sec:implementation:rendering:structure:ngzone}
\end{figure}

\subsection{Zielerfüllung}
\label{sec:implementation:program:finish}

Hat der Nutzer mit seinem Programm, oder aber manuell über die Befehls-Buttons alle Container an ihr Ziel verbracht, erkennt die Software, dass das Spielfeld gelöst ist. Bei Lightbot wird an dieser Stelle nun der Bildschirm von einer Meldung überdeckt und der Spieler wird aufgefordert zur nächsten Aufgabe zu springen. Dabei entsteht ein Eindruck, wie er aus vielen Puzzle-Spielen bekannt ist und der den Spieler animieren soll immer mehr Level zu lösen.

Bei der hier entwickelten Anwendung ist das Verhalten bewusst ein anderes: Der Nutzer erhält eine Statusmeldung, dass das Spielfeld gelöst wurde, wird aber nicht aus der aktuellen Arbeitsumgebung herausgerissen. Vielmehr soll er die Möglichkeit bekommen das eigene Programm nocheinmal zu lesen und zu verstehen \emph{warum} dieses Programm zu der Lösung geführt hat. Außerdem kann der Nutzer so sein Programm weiter optimieren und vielleicht eine Lösung implementieren, welche noch schneller zum gewünschten Ergebnis führt. Einzelne Schritte können dafür mit Hilfe eines entsprechenden Buttons rückgängig gemacht werden, oder aber die Welt wird direkt wieder auf ihren Ausgangszustand zurückgesetzt.

\subsection{Level-Editor}
\label{sec:implementation:program:level-editor}

Für den Drag \& Drop-Editor wurde eine weitere Grammatik in BlattWerkzeug eingeführt, welche es ermöglicht eine eigene Karte zu kreieren. Der hieraus generierte Syntaxbaum wird in eine Beschreibung einer Welt (\inlinec{WorldDescription}) umgewandelt, mit der die \inlinec{World}-Klasse instanziiert werden kann. Diese Beschreibung enthält sowohl die Größe der Welt, sowie die Position und initiale Beladung des Lastwagen, als auch eine Liste von Kacheln, welche wiederum ihre Position definieren und Informationen über Ampeln, Fracht und Frachtziele enthalten.

Für die Aufgabe der Definition einer umfangreichen listenartigen Datenstruktur wie der einer Welt, erwieß sich der Drag \& Drop-Editor als eher ungeeignet. Der Nutzer muss ein sehr genaues Bild der Welt vor Augen haben, um die Kacheln mit den richtigen Öffnungen zu platzieren. Um die Welten für die Beispielaufgaben besser erzeugen zu können, wurde ein rudimentärer Level-Editor entwickelt, der als JavaScript-Anwendung unabhängig von BlattWerkzeug funktioniert und den Syntaxbaum der Welt ausgiebt. Dieser muss anschließend manuell in die BlattWerkzeug-Datenbank einkopiert werden. Da dies keine Lösung für reguläre Anwender darstellt und damit Lehrer ohne tiefergende Kenntnisse der Software in Zukunft selbst in der Lage sind, eingene Aufgabenstellungen vorzubereiten, wäre die Entwicklung eines geeigneten Level-Editor innerhalb der BlattWerkzeug-Umgebung, aber unabhängig vom Drag \& Drop-Editor notwendig. Dies würde jedoch den Rahmen dieser Arbeit übersteigen.

\subsection{Lastwagen-Position}
\label{sec:implementation:rendering:truck-position}

Sowohl bei Kara \tref{sec:related:kara}, als auch bei Lightbot \tref{sec:related:lightbot} bewegt sich die Spielfigur von einer Kachel des Spielfeldes zur nächsten und kommt zwischen den Schritten auf der Mitte der Kachel zum stehen. Eine Drehung findet auf der Stelle statt. Die Spielfigur dreht sich um sich selbst und kann sich so in alle vier Richtungen bewegen. So liegt es nahe diese Verhalten auch für den Lastwagen zu implementieren \fref{fig:implementation:rendering:truck-position:diff:a}, jedoch ist zu bedenken, dass die Spielfiguren von Kara und Lightbot sich in einem realen Umfeld anders Bewegen als ein Lastwagen. Wärend eine Drehung auf der Stelle für einen Marienenkäfer und einen hüpfenden Roboter kein Problem darstellen, wäre der Fahrer eines Lastwagens mit dieser Aufgabe wohl überfordert. Ein Lastwagen dreht sich nur dann, wenn bei einer Vorwärtsbewegung die Lenkung eingeschlagen wird. Um dieses Verhalten auch in die Mikrowelt zu übertragen, wurde eine Implementierung gewählt, bei der der Lastwagen auf der Kante der Kachel zum stehen kommt. An dieser Stelle hat der Spieler die Möglichkeit einen Blinker nach rechts oder links zu setzten und damit die Richtung bei der nächsten Vorwärtsbewegung zu beeinflussen \fref{fig:implementation:rendering:truck-position:diff:b}. Im Gegensatz zur erstgenannten Methode ist mit diesem Ansatz kein Wenden möglich. Der Lastwagn muss eventuell einen Umweg fahren um sein Ziel zu erreichen und darf sich in keine Sackgassen begeben. Für die Zukunft wäre es allerdings denkbar, einen Rückwärtsgang einzuführen.

\begin{figure}
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{gfx/implementation-rendering-truck-position-diff-a.png}
    \caption{Haltepunkt auf der Mitte der Kachel}
    \label{fig:implementation:rendering:truck-position:diff:a}
  \end{subfigure}\hfill
  \begin{subfigure}[b]{0.45\textwidth}
    \includegraphics[width=\textwidth]{gfx/implementation-rendering-truck-position-diff-b.png}
    \caption{Haltepunkt auf der Kante der Kachel}
    \label{fig:implementation:rendering:truck-position:diff:b}
  \end{subfigure}\hfill
  \caption{Haltepunkte des Lastwagen im Spielfeld}
  \label{fig:implementation:rendering:truck-position:diff}
\end{figure}

\subsection{Animationsschritte}
\label{sec:implementation:rendering:animation}

Durch Animationen kann das Benutzererlebnis noch einmal deutlich aufgewertet werden, indem die den Ausführungsfluss der Anwendung verlangsamt und dadurch die Nachvollziehbarkeit der ausgeführten Befehle ermöglicht wird. Zwischen den Positionen des Lastwagen wird daher zeitlich interpoliert. Eine wichtige Grundlage dafür wurde mit der Welt-Objektstruktur bereits geschaffen \tref{sec:implementation:structure}: Jede Operation erzeugt einen neuen Zustand, der in einer Liste gespeichert wird. Dieses Vorgehen macht es leicht zwischen dem aktuellen und dem vorherigen Zustand zu interpolieren.

Zur Darstellung einiger Operation wir eine gewisse Zeit benötigt. So ist für die Operation des vorwärts Fahren, ein Zeitschritt festgelegt, beim Setzten eines Blinkers kann die verbrauchte Zeit jedoch vernachlässigt werden, daher wird diese Operation mit null Zeitschritten bewertet. Die tatsächliche Zeit, die ein Zeitschritt verbraucht, kann seperat festgelegt werden. Dadurch ist es möglich die Zeit (z.B. für die Auswertung von Testfällen) kleiner zu stellen und dadurch die Animationen schneller laufen zu lassen. Als Standardeinstellung hat sich die Dauer von einer Sekunde für einen Zeitschritt als passend erwiesen.

Auch sind die Zeitschritte für die Berechnung der Ampelphasen relevant. Für Ampeln kann die Dauer der Rot-, bzw. Grünphase in Zeitschritten festgelegt werden. Eine Ampel mit einer Rotphase von einem Zeitschritt sowie einer Grünphase von ebenfalls einem Zeitschritt wir nun nach jeder Vorwärtsbewegung oder Aufruf des Warten-Befehls, umspringen. Jedoch nicht beim Wechsel der Blinkerseite. 

Um der Animationszeit im Programmablauf gerecht zu werden stellt, die \inlinec{World}-Klasse neben der \inlinec{command}-Methode auch noch die Methode \inlinec{commandAsync} bereit, die als asynchrone Funktion definiert ist und ein \inlinec{Promise} zurück gibt, welches erfüllt wird, sobald die für diesen Befehl vorgesehene Zeit abgelaufen ist. Die MDN-Web-Dokumentation (Mozilla Developer Network) beschreibt asynchrone Funktionen wie folgt:

\begin{quote}
  "Eine asynchrone Funktion arbeitet außerhalb des Kontrollflusses, und teilt ihr Ergebnis durch ein unausgedrücktes, in die Ereignisschleife eingefügtes \inlinec{Promise} mit. Die Gestalt des Codes bei einer asynchronen Funktion ähnelt allerdings der der standardmässigen synchronen Funktionen. [...] Eine \inlinec{async} Funktion darf einen \inlinec{await} Ausdruck enthalten, der die Ausführung der Funktion anhält. Die Funktion wartet auf den zurückgegebenen ("resolved") Wert des \inlinec{Promise}, das der \inlinec{await} Ausdruck erzeugt, worauf die Funktion ihre Arbeit wieder aufnimmt."~\cite{mdn-async-function}
\end{quote}

Wärend die Nutzung von asynchronen Funktionen also technisch im Prinzip der Nuztung von Promises entspricht, vebessern sie die Lesbarkeit deutlich. Dies ist eine Eigenschaft, die besonders für den vom Compiler generierten Code \tref{sec:implementation:program:evaluation} nützlich ist und dort zum Einsatz kommt. Im generierten Code wird aus diesem Grund jedem Befehlsaufruf ein \inlinec{await} vorangestellt. Außerdem werden auch alle benuzterdefinierte Prozeduren als asynchrone Funktionen definiert.

In Abschnitt \ref{sec:implementation:program:evaluation} wurde bereits angedeutet, dass für die Ausführung des generierten Codes eine Funktion mit dem \inlinec{AsyncFunction}-Kontruktor erzeugt wurde. Im gegensatz zu \inlinec{Function} ist \inlinec{AsyncFunction} kein globales Objekt und kann auf etwas umständliche Weise durch die Ausführung des in \figreft{fig:implementation:rendering:animation:async-function} dargestellten Codes erhalten werden~\cite{mdn-async-constructor}.

\begin{figure}
  \lstinputlisting{snippets/implementation-rendering-animation-async-function.js}
  \caption{Erhalten des \inlinec|AsyncFunction|-Objekt~\cite{mdn-async-constructor}}
  \label{fig:implementation:rendering:animation:async-function}
\end{figure}

%************************************************
% Integration
%************************************************
\section{Integration}
\label{sec:implementation:integration}

Um mit möglichst wenigen Abhängigkeiten und dadurch geringerem Zeitaufwand verschiedene Ansätze ausprobieren zu können, wurde zunächst mit der Entwicklung eines Prototypen auf einer "grünen Wiese" begonnen. Auch wenn der Prototyp als Angular-Anwendung aufgesetzt wurde, erfolgte der Großteil der Entwicklung außerhalb dieser Umgebung. Nachdem der ursprüngliche Ansatz der Darstellung mittels SVG-Grafiken verworfen wurde und die Darstellung auf Canvas-Rendering umgestellt wurde, sind die Objektstruktur, sowie der Renderer vollständig unabhängig von Angular implementiert, da sie von den von Angular bereitgestellten Strukturen nicht profitieren können. Diese Klassen konnten so ohne Anpassungen in die Umgebung von BlattWerkzeug übernommen werden. Lediglich die rudimentäre Benutzeroberfläche des Prototypen (siehe Abbildung \ref{fig:implementation:integration:prototype}) wurde mit Hilfe von Angular umgesetzt, für die Integration in BlattWerkzeug in dieser Form jedoch nicht mehr benötigt.

\begin{figure}
  \centering
  \includegraphics[width=0.4\textwidth]{gfx/implementation-integration-prototype.png}
  \caption{Bildschirmfoto der UI des Prototyp vor der Integration in Blattwerkzeug}
  \label{fig:implementation:integration:prototype}
\end{figure}

\subsection{Angular-Service}
\label{sec:implementation:integration:ng-service}

Ein Projekt in BlattWerkzeug kann sowohl mehrere Welten, als auch mehrere Programme (im Folgenden Coderessource genannt) beinhalten. Diese zusammen zu bringen ist die Aufgabe des \inlinec{TruckWorldService}. Die Auslagerung dieser Funktionalität ist notwendig, da Darstellung und Steuerung der Welten über mehrere Angular-Komponenten verteilt sind. Alle diese Komponenten erhalten in Abhängigkeit der ihnen zugeordneten Coderessource die entsprechende Instanz ihrer der Welt. Auch übernimmt der Service die Aufgabe -- falls notwendig -- eine neue Instanz einer Welt zu erzeugen.

Eine besondere Schwierigkeit ist in diesem Zusammenhang die Zuordnung einer Welt zu einem Programm. BlattWerkzeug bietet aktuell nicht die Möglichkeit eine Verküpfungen zwischen verschiedenen Ressourcen herzustellen. Zu diesem Zweck wurde eine Auswahlbox implementiert, welche in die UI der Controller-Komponente (siehe \ref{sec:implementation:integration:controller}) eingegliedert wurde und in einm Auswahlfeld alle im aktuellen Projekt verfügbaren Welten darstellt. Die Auswahl wird an den \inlinec{TruckWorldService} weitergegeben, der sie zwischenspeichert. So geht die Auswahl der Welt, sowie deren aktueller Zustand auch nicht verloren, wenn der Nuzter zwischen verschiedenen Coderessourcen wechselt. Aufgrund der fehlenden Speichermöglichkeit in BlattWerkzeug, muss die Welt allerdings erneut ausgewählt werden, sobald die Seite neu geladen und der Service dadurch neu instanziiert wird. Auch wenn diese Lösung nicht optimal ist, reicht sie für eine sinnvolle Benutzbarkeit des Programms aus.

\subsection{Renderer}
\label{sec:implementation:integration:renderer}

Zum Anzeigen der Welt wurde in BlattWerkzeug eine Komponente definiert, welche die \inlinec{Renderer}-Klasse (siehe \ref{sec:implementation:rendering:structure}) aus dem Prototypen nahezu ohne Anpassungen übernehmen konnte. Die Komponente erhält vom \inlinec{TruckWorldService} die aktuelle \inlinec{World}-Instanz, mit der sie den Renderer instanziiert und außerhalb der Angular Zone (siehe Abschnitt \ref{sec:implementation:rendering:ngzone}) den Renderingprozess startet. Diese Komponente greift dabei lediglich lesend auf die Welt zu und nimmt keine Veränderungen vor.

Zusätzlich wird die Komponente im Welt-Editor verwendet, um die bisher erstellte Welt darzustellen. Aus diesem Grund wurde darauf geachtet, die Darstellung möglichst robust und fehlertolerant zu gestalten, damit auch halbfertige Welten zuverlässig dargestellt werden können.

\subsection{Controller}
\label{sec:implementation:integration:controller}

Innerhalb der Controller-Komponente ist es möglich die Befehle in der aktuellen Welt per Klick auf einen Button von Hand auszuführen. Außerdem kann an dieser Stelle die Ausführung des im Drag \& Drop-Editor zusammengestellen Programm gestartet und gestoppt werden. Es ist desweiteren möglich einzelne Befehle rückgängig zu machen oder die Welt direkt auf ihren Ausgangszustand zurückzusetzen.

Auch diese Komponente greift auf den \inlinec{TruckWorldService} zurück, um die aktuell gewählte Welt zu erhalten. Klicks auf die Buttons werden direkt an die entsprechenden Funktionen der \inlinec{World}-Klasse weitergeleitet.

Mit Hilfe des \inlinec{CurrentCodeResourceService}, einem von BlattWerkzeug bereitgestellten Service zum erhalt der aktuellen Coderessource, kann auf den aus dem Drag \& Drop-Editor kompilierten Code zugegriffen werden. Dieser Code wird beim Klick auf den entsprechenden Button an die \inlinec{World}-Klasse zur Ausführung übergeben.

Solange eine Operation auf der Welt ausgeführt wird, sind die Bedienelemente zur Ausführung weiterer Befehle gesperrt. Erst nach Beendigung der Operation und damit auch der Animation, kann ein weiterer Befehl ausgeführt werden. Dazu existiert in der \inlinec{World}-Klasse ein Flag, welches während der Ausführung gesetzt und von dieser Komponente ständig ausgewertet wird.

\subsection{Sensoren}
\label{sec:implementation:integration:sensors}

Eine letzte Komponente dient lediglich der Darstellung der aktuellen Werte aller Sensoren. Dadurch wird dem Nutzer im Navigationsmodus ermöglicht sich in die Lage des Programms hineinzuversetzen und Entscheidungen basierend auf dem Wert von Sensoren zu treffen. Auch diese Komponente erhält über den \inlinec{TruckWorldService} Zugriff auf die aktuelle Welt, auf welche sie allerdings nur lesend zugreift.
