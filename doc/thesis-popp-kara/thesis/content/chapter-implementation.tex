%************************************************
% Implementierung
%************************************************
\chapter{Implementierung}
\label{sec:implementation}

\section{Objektstruktur}
\label{sec:implementation:structure}

\TODO{} wurde zunächst eine Objektorientierte Datenstruktur erarbeitet, die eine Welt repräsentieren und Operationen auf der Welt durchführen kann. \figreft{fig:implementation:program:uml} zeigt ein UML-Diagram dieser Struktur. Zur besseren Übersicht wurde diese Darstellung auf die wehsentlichen zum Verständnis notwenigen Klassen, Attribute und Operationen beschränkt.

\begin{figure}[h]
  \begin{tikzpicture}
    \tikzstyle{every node}=[font=\small]

    \begin{class}[text width=5cm]{World}{4.75,0}
      \attribute{commands}
      \attribute{sensors}

      \operation{command(command: Command)}
      \operation{sensor(sensor: Sensor): boolean}
    \end{class}

    \begin{class}[text width=3cm]{Size}{-1.5,-1}
      \attribute{width: number}
      \attribute{height: number}
    \end{class}

    \begin{class}[text width=3cm]{WorldState}{11,-1.5}
      \attribute{step: number}
      \attribute{time: number}
      \attribute{prev: WorldState}
    \end{class}

    \begin{class}[text width=4cm]{Tile}{-1,-3.5}
      \attribute{position: Position}
      \attribute{freightTarget: Freight}

      \operation{addFreight(freight: Freight)}
      \operation{removeFreight(): Freight}
    \end{class}

    \begin{class}[text width=5cm]{Truck}{10,-5}
      \attribute{position: Position}
      \attribute{facing: number}

      \operation{loadFreight(freight: Freight)}
      \operation{unloadFreight(): Freight}
      \operation{turn(turnDirection: TurnDirection)}
      \operation{move()}
    \end{class}

    \begin{class}[text width=6cm]{TrafficLight}{4.75,-10}
      \attribute{redPhase: number}
      \attribute{greenPhase: number}
      \attribute{initial: number}

      \operation{isRed(step: number): boolean}
      \operation{isGreen(step: number): boolean}
    \end{class}

    \begin{enumeration}[text width=4cm]{TileOpening}{-1,-8}
      \attribute{None}
      \attribute{North}
      \attribute{East}
      \attribute{South}
      \attribute{West}
    \end{enumeration}

    \begin{enumeration}[text width=3.5cm]{Freight}{4.25,-4.5}
      \attribute{Red}
      \attribute{Green}
      \attribute{Blue}
    \end{enumeration}

    \begin{enumeration}[text width=4cm]{TurnDirection}{10.5,-10.5}
      \attribute{Straight}
      \attribute{Left}
      \attribute{Right}
    \end{enumeration}

    \aggregation{World}{size}{1}{Size}
    \aggregation{World}{states}{*}{WorldState}
    \aggregation{WorldState}{tiles}{*}{Tile}
    \aggregation{WorldState}{truck}{1}{Truck}
    \aggregation{Tile}{trafficLights}{0..4}{TrafficLight}
    \unidirectionalAssociation{Truck}{turning}{1}{TurnDirection}
    \unidirectionalAssociation{Tile}{openings}{1..4}{TileOpening}
    \unidirectionalAssociation{Truck}{freight}{0..*}{Freight}
    \unidirectionalAssociation{Tile}{freight}{0..*}{Freight}
  \end{tikzpicture}
  \caption{Vereinfachtes UML-Diagramm der Weltobjektstruktur}
  \label{fig:implementation:program:uml}
\end{figure}

Wurzelelement dieser Struktur ist die \inlinec{World}-Klasse. Sie wird mit einer Beschreibung (\inlinec{WorldDescription}) der zu genrierenden Welt instanziiert. Anhand dieser Beschreibung erzeugt der Kontruktor die Größe (\inlinec{Size}) der Welt, einen Lastwagen (\inlinec{Truck}) und eine Menge von Kacheln (\inlinec{Tile}). Lastwagen und Kacheln werden in einen Weltzustand (\inlinec{WorldState}) verpackt. Die Daten eines einmal gespeicherten Zustandes werden nicht mehr geändert. Stattdessen wird eine Kopie des aktuellen Zustandes erzeugt, verändert und in die Liste aller Zustände abgespeichert. Dieses Vorgehen wurde gewählt, um dem Nutzer zu ermöglichen Aktionen wieder rückgängig zu machen. Außerdem vereinfacht sie die für die Animationen \TODO{Verweis} notwenige Interpolation zwischen Zuständen. Die Veränderung der Zustände übernimmt die \inlinec{World}-Klasse in der Operation \inlinec{command}.

\section{Programmiersprache}

Elemente der Sprache

\begin{itemize}
  \item Wichtigster Bestandteil sind die \emph{atomaren Befehle}. Durch die Aneinanderreihung mehrerer Befehle lässt sich bereits ein sinnvolles Programm implementieren. Als notwendige Befehle wurden identifiziert:
  \begin{itemize}
    \item \emph{Vorwärts fahren}: Bewegt den Lastwagen nach Vorne. Falls dabei ein Blinker in eine Richtung gesetzt ist, biegt der Laswagen in die entsprechende Richtung ab.
    \item \emph{Blinker links setzten}: Setzt den Blinker auf der linken Seite. Dadurch biegt der Lastwagen bei der nächsten Vorwärtsbewegung links ab.
    \item \emph{Blinker rechts setzten}: Setzt den Blinker auf der rechten Seite. Bei der nächsten Vorwärtsbewegung biegt der biegt der Lastwagen dadurch entsprechend rechts ab.
    \item \emph{Blinker ausschalten}: Schaltet einen vorher eingeschalteten Blinker wieder aus.
    \item \emph{Aufladen}: Läd ein Frachstück, welches vor dem Lastwagen liegt auf.
    \item \emph{Abladen}: Läd ein Frachtstück auf eine Ablagefläche oder einen leeren Steckenabschnitt vor dem Lastwagen wieder ab.
    \item \emph{Warten}: Wartet einen Zeitschritt ab. Dieser Befehl ist wichtig um das warten auf eine Ampel zu ermöglichen.
  \end{itemize}
  \item Um Codeverdoppelung zu vermeiden kann eine \emph{Schleife} eingesetzt werden, die einen Befehlsblock wiederholt. Die Anzahl der Wiederholungen kann vom Nutzer festgelegt werden.
  \item Um Verzweigungen Nutzen zu können, gibt es die Möglichkeit Werte von \emph{Sensoren} abzufragen. Sensoren stehen immer entweder auf Wahr oder Falsch. Folgende Sensoren stehen zur Verfügung:
  \begin{itemize}
    \item \emph{Ampel ist rot}: Dieser Sensor ist Wahr, wenn die Ampel vor dem Lastwagen rot ist. Ist, die Ampel grün, oder es gibt keine Ampel vor dem Lastwagen, so steht dieser Sensor auf Falsch.
    \item \emph{Ampel ist grün}: Ananlog dazu, ist dieser Sensor Wahr, wenn die Ampel vor dem Lastwagen grün ist und Falsch, wenn sie auf rot steht oder es keine Ampel vor dem Lastwagen gibt.
    \item \emph{Kann geradeaus fahren}: Dieser Sensor wertet zu Wahr aus, wenn das Straßennetz es zulässt, dass der Lastwagen im nächsten Schritt geradeaus fahren kann.
    \item \emph{Kann links abbiegen}: Dieser Sensor wertet zu Wahr aus, wenn im nächsten Schritt links abgebogen werden kann.
    \item \emph{Kann rechts abbiegen}: Wenn im nächsten Schritt nach rechts abgebogen werden kann, wertet dieser Sensor zu Wahr aus.
    \item \emph{Ist gelöst}: Wenn die aktuelle Welt gelöst wurde, also alle Frachtstücke zu ihren Zielen transporiert wurden, wertet dieser Sensor zu Wahr aus.
  \end{itemize}
  \item Mit den Sensoren ist es möglich eine \emph{Schleife mit Abbruchbedingung} zu nutzen. Diese wiederholt den Befehlsblock solange bis der angegebene Ausdruck zu Wahr auswertet.
  \item Sensoren ermöglichen außerdem \emph{Verzweigungen}, die einen Befehlsblock nur dann ausführen, wenn der angegebene Sensor zu Wahr ausgewertet wird.
  \item Es ist möglich den Wert von Sensoren zu \emph{negieren}.
  \item Mit Hilfe von \emph{Verknüfungen} mit "und" und "oder", können neue Ausdrücke erzeugt werden, welche wiederum in Schleifen und Verzweigungen verwendet werden können. So ist es z.B. möglich zu prüfen, ob das vorrausliegende Steckenstück eine Kurve ist: (Kann nicht geradeaus fahren und ((Kann links abbiegen und Kann nicht rechts abbiegen) oder (Kann nicht links abbiegen und Kann rechts abbiegen)))
  \item Desweiteren ist es möglich eigene \emph{Prozeduren} zu definieren und aufzurufen. Dies ermöglicht zusätzlich die Nutzung von Rekursion.
\end{itemize}

\subsection{Auswertung}

Für die Auswertung und Ausführung des durch den Syntaxbaum beschriebenen Code kommen zwei Vorgehensweisen infrage. Im Grundlagenkapitel \ref{sec:basics:compile-interpret} wurde der Unterschied zwischen Kompilieren und Interpretieren im klassischen Sinne bereits erklärt. Da im Browser jedoch nicht direkt Maschienencode ausgeführt werden kann ist der Unterschied in diesem Zusammenhang etwas anders zu verstehen.

\begin{itemize}
  \item Beim \emph{Interpretieren} wird der Syntaxbaum nach und nach durch ein in JavaScript geschriebenes Programm abgearbeitet und die entsprechenden Befehle direkt ausgeführt. In dieser Umgebung lässt sich der Fortschritt des Programms leicht verfolgen, da der Interpreter zu jedem Zeitpunkt die Position kennt bis zu der der Code bisher ausgeführt wurde. Dies ermöglicht den Einbau von Aussagekräftigen Debuggingfunktionen für den den auszuführenden Code.
  \item Im Unterschied dazu ist \emph{Kompilieren} in diesem Zusammenhang so zu verstehen, dass ein JavaScript-Programm den Syntaxbaum zunächst in einen vollständig ausführbaren JavaScript-Code überführt. Der JavaScript-Code liegt bei diesem Vorgehen nach dem Kompilieren als String vor und kann anschließend als ganzes in einer Art Sandkasten ausgeführt werden. Innerhalb dieser "Blackbox" lässt sich nur recht unzuverlässig auf den aktuellen Zustand des laufenden Programmes schließen ohne zusätzlichen Code code einzufügen, der die Lesbarkeit des generierten Codes verschlechtert. Eben diese Lesbarkeit des generierten Codes ist einer der wichtigsten Vortile dieser Vorgehensweise. Der Code lässt sich nicht nur für seine Ausführung nutzen, sondern kann gerade im Kontext einer Lernsoftware für den Nutzer interessant sein.
\end{itemize}

Im Verlauf der Arbeit wurde die Vorgehensweise "Kompilieren" an dieser Stelle als Anforderung festgelegt, da dieses Vorgehen speziell für BlattWerkzeug den Vorteil mit sich bringt, dass generierter Code in Zukunft vor der Ausführung noch vom Nutzer angesehen und bearbeitet werden kann, was den Übergang zu einer Universalsprache erleichtern würde \TODO{Verweis auf Ausblick}.

Für die Kompilierung des Syntaxbaum wird auf den von BlattWerkzeug zur Verfügung gestellten Codegenerator-Strukturen zurückgegriffen, die es ermöglichen einen Codegenrator zu implementieren, der Übersetzungsregeln für jeden Knotentypen definiert. \figreft{fig:implementation:program:evaluation:while} zeigt die Implementierung eines Codegenrators für Knoten, die eine While-Schleife repräsentieren. Zwischen den Klammern innerhalb der \inlinec{while}-Anweisung wird der Kindknoten für die Bedingung der Schleife eingefügt, gefolgt vom Inhalt der Schleife. Diese Kindknoten werden wiederrum durch ähnlich aufgebaute Generatoren umgewandelt bis der Vollständige Code des Wurzelknoten im Syntaxbaum generiert wurde.

\begin{figure}[h]
  \begin{lstlisting}
    {
      type: {
        languageName: "trucklino_program",
        typeName: "loopWhile"
      },
      converter: {
        init: function(node: Node, process: CodeGeneratorProcess<State>) {
          process.addConvertedFragment(`while (`, node);
          node.getChildrenInCategory('pred').forEach((c) => process.generateNode(c));
          process.addConvertedFragment(`) {`, node, OutputSeparator.NEW_LINE_AFTER);
          process.indent(() => {
            node.getChildrenInCategory('body').forEach((c) => process.generateNode(c));
          });
          process.addConvertedFragment(`}`, node, OutputSeparator.NEW_LINE_AFTER);
        }
      }
    }
  \end{lstlisting}
  \caption{Beispielhafte Implementierung eines Codegenrator für eine While-Schleife}
  \label{fig:implementation:program:evaluation:while}
\end{figure}

- Funktionen und Sensoren aufrufen, verschiedene Möglichkeiten:
    - Eine Funktion für Befehle, eine Funktion für Sensoren und gewünschten Befehl/Sensor als Konstante. Vorteil: Sehr gute Wartbarkeit, da Befehle nur an einer Stelle hinzugefügt werden müssen. Nachteil: Unintuitiver generierter Code / Anders als "übliche" Schreibweise
    - Funktionen und Befehle werden im Kontext übergeben und über this aufgerufen. Vorteil: Gute wartbarkeit (wenn auch doppelte Pflege notwendig), Codelesbarkeit gut, Einfache übergabe im Objekt. Nachteil: Vor jeder Funktion/Sensor muss ein this stehen
    - Funktionen und Befehle werden als Parameter übergeben. Vorteil: Direkter Aufruf der Funktionen ohne zusätzlichen Code dadurch sehr gute Codelesbarkeit. Nachteil: Unübersichliche Definition der Funktion und dadurch schlechtere Wartbarkeit.

\section{Darstellung}

\subsection{Technologie}

Also mögliche Technologien für die Darstellung und Animation der Welt im Browser wurden im vier Ansätze evaluiert.

\begin{itemize}
  \item Rendering über klassische \emph{HTML}-Elemente und Styling mittels CSS und Integration von nachgeladenen Bilddateien.
  \item Rendering mittels eines eingebetteten \emph{SVG}-Element.
  \item Rendering mittels eines \emph{Canvas}-Element und Integration von nachgeladenen Bilddateien.
  \item Einsatz von \emph{WebGL} für die Darstellung einer dreidimensionalen Welt.
\end{itemize}

WebGL ist als Technologie für diese Arbeit als zu mächtig einzustufen. Die Erstellung von dreidimensionalen Modellen hätte den Rahmen dieser Arbeit gesprengt und im Vergleich zu den übrigen Technologien keinen nennenswerten Nutzen gehabt.

Rendering mittels HTML und SVG haben den Vorteil, dass sie sehr von den Funktionen des Angular-Framework profitieren. Die Datenstruktur kann direkt an HTML-Elemente angebunden werden und Angular kümmert sich um die Aktualisierung des DOM. Dieses Vorgehen reduziert den Aufwand für die Implementierung des Renderes enorm. Zusätzlich bringt Angular nativ ein Animationsframework mit. Für die Implementierung eines Prototyp wurde das Rendering mittels eines SVG-Element gewählt, da es gegenüber einfachem HTML den Vorteil bietet, Grafiken direkt und ohne zusätliches Nachladen von Ressourcen integrieren zu können.

In der Implementierung des Prototyp erwies sich aber genau dieses Animationsframework als ein Nachteil dieser Technologie. Angular setzt an dieser Stelle auf ein Zustandsbasiertes System. Eine Animationen finden immer zwischen definierten Zuständen statt. Zustände können bestimmte CSS Regeln definieren, zwischen denen bei einem Zustandswechel interpoliert wird \cite{angular-animations}. Dieses System ist mit den Anforderungen, die der im Rahmen dieser Arbeit behandelte Anwendungsfall stellt nicht kompatibel. Für die Animation eines Lastwagen müsste vielmehr zwischen verschiedenen Positionen interpoliert werden. Diese lassen sich nicht sinnvoll auf Zustände abbilden.

So setzt die aktuelle Version des Programms auf einen Renderer mittels Canvas-Element. Dass Angular keine Funktionen zum Rendern in einem Canvas-Element bereithält und dieser Prozess vollständig außerhalb und unabhängig von Angular stattfinden muss, \TODO{entpuppte / besseres Wort!} sich schnell als Vorteil. Der Renderer hat dadurch keine externen Abhängigkeiten, ermöglicht eine leichte Integration in BlattWerkzeug und könnte potenziell auch in eine Anwendung portiert werden, welche Angular nicht einsetzt.

\subsection{Objektstruktur}

Die Objektstruktur des Renderers ist in \figreft{fig:implementation:rendering:uml} zur besseren Übersicht vereinfacht dargestellt. Wurzelklasse ist hier der Renderer, welche mit einem \inlinec{World}-Objekt (Die Objektstruktur wurde in Abschnitt \ref{sec:implementation:structure} beschrieben) und einem Canvas-Context instanziiert wird. Mit dem Aufruf der \inlinec{render}-Methode wird der Render-Prozess gestartet. Diese Methode zeichnet den Canvas-Inhalt und ruft sich mittels der \inlinec{requestAnimationFrame}-Funktion\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}} immer wieder selbst auf.

Die Eigentliche Zeichenaufgabe gibt die \inlinec{Renderer}-Klasse jedoch an einen Baum von \inlinec{ObjectRenderer}-Klassen ab, die für die Darstellung wehsentlicher visueller Objekte zuständig sind. Die Struktur der \inlinec{ObjectRenderer} ist an der Weltobjektstruktur \tref{sec:implementation:structure} orientiert. Die \inlinec{Renderer}-Klasse hält eine Instanz eines \inlinec{WorldRenderer}, welcher die von ihm gehaltene \inlinec{WorldStateRenderer}-Instanz über Zustandsänderungen der Welt informiert. Der \inlinec{WorldStateRenderer} verwaltet genau eine \inlinec{TruckRenderer}-Instanz, welche für das letztendliche Zeichnen des Lastwagen und die Animation von dessen Zustandsübergängen verantwortlich ist, sowie die notwenige Anzahl von \inlinec{TileRenderer}-Instanzen. Die \inlinec{draw}-Methode der \inlinec{ObjectRenderer} werden immer mit einem \inlinec{RenderingContext} aufgerufen, welcher den Zeitstempel der Animation verwaltet, einen Verweis auf den zu verwendenden Canvas-Context enhält, sowie einige Hilfsmethoden zum Zeichnen auf demselbigen bereitstellt.

\begin{figure}[h]
  \begin{tikzpicture}
    \tikzstyle{every node}=[font=\small]

    \begin{class}[text width=7cm]{Renderer}{1,0}
      \attribute{running: boolean}

      \operation{constructor(world: World, ctx: CanvasContext)}
      \operation{stop()}
      \operation{render(timestamp: TimeStamp)}
    \end{class}

    \begin{class}[text width=5cm]{RenderingContext}{9,0}
      \attribute{ctx: CanvasRenderingContext2D}
      \attribute{width: number}
      \attribute{height: number}
      \attribute{start: TimeStamp}
      \attribute{previousFrame: TimeStamp}
      \attribute{currentFrame: TimeStamp}

      \operation{animationSpeed(): number}
    \end{class}

    \begin{interface}[text width=5cm]{ObjectRenderer}{3.5,-3}
      \operation{draw(ctx: RenderingContext)}
    \end{interface}

    \begin{class}[text width=3cm]{WorldRenderer}{-1,-5}
      \implement{ObjectRenderer}

      \attribute{world: World}

    \end{class}

    \begin{class}[text width=4cm]{WorldStateRenderer}{-0.5,-7.5}
      \implement{ObjectRenderer}

      \attribute{state: WorldState}
      \attribute{freightTarget: Freight}

      \operation{update(state: WorldState)}
    \end{class}

    \begin{class}[text width=2.75cm]{TileRenderer}{5.5,-6}
      \implement{ObjectRenderer}

      \attribute{tile: Tile}

      \operation{update(tile: Tile)}
    \end{class}

    \begin{class}[text width=3.5cm]{TruckRenderer}{9.75,-7}
      % \implement{ObjectRenderer}

      \attribute{truck: Truck}
      \attribute{prevTruck: Truck}
      \attribute{initial: number}

      \operation{update(truck: Truck)}
    \end{class}

    \composition{Renderer}{ctx}{1}{RenderingContext}
    \composition{Renderer}{worldRenderer}{1}{WorldRenderer}
    \composition{WorldRenderer}{stateRenderer}{1}{WorldStateRenderer}
    \composition{WorldStateRenderer}{truckRenderer}{1}{TruckRenderer}
    \composition{WorldStateRenderer}{tileRenderers}{0..*}{TileRenderer}

    \draw[umlcd style implement line](ObjectRenderer) -- (TruckRenderer.north);
  \end{tikzpicture}
  \caption{Vereinfachtes UML-Diagramm der Rendererobjektstruktur}
  \label{fig:implementation:rendering:uml}
\end{figure}

Wenn die \inlinec{render}-Methode aus einer Angular-Anwendung heraus aufgerufen wird, empfielt es sich diesen Aufruf außerhalt der Angular-Zone vorzunehemen. Angularanwendungen werden immer innerhalb der "Angular-Zone" ausgeführt. Wenn ein Browserereignis (z.B. ein Klick oder ein \inlinec{setTimeout}) eintritt, wird die Angular Zone betreten und der Code zur Ereignisbehandlung ausgeführt. Anschließend führen die Zone und Angular die Änderungserkennung für die Anwendung durch. In den meisten Fällen ist dieses Verhalten erwünscht. Beim Zeichnen führt dies jedoch dazu, dass \inlinec{requestAnimationFrame} ebenfalls in der Angular-Zone ausgeführt wird. Dies bedeutet, wenn eine Animation läuft, werden pro Sekunde bis zu 60 Änderungserkennungen ausgeführt. \cite{angular-canvas} Da die \inlinec{render}-Methode lediglich der Darstellung dient, keinerlei Änderungen an der Welt oder ihren Zuständen vornimmt und somit nie Änderungen zu detektieren sein werden, kann und muss sie dementsprechend außerhalb der Angular-Zone ausgeführt werden.

\subsection{Lastwagen-Position}

- Möglichkeit A: Lastwagen halten auf Mitte der Kachel und drehen sich auf der
                 Stelle => Lastwagen können auch wenden, aber das Verhalten
                 sieht unnatürlich aus.
- Möglichkeit B: Lastwagen halten auf dem Rand der Kachel und es kann ein
                 Blinker nach links oder rechts gesetzt werden, der die
                 Fahrtrichtung beim nächsten Vorwärtsfahren beeinflusst
                 => Verhalten sieht deutlich natürlicher aus und ist näher am
                 Vorbild. Allerdings kann der Lastwagen nun nicht mehr auf der
                 Stelle wenden und muss eventuell längere Strecken fahren.
                 => Erste Idee: Pfeil davor anzeigen, Zweite Idee: Blinker
                 => Rückwärts fahren?

- Bewegung: Absolut (N, E, S, W) vs. Relativ (Links, Rechts, Geradeaus)

\subsection{Animationsschritte}

- Neuer Zustand für jede Operation
- Zustände haben unterschiedliche Zeitwerte: Blinker setzen kostet keine Zeit,
  geradeaus fahren oder warten kostet einen Zeitschritt
- Zeitschritte sind besonders für die Berechnung der Ampelstellung relevant
- Position des Lastwagen wird schrittweise interpoliert

- Schitte haben eine feste Zeit, die aber übersprungen wird, wenn ein neuer
  Schritt vor ablauf der Zeit dazu kommt. Dadurch kann ein Programm auch im
  "Schnelldurchlauf" abgespielt werden.

- Kompilieren in JS-Code mit async await
- new AsyncFunction (TypeScript-Compiler-Problem, Anforderung an den Browser)

\section{Integration}

Um mit möglichst wenigen Abhängigkeiten und dadurch der Möglichkeit mit geringerem Zeitaufwand verschiedene Ansätze ausprobieren zu können, wurde zunächst mit der Entwicklung eines Prototypen auf einer "grünen Wiese" begonnen. Auch wenn der Prototyp als Angular-Anwendung aufgesetzt wurde, erfolgte der Großteil der Entwicklung erfolge außerhalb dieser Umgebung. Nachdem der ursprüngliche Ansatz der Darstellung mittels SVG-Grafiken verworfen wurde und die Darstellung auf Canvas-Rendering umgestellt wurde, sind die Objektstruktur, sowie der Renderer wurden völlig unabhängig von Angular, da sie von den von Angular bereitgestellten Strukturen nicht profitieren können. Diese Klassen konnten so ohne Anpassungen in die Umgebung von BlattWerkzeug übernommen werden. Lediglich die rudimentäre Benutzeroberfläche des Prototypen \TODO{Screenshot Prototyp} wurde mit Hilfe von Angular umgesetzt, für die Integration in BlattWerkzeug jedoch nicht mehr benötigt.

\subsection{Angular-Service}

- Auslagerung der Welt in einen Service

\subsection{Fortschrittsmeldungen}

- Rückmeldung über den Fortschritt des Programm zur Anzeige im Drag \& Drop-Editor => Ausblick?
