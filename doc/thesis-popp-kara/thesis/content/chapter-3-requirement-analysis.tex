%************************************************
% Anforderungsanalyse
%************************************************
\chapter{Anforderungsanalyse}
\label{sec:requirements}

Aufgabe der Abschlussarbeit ist die Integration eines Tools zum spielerischen Erlernen von Programmierfähigkeiten in die von Marcus Riemer entwickelte Lehr-Entwicklungsumgebung BlattWerkzeug \tref{sec:requirements:existing}. Als Vorbilder dieser Anwendung dienen dabei Kara \tref{sec:related:kara} und Lightbot \tref{sec:related:lightbot}. Im Folgenden sind die Anforderungen an dieses Programm näher beschrieben.

%************************************************
% Vorhandenes Projekt
%************************************************
\section{Vorhandenes Projekt}
\label{sec:requirements:existing}

Marcus Riemer hat im Rahmen seiner Master-Thesis an der Fachhochschule Wedel die Lehr-Entwicklungsumgebung BlattWerkzeug entwickelt, die sich an Kinder und Jugendliche richtet. Mit BlattWerkzeug lassen sich gestützt durch Drag \& Drop-Editoren für beliebige SQLite-Datenbanken Abfragen formulieren und Oberflächen entwickeln~\cite[2]{riemer2016}.

\subsection{Aufbau}

\subsubsection{Server}

Der Server ist auf Basis von Ruby mit Sinatra gebaut. Er dient hauptsächlich der Speicherung und Auslieferung von Daten. Kommuniziert wird primär über eine REST-artige JSON-Schnittstelle~\cite[94]{riemer2016}.

Die für diese Arbeit entwickelte Software baut jedoch lediglich auf dem Client von BlattWerkzeug auf und hat mit der serverseitigen Anwendung keine direkten Berührungspunkte.

\subsubsection{Client}

Der Client wurde als eine Single-Page Application mit rein clientseitiger Visualisierung aufgebaut, die weitestgehend auf Roundtrips zum Server verzichtet~\cite[94-95]{riemer2016}. Programmiert wurde sie auf Basis von Angular 2 in TypeScript, wobei der aktuelle Stand inzwischen auf eine höhere Angular-Version setzt.

Durch die direkte Einbindung des im Rahmen dieser Arbeit erstellten Programms, ist die Implementierung in Angular und TypeScript fest vorgegeben.

\subsection{Drag \& Drop-Editor}

Besonders hervorgehoben werden soll an dieser Stelle der Drag \& Drop-Editor von BlattWerkzeug. Auch wenn er nicht direkt Teil dieser Arbeit ist, spielt er doch eine entscheidende Rolle, da über ihn der Großteil der Interaktion abläuft. Programmcode wird nicht getippt sondern aus unterschiedlichen Bausteinen mit der Maus zusammengesetzt.

\begin{quote}
    "So nutzt auch BlattWerkzeug einen Drag \& Drop-Editor um Syntaxfehler von vornherein auszuschließen und kontextsensitiv mögliche Operationen hervorzuheben."~\cite[6]{riemer2016}
\end{quote}

Die Bausteine des Drag \& Drop-Editor und deren Kombinationsmöglichkeiten werden durch die Grammatik festgelegt, die in \treft{sec:requirements:program} näher beschrieben wird. Ergebnis des Drag \& Drop-Editor ist nach dem Bearbeiten durch den Nutzer dann ein Syntaxbaum, der alle Operationen enthält und vom Programm weiterverarbeitet werden kann. \figreft{fig:requirements:existing:draganddrop} zeigt ein Bildschirmfoto des Drag \& Drop-Editor mit einem vollständigen Programm.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{gfx/3-requirements-existing-draganddrop.png}
    \caption{Bildschirmfoto des Drag \& Drop-Editor in BlattWerkzeug}
    \label{fig:requirements:existing:draganddrop}
\end{figure}

%************************************************
% Zielgruppe
%************************************************
\section{Zielgruppe}
\label{sec:requirements:target}

Die Zielgruppe wird zum Teil natürlich auch über die Zielgruppe von BlattWerkzeug definiert, wobei sie im Folgenden noch etwa spezieller formuliert und erweitert werden soll.

BlattWerkzeug definiert die Zielgruppe auf Schüler und Schülerinnen ab der Mittelstufe mit grundlegenden PC-Anwenderkenntnissen. Kenntnisse über den Umgang mit Tabellenkalkulationsprogrammen werden nicht als zwingende Voraussetzung, aber als eine sinnvolle Vorstufe, um die Strukturierungsmöglichkeiten von Datenbeständen zu verstehen, angesehen. Für die Entwicklung von Oberflächen werden grundlegende Vorstellungen über die Funktionsweise und Parameter einiger Bedienelemente benötigt. Außerdem wird das Wissen über einzelne englische Vokabeln vorrausgesetzt~\cite[22-23]{riemer2016}.

Bei den Schülern sollten grundlegende PC-Anwenderkenntnisse zur Bedienung des Tools vorhanden sein. Dazu gehört das starten und Bedienen eines Webbrowsers, was bei den meisten Schülern allerdings vorrausgesetzt werden können sollte. Kenntnisse über den Umgang mit Tabellenkalkulationsprogrammen und Vorstellungen über die Funktionsweise und Parameter einiger Bedienelemente ist für die Benutzung nicht notwendig. Schüler, die noch nie mit dem Thema Programmierung in Berührung gekommen sind, sollten bei den ersten Schritten von einer Lehrkraft begleitet werden. Nachdem erste Erfahrungen gesammelt wurden, sollten Schüler dann auch selbstständig in der Lage sein neue Möglichkeiten zu entdecken und neue Aufgaben zu lösen. Eine Begleitung in Form einer Schritt für Schritt Anleitung durch die Software ist zunächst nicht geplant.

Außerdem sollen auch Lehrer in die Zielgruppe mit aufgenommen werden, denen die Möglichkeit gegeben werden soll Welten und damit Aufgaben für Ihre Schüler zu erstellen und vorzubereiten \tref{sec:requirements:world} und ihre Schüler bei der Lösung der Aufgaben zu unterstützen.

% \TODO{Evtl. grafische Darstellung der Akteure}

%************************************************
% Spielerisches Lernen
%************************************************
\section{Spielerisches Lernen}

Die im Rahmen dieser Arbeit entwickelte Software soll Lehrer dabei unterstützen ihren Schülern die Grundlagen des Programmierens zu vermittelt. Dies soll spielerisch geschehen. Prensky führt in seinem Buch \textit{Digital Game-Based Learning} drei Gründe an warum digitales spielerisches Lernen funktioniert~\cite[147]{prensky2007}:

\begin{enumerate}
    \item Der Erste ist das zusätzliche Engagement, das dadurch entsteht, dass das Lernen in einen Spielkontext gebracht wird. Dies kann beträchtlich sein, besonders wenn Menschen nicht lernen wollen.
    \item Der Zweite ist der interaktive Lernprozess. Dier kann und sollte abhängig von den Lernzielen viele verschiedene Formen annehmen.
    \item Der Dritte ist die Art und Weise, wie die Zwei im Gesamtpaket zusammengefügt werden. Es gibt viele Möglichkeiten, dies zu tun, und die beste Lösung ist sehr kontextabhängig.
\end{enumerate}

Desweiteren hängt der Lernerfolg auch immer stark davon ab, wie Spiele vom Lehrer letztendlich eingesetzt werden, aber auch der Stil des Spieles spielt eine Rolle. Damit Spiele -- Lehrspiele im speziellen -- Spaß bringen, müssen sie einige Anforderungen erfüllen. Malone stellt in seinem Artikel \textit{What Makes Computer Games Fun?} eine Checkliste auf, die sich in drei Kategorien gliedert und unter anderem die folgenden Fragen enthält~\cite[49]{malone1981}:

\begin{itemize}
    \item \emph{Herausforderung}: Hat das Spiel ein Ziel? Hat das Spiel einen variablen Schwierigkeitsgrad? Verfügt die Aktivität über mehrere Ziele, z. B. Zählen von Punkten oder schnelle Reaktionen? Enthält das Programm Zufall? Enthält das Programm versteckte Informationen die selektiv aufgedeckt werden?
    \item \emph{Fantasie}: Enthält das Programm eine emotional ansprechende Fantasie? Hängt die Fantasie instinktiv mit der in der Aktivität erlernten Fähigkeit zusammen? Ist die Fantasie eine nützliche Metapher?
    \item \emph{Neugierde}: Gibt es audio- und visuelle Effekte, um die Neugier der Sinne zu stimulieren? Gibt es Elemente, die die kognitive Neugier wie Überraschungen oder konstruktives Feedback stimulieren?
\end{itemize}

Auch wenn nicht alle Anforderungen durch das entwickelte Spiel erfüllt werden können, sollte es doch das Ziel sein, so vielen wie möglich gerecht zu werden, um die Aktivität für den Schüler so interessant wie möglich zu gestalten.

%************************************************
% Welt
%************************************************
\section{Welt}
\label{sec:requirements:world}

Die im vorherigen Abschnitt beschriebenen Anforderungen lassen sich sehr gut mit den Lernzielen vereinbaren. Ein Objekt wird mit programmierten Befehlen durch eine virtuelle Welt geführt. Der Spieler löst so eine Art Puzzelrätsel.

\subsection{Handlungsgerüst}
\label{sec:requirements:world:metaphor}

Um nachfolgend die Definition der Anforderungen zu erleichern, wird bereits an dieser Stelle die Metapher beschrieben. Ziel des Spiels soll es sein mit Hilfe eines Lastwagen, welcher vom Spieler über Programmbefehle steuerbar ist \tref{sec:requirements:program}, über ein Netz von Straßen, verschiedenfarbige Container an ihre vorgesehenen Ziele zu bringen. Dabei ist die Ladefläche des Lastwagen begrenzt, womit unter Umständen mehrfache Fahrten notwendig sind. Zusätzlich kann der Tank des Lastwagen begrenzt werden, wodurch es für die Lehrkraft denkbar wäre eine effiziente Routenführung Teil der Aufgabe zu machen.

Diese Metapher wurde gewählt, da der Transport von Waren in dieser vereinfachten Darstellung jedem bekant sein sollte. Außerdem bietet die Metapher verschiedene Erweiterungsmöglichkeiten und ermöglicht eine schrittweise Erhöhung der Komplexität. So ist z.B. die Einführung von Verkehrsampeln zur Vermittlung des Konzeptes der Verzweigungen denkbar.

\subsection{Datenstruktur}
\label{sec:requirements:world:structure}

In Anlehnung an Kara soll die Möglichkeit gegeben werden neue Level, bzw. Aufgaben zu entwerfen. Jede Aufgabe besteht dabei aus einer Welt, wobei sowohl Lehrer, als auch Schüler in der Lage sein sollen neue Welten zu erstellen. Die Funktion richtet sich jedoch primär an die Lehrkraft. In Anlehnung an Lightbot ist das Ziel der Aufgabe jedoch immer dadurch definiert, dass alle Container -- die sich zu Beginn des Level bereits auf der Ladefläche oder an einer beliebigen Straße im Spielfeld befinden können -- an ihr vorgesehenes Ziel gebracht werden.

Es kann davon ausgegangen werden, dass ein Lehrer für das Fach Informatik über Erfahrung in der Bedienung auch von komplexeren Programmen verfügt. Daher kann die Umgebung zur Gestaltung der Level eher zweckmäßig sein und setzt keinen Fokus auf eine leichte Bedienung.

Um diese Funktionalität zu ermöglichen, muss für BlattWerkzeug eine Datenstruktur entwickelt werden, durch die sich mit dem Drag \& Drop-Editor eine Welt bauen lässt.

%************************************************
% Programm
%************************************************
\section{Programm}
\label{sec:requirements:program}

Die Bewegungsabläufe wie z.B. "geradeaus fahren", "links abbiegen", "rechts abbiegen" oder "warten" werden vom Nutzer mithilfe des Drag \& Drop-Editor programmiert. Dafür wird eine Minisprache eingeführt, die über einen reduzierten Funktionsumfang verfügt und dadurch den Nutzer behutsam an das Thema heranführen soll und ihn nicht wie Universalsprachen mit einem großen Sprachumfang und der damit verbundennen steileren Lernkurve überfordern soll. Brusilovsky et al. heben in Ihrem Artikel \textit{Mini-languages: a way to learn programming principles} einige Eigenschaften von Minisprachen als besonders wichtig hervor \cite[73-74]{brusilovsky1997}:

\begin{itemize}
    \item Sowohl Syntax, als auch Semantik der Sprache sollte \emph{einfach} sein.
    \item Die Operationen der Minisprache sollten \emph{sichtbar} sein. Die meisten Operationen, die der Akteur ausführt, sollten sichtbare Änderungen in der auf dem Bildschirm dargestellten Mikrowelt vornehmen.
    \item Die Minisprache sollte für die vorgesehene Kategorie von Studenten \emph{attraktiv} und aussagekräftig sein.
    \item Die Sprache sollte \emph{dialogorientiert} sein. Das bedeutet, dass die Sprache Befehl für Befehl in einem Navigationsmodus ausgeführt werden kann (Einzelbefehlsausführung) und als Ganzes in einem Programmiermodus (komplexe Programmausführung).
    \item Die Sprache sollte \emph{modular} sein. Sie sollte einen Mechanismus zum Erstellen abstrakter Anweisungen (Prozeduren) enthalten. Alle Verfahren sollten unabhängige Einheiten sein. Eine solche Prozedur kann als neuer Befehl des Akteurs betrachtet werden, der sowohl im Navigations- als auch im Programmiermodus verwendet werden kann.
\end{itemize}

% Brusilovsky et al. nennen in Ihrem Artikel \textit{Mini-languages: a way to learn programming principles} drei Probleme mit Universalsprachen (wie z.B. Java oder C) für die Anwendung zum Lernen, die Minisprachen zu beheben versuchen \cite[67]{brusilovsky1997}:

% \begin{itemize}
%     \item Universalsprachen sind zu groß und zu idiosynkratisch. Die konzeptionelle Basis der Sprache bildet zusammen mit den Hauptprinzipien der Programmierung eine große Menge an Material. Anstatt die Grundprinzipien hervorzuheben, rufen die Sprachen \TODO{evoke secondary notions / sekundäre Begriffe} hervor, die die Feinheiten der jeweiligen Sprache und deren Umsetzung widerspiegeln.
%     \item Universalsprachen fördern nicht das Verständnis ihrer grundlegenden Aktionen und Kontrollstrukturen. Die Sprachen sind nicht visuell und ihre Grundfunktionen werden hinter einer undurchsichtigen Barriere ausgeführt. Wenn der Prozess der Programmausführung verborgen ist, entwickelt der Student ein Input-Output-orientiertes Verständnis. Auf diese Weise behindert das Fehlen von visuellem Feedback die Beherrschung der Sprachsemantik.
%     \item Da sich Universalsprachen an der Zahlen- und Symbolverarbeitung orientieren, sind die ersten möglichen Aufgaben, die beim Unterrichten der Sprache umgesetzt werden können, weit von den Alltagserfahrungen der Schüler entfernt. Die Entwicklung von Anwendungen, die sowohl informativ als auch interessant sind, erfordert das Erlernen einer beträchtlichen Untermenge der Sprache und das Schreiben recht großer Programme.
% \end{itemize}

\subsection{Datenstruktur}
\label{sec:requirements:program:structure}

\TODO{Datenstruktur}

\subsection{Kompilieren / Interpretieren}
\label{sec:requirements:world:compile-interpret}

\TODO{Kompilieren / Interpretieren}

% Wagenknecht und Hielscher beschreiben den Unterschied zwischen Kompilieren und Interpretieren wie folgt:

% \begin{quote}
%     "Programme, die Programme einer Quellsprache in zugehörige Programme einer Zielsprache überführen, nennt man \emph{Compiler}. [...] Statt Anwendungsprogramme aus maschienennahen Instruktionen aufzubauen, verwendet man menschenfreundlichere Sprachelemente [...]. Damit diese Programme von [...] einem Prozessor und dem Betriebsystem verarbeitet werden können, ist eine entsprechende Übersetzung notwendig. [...] \emph{Interpreter} gehen anders vor als Compiler. Das vorgelegte Programm wird nicht vollständig übersetzt, sondern "portionsweise" analysiert, in eine zugehörige Folge von Prozessorintruktionen übertragen und ausgeführt."~\cite[47]{wagenknecht2009}
% \end{quote}

\subsection{Darstellung der Ausführung}
\label{sec:requirements:world:display}

\TODO{Darstellung der Ausführung}
